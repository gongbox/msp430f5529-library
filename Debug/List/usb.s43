///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:47 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_Common\usb.c                         /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_Common\usb.c -D DEBUG -D RAM_VECTOR  /
//                     -lA E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\ /
//                     List\ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\D /
//                     ebug\Obj\ --no_cse --no_unroll --no_inline             /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \usb.s43                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME usb

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero20
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK USBCTL
        PUBWEAK USBFUNADR
        PUBWEAK USBIE
        PUBWEAK USBIEPIE
        PUBWEAK USBIFG
        PUBWEAK USBOEPIE
        PUBLIC USB_InitSerialStringDescriptor
        FUNCTION USB_InitSerialStringDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 26, STACK
        PUBLIC USB_connect
        FUNCTION USB_connect,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_connectionInfo
        FUNCTION USB_connectionInfo,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_connectionState
        FUNCTION USB_connectionState,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_disable
        FUNCTION USB_disable,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_disconnect
        FUNCTION USB_disconnect,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_enable
        FUNCTION USB_enable,021201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC USB_forceRemoteWakeup
        FUNCTION USB_forceRemoteWakeup,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_getEnabledEvents
        FUNCTION USB_getEnabledEvents,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_init
        FUNCTION USB_init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 10, STACK
        PUBLIC USB_reset
        FUNCTION USB_reset,021201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC USB_resume
        FUNCTION USB_resume,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_setEnabledEvents
        FUNCTION USB_setEnabledEvents,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_suspend
        FUNCTION USB_suspend,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBWEAK _A_UCSCTL6_L
        PUBWEAK _A_USBCNF_L
        PUBWEAK _A_USBKEYID_L
        PUBWEAK _A_USBPHYCTL_L
        PUBWEAK _A_USBPLLCTL_L
        PUBWEAK _A_USBPLLDIVB_L
        PUBWEAK _A_USBPLLIR_L
        PUBWEAK _A_USBPWRCTL_L
        PUBWEAK abIEP0Buffer
        PUBWEAK abOEP0Buffer
        PUBLIC abUsbRequestIncomingData
        PUBLIC abUsbRequestReturnData
        PUBLIC abramSerialStringDescriptor
        PUBLIC bEnumerationStatus
        PUBLIC bFunctionSuspended
        PUBLIC bStatusAction
        PUBWEAK tEndPoint0DescriptorBlock
        PUBWEAK tInputEndPointDescriptorBlock
        PUBWEAK tOutputEndPointDescriptorBlock
        PUBWEAK tSetupPacket
        PUBLIC usbClearDeviceFeature
        FUNCTION usbClearDeviceFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbClearEndpointFeature
        FUNCTION usbClearEndpointFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbClearOEP0ByteCount
        FUNCTION usbClearOEP0ByteCount,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbDecodeAndProcessUsbRequest
        FUNCTION usbDecodeAndProcessUsbRequest,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 40, STACK
        PUBLIC usbGetConfiguration
        FUNCTION usbGetConfiguration,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetConfigurationDescriptor
        FUNCTION usbGetConfigurationDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetDeviceDescriptor
        FUNCTION usbGetDeviceDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetDeviceStatus
        FUNCTION usbGetDeviceStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetEndpointStatus
        FUNCTION usbGetEndpointStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC usbGetInterface
        FUNCTION usbGetInterface,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetInterfaceStatus
        FUNCTION usbGetInterfaceStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetStringDescriptor
        FUNCTION usbGetStringDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC usbInvalidRequest
        FUNCTION usbInvalidRequest,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbReceiveDataPacketOnEP0
        FUNCTION usbReceiveDataPacketOnEP0,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbReceiveNextPacketOnOEP0
        FUNCTION usbReceiveNextPacketOnOEP0,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSendDataPacketOnEP0
        FUNCTION usbSendDataPacketOnEP0,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC usbSendNextPacketOnIEP0
        FUNCTION usbSendNextPacketOnIEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSendZeroLengthPacketOnIEP0
        FUNCTION usbSendZeroLengthPacketOnIEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetAddress
        FUNCTION usbSetAddress,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetConfiguration
        FUNCTION usbSetConfiguration,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetDeviceFeature
        FUNCTION usbSetDeviceFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetEndpointFeature
        FUNCTION usbSetEndpointFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetInterface
        FUNCTION usbSetInterface,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbStallEndpoint0
        FUNCTION usbStallEndpoint0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbStallOEP0
        FUNCTION usbStallOEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC wBytesRemainingOnIEP0
        PUBLIC wBytesRemainingOnOEP0
        PUBLIC wUsbEventMask
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN tUsbRequestList
        EXTERN USB_handleEnumCompleteEvent
        FUNCTION USB_handleEnumCompleteEvent,0200H
        EXTERN stUsbHandle
        EXTERN MscReadControl
        EXTERN MscWriteControl
        EXTERN abromConfigurationDescriptorGroup
        EXTERN abromStringDescriptor
        EXTERN abromDeviceDescriptor
        EXTERN bMscResetRequired
        EXTERN bMcsCommandSupported
        EXTERN XT2_Start
        FUNCTION XT2_Start,0202H
        EXTERN HidResetData
        FUNCTION HidResetData,0200H
        EXTERN isMSCConfigured
        EXTERN MscResetData
        FUNCTION MscResetData,0200H
        EXTERN CdcResetData
        FUNCTION CdcResetData,0200H
        EXTERN Get_TLV_Info
        FUNCTION Get_TLV_Info,0202H
        EXTERN USB_initMemcpy
        FUNCTION USB_initMemcpy,0202H
        EXTERN MscResetCtrlLun
        FUNCTION MscResetCtrlLun,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c
//    1 // (c)2010 by Texas Instruments Incorporated, All Rights Reserved.
//    2 /*----------------------------------------------------------------------------+
//    3 |                                                                             |
//    4 |                              Texas Instruments                              |
//    5 |                                                                             |
//    6 |                          MSP430 USB-Example (CDC/HID Driver)                |
//    7 |                                                                             |
//    8 +-----------------------------------------------------------------------------+
//    9 |  Source: usb.c, File Version 1.02 2010/06/17                                |
//   10 |  Author: RSTO                                                               |
//   11 |                                                                             |
//   12 |  WHO          WHEN         WHAT                                             |
//   13 |  ---          ----------   ------------------------------------------------ |
//   14 |  RSTO         2008/09/03   born                                             |
//   15 |  RSTO         2008/12/23   enhancements of CDC API                          |
//   16 |  RSTO         2009/01/12   enhancements for USB serial number               |
//   17 |  RSTO         2009/05/15   added USB_connectionState()                      |
//   18 |  RSTO         2009/07/17   added __data16 qualifier for USB buffers         |
//   19 |  RSTO         2009/08/04   workaround for PLL start up problem              |
//   20 |  MSP,Biju     2009/10/20   Changes for composite support                    |
//   21 |  RSTO         2009/10/21   updated USB_InitSerialStringDescriptor()         |
//   22 |  RSTO         2009/11/05   updated USB_connectionState()                    |
//   23 |  MSP,Biju     2010/07/15   Updated for MSC                                  |
//   24 +----------------------------------------------------------------------------*/
//   25 /*----------------------------------------------------------------------------+
//   26 | Include files                                                               |
//   27 +----------------------------------------------------------------------------*/
//   28 
//   29 #include "../USB_Common/device.h"

        ASEGN DATA16_AN:DATA:NOROOT,0900H
// union <unnamed> __data16 _A_USBKEYID_L
_A_USBKEYID_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0902H
// union <unnamed> __data16 _A_USBCNF_L
_A_USBCNF_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0904H
// union <unnamed> __data16 _A_USBPHYCTL_L
_A_USBPHYCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0908H
// union <unnamed> __data16 _A_USBPWRCTL_L
_A_USBPWRCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0910H
// union <unnamed> __data16 _A_USBPLLCTL_L
_A_USBPLLCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0912H
// union <unnamed> __data16 _A_USBPLLDIVB_L
_A_USBPLLDIVB_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0914H
// union <unnamed> __data16 _A_USBPLLIR_L
_A_USBPLLIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,092eH
// unsigned char volatile __data16 USBIEPIE
USBIEPIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,092fH
// unsigned char volatile __data16 USBOEPIE
USBOEPIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093cH
// unsigned char volatile __data16 USBCTL
USBCTL:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093dH
// unsigned char volatile __data16 USBIE
USBIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093eH
// unsigned char volatile __data16 USBIFG
USBIFG:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093fH
// unsigned char volatile __data16 USBFUNADR
USBFUNADR:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,016cH
// union <unnamed> __data16 _A_UCSCTL6_L
_A_UCSCTL6_L:
        DS8 2
//   30 #include "../USB_Common/types.h"              // Basic Type declarations
//   31 #include "../USB_Common/defMSP430USB.h"
//   32 #include "../USB_Common/usb.h"  // USB-specific Data Structures
//   33 #include "../USB_CDC_API/UsbCdc.h"
//   34 #include "../USB_HID_API/UsbHidReq.h"
//   35 #include "../USB_MSC_API/UsbMscScsi.h"
//   36 #include <descriptors.h>
//   37 
//   38 #include <HAL_UCS.h>
//   39 #include <HAL_TLV.h>
//   40 #include <string.h>
//   41 
//   42 /*----------------------------------------------------------------------------+
//   43  | Internal Constant Definition                                               |
//   44  +----------------------------------------------------------------------------*/
//   45 #define NO_MORE_DATA    0xFFFF
//   46 #define EPBCT_NAK       0x80
//   47 #define EPCNF_TOGLE     0x20
//   48 
//   49 #define DIRECTION_IN	0x80
//   50 #define DIRECTION_OUT	0x00
//   51 
//   52 /*----------------------------------------------------------------------------+
//   53 | Internal Variables                                                          |
//   54 +----------------------------------------------------------------------------*/
//   55 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   56 static BYTE bConfigurationNumber;      // Set to 1 when USB device has been
bConfigurationNumber:
        DS8 1
//   57                                 // configured, set to 0 when unconfigured
//   58 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   59 static BYTE bInterfaceNumber;   // interface number
bInterfaceNumber:
        DS8 1
//   60 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   61 WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
wBytesRemainingOnIEP0:
        DS8 2
//   62                                 // Holds count of bytes remaining to be
//   63                                 // transmitted by endpoint 0.  A value
//   64                                 // of 0 means that a 0-length data packet
//   65                                 // A value of 0xFFFF means that transfer
//   66                                 // is complete.
//   67 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   68 WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
wBytesRemainingOnOEP0:
        DS8 2
//   69                                 // Holds count of bytes remaining to be
//   70                                 // received by endpoint 0.  A value
//   71                                 // of 0 means that a 0-length data packet
//   72                                 // A value of 0xFFFF means that transfer
//   73                                 // is complete.
//   74 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   75 static PBYTE pbIEP0Buffer;      // A buffer pointer to input end point 0
pbIEP0Buffer:
        DS8 4
//   76                                 // Data sent back to host is copied from
//   77                                 // this pointed memory location
//   78 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   79 static PBYTE pbOEP0Buffer;      // A buffer pointer to output end point 0
pbOEP0Buffer:
        DS8 4
//   80                                 // Data sent from host is copied to
//   81                                 // this pointed memory location
//   82 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   83 static BYTE bHostAskMoreDataThanAvailable=0;
bHostAskMoreDataThanAvailable:
        DS8 1
//   84 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   85 BYTE abUsbRequestReturnData[USB_RETURN_DATA_LENGTH];
abUsbRequestReturnData:
        DS8 8

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   86 BYTE abUsbRequestIncomingData[USB_RETURN_DATA_LENGTH];
abUsbRequestIncomingData:
        DS8 8
//   87 

        RSEG DATA20_N:DATA:SORT:NOROOT(0)
//   88 __no_init BYTE abramSerialStringDescriptor[34];
abramSerialStringDescriptor:
        DS8 34
//   89 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   90 BYTE bStatusAction;
bStatusAction:
        DS8 1

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   91 BYTE bFunctionSuspended=FALSE;  // TRUE if function is suspended
bFunctionSuspended:
        DS8 1

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   92 BYTE bEnumerationStatus = 0;    //is 0 if not enumerated
bEnumerationStatus:
        DS8 1
//   93 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   94 static BYTE bRemoteWakeup;
bRemoteWakeup:
        DS8 1
//   95 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   96 WORD wUsbEventMask;             //used by USB_getEnabledEvents() and USB_setEnabledEvents()
wUsbEventMask:
        DS8 2
//   97 
//   98 #ifdef _MSC_
//   99 void MscResetData();
//  100 extern BOOL bMcsCommandSupported;
//  101 extern BOOL isMSCConfigured;
//  102 
//  103 extern BYTE bMscResetRequired;
//  104 #endif
//  105 
//  106 /*----------------------------------------------------------------------------+
//  107 | Global Variables                                                            |
//  108 +----------------------------------------------------------------------------*/
//  109 /*----------------------------------------------------------------------------+
//  110 | Hardware Related Structure Definition                                       |
//  111 +----------------------------------------------------------------------------*/
//  112 
//  113 #ifdef __IAR_SYSTEMS_ICC__
//  114 
//  115 #pragma location = 0x2380

        ASEGN DATA16_AN:DATA:NOROOT,02380H
//  116 __no_init tDEVICE_REQUEST __data16 tSetupPacket;
tSetupPacket:
        DS8 8
//  117 
//  118 #pragma location = 0x0920

        ASEGN DATA16_AN:DATA:NOROOT,0920H
//  119 __no_init tEDB0 __data16 tEndPoint0DescriptorBlock;
tEndPoint0DescriptorBlock:
        DS8 4
//  120 
//  121 #pragma location = 0x23C8

        ASEGN DATA16_AN:DATA:NOROOT,023c8H
//  122 __no_init tEDB __data16 tInputEndPointDescriptorBlock[7];
tInputEndPointDescriptorBlock:
        DS8 56
//  123 
//  124 #pragma location = 0x2388

        ASEGN DATA16_AN:DATA:NOROOT,02388H
//  125 __no_init tEDB __data16 tOutputEndPointDescriptorBlock[7];
tOutputEndPointDescriptorBlock:
        DS8 56
//  126 
//  127 #pragma location = 0x2378

        ASEGN DATA16_AN:DATA:NOROOT,02378H
//  128 __no_init BYTE __data16 abIEP0Buffer[EP0_MAX_PACKET_SIZE];
abIEP0Buffer:
        DS8 8
//  129 
//  130 #pragma location = 0x2370

        ASEGN DATA16_AN:DATA:NOROOT,02370H
//  131 __no_init BYTE __data16 abOEP0Buffer[EP0_MAX_PACKET_SIZE];
abOEP0Buffer:
        DS8 8
//  132 
//  133 #pragma location = OEP1_X_BUFFER_ADDRESS
//  134  __no_init BYTE __data16 pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  135 
//  136 #pragma location = OEP1_Y_BUFFER_ADDRESS
//  137  __no_init BYTE __data16 pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  138 
//  139 #pragma location = IEP1_X_BUFFER_ADDRESS
//  140  __no_init BYTE __data16 pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  141 
//  142 #pragma location = IEP1_Y_BUFFER_ADDRESS
//  143  __no_init BYTE __data16 pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  144 
//  145 #pragma location = OEP2_X_BUFFER_ADDRESS
//  146  __no_init BYTE __data16 pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  147 
//  148 #pragma location = OEP2_Y_BUFFER_ADDRESS
//  149  __no_init BYTE __data16 pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  150 
//  151 #pragma location = IEP2_X_BUFFER_ADDRESS
//  152  __no_init BYTE __data16 pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  153 
//  154 #pragma location = IEP2_Y_BUFFER_ADDRESS
//  155  __no_init BYTE __data16 pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  156 
//  157 #pragma location = OEP3_X_BUFFER_ADDRESS
//  158 __no_init BYTE __data16 pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  159 
//  160 #pragma location = OEP3_Y_BUFFER_ADDRESS
//  161 __no_init BYTE __data16 pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  162 
//  163 #pragma location = IEP3_X_BUFFER_ADDRESS
//  164 __no_init BYTE __data16 pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  165 
//  166 #pragma location = IEP3_Y_BUFFER_ADDRESS
//  167 __no_init BYTE __data16 pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  168 
//  169 #pragma location = OEP4_X_BUFFER_ADDRESS
//  170 __no_init BYTE __data16 pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  171 
//  172 #pragma location = OEP4_Y_BUFFER_ADDRESS
//  173 __no_init BYTE __data16 pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  174 
//  175 #pragma location = IEP4_X_BUFFER_ADDRESS
//  176 __no_init BYTE __data16 pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  177 
//  178 #pragma location = IEP4_Y_BUFFER_ADDRESS
//  179 __no_init BYTE __data16 pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  180 
//  181 #pragma location = OEP5_X_BUFFER_ADDRESS
//  182 __no_init BYTE __data16 pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  183 
//  184 #pragma location = OEP5_Y_BUFFER_ADDRESS
//  185 __no_init BYTE __data16 pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  186 
//  187 #pragma location = IEP5_X_BUFFER_ADDRESS
//  188 __no_init BYTE __data16 pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  189 
//  190 #pragma location = IEP5_Y_BUFFER_ADDRESS
//  191 __no_init BYTE __data16 pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  192 
//  193 #pragma location = OEP6_X_BUFFER_ADDRESS
//  194 __no_init BYTE __data16 pbXBufferAddressEp6[EP_MAX_PACKET_SIZE];
//  195 
//  196 #pragma location = OEP6_Y_BUFFER_ADDRESS
//  197 __no_init BYTE __data16 pbYBufferAddressEp6[EP_MAX_PACKET_SIZE];
//  198 
//  199 #pragma location = IEP6_X_BUFFER_ADDRESS
//  200 __no_init BYTE __data16 pbXBufferAddressEp86[EP_MAX_PACKET_SIZE];
//  201 
//  202 #pragma location = IEP6_Y_BUFFER_ADDRESS
//  203 __no_init BYTE __data16 pbYBufferAddressEp86[EP_MAX_PACKET_SIZE];
//  204 
//  205 #pragma location = OEP7_X_BUFFER_ADDRESS
//  206 __no_init BYTE __data16 pbXBufferAddressEp7[EP_MAX_PACKET_SIZE];
//  207 
//  208 #pragma location = OEP7_Y_BUFFER_ADDRESS
//  209 __no_init BYTE __data16 pbYBufferAddressEp7[EP_MAX_PACKET_SIZE];
//  210 
//  211 #pragma location = IEP7_X_BUFFER_ADDRESS
//  212 __no_init BYTE __data16 pbXBufferAddressEp87[EP_MAX_PACKET_SIZE];
//  213 
//  214 #pragma location = IEP7_Y_BUFFER_ADDRESS
//  215 __no_init BYTE __data16 pbYBufferAddressEp87[EP_MAX_PACKET_SIZE];
//  216 
//  217 
//  218 
//  219 #endif
//  220 
//  221 #ifdef __TI_COMPILER_VERSION__
//  222 extern __no_init tDEVICE_REQUEST tSetupPacket;
//  223 extern __no_init tEDB0 tEndPoint0DescriptorBlock;
//  224 extern __no_init tEDB tInputEndPointDescriptorBlock[7];
//  225 extern __no_init tEDB tOutputEndPointDescriptorBlock[7];
//  226 extern __no_init BYTE abIEP0Buffer[EP0_MAX_PACKET_SIZE];
//  227 extern __no_init BYTE abOEP0Buffer[EP0_MAX_PACKET_SIZE];
//  228 extern __no_init BYTE pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  229 extern __no_init BYTE pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  230 extern __no_init BYTE pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  231 extern __no_init BYTE pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  232 extern __no_init BYTE pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  233 extern __no_init BYTE pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  234 extern __no_init BYTE pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  235 extern __no_init BYTE pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  236 extern __no_init BYTE pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  237 extern __no_init BYTE pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  238 extern __no_init BYTE pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  239 extern __no_init BYTE pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  240 
//  241 extern __no_init BYTE pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  242 extern __no_init BYTE pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  243 extern __no_init BYTE pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  244 extern __no_init BYTE pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  245 
//  246 extern __no_init BYTE pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  247 extern __no_init BYTE pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  248 extern __no_init BYTE pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  249 extern __no_init BYTE pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  250 
//  251 #endif
//  252 
//  253 VOID CdcResetData();
//  254 VOID HidResetData();
//  255 
//  256 VOID USB_InitSerialStringDescriptor(VOID);
//  257 VOID USB_initMemcpy(VOID);
//  258 
//  259 //----------------------------------------------------------------------------

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  260 BYTE USB_init(VOID)
USB_init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function USB_init
//  261 {
        FUNCALL USB_init, USB_InitSerialStringDescriptor
        LOCFRAME CSTACK, 10, STACK
        FUNCALL USB_init, USB_initMemcpy
        LOCFRAME CSTACK, 10, STACK
        FUNCALL USB_init, MscResetCtrlLun
        LOCFRAME CSTACK, 10, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x2, SP
          CFI CFA SP+10
//  262     WORD bGIE  = __get_SR_register() &GIE;  //save interrupt status
        MOV.W   SR, R10
        AND.W   #0x8, R10
//  263     // atomic operation - disable interrupts
//  264     __disable_interrupt();               // Disable global interrupts
        DINT
        NOP
//  265 
//  266     // configuration of USB module
//  267     USBKEYPID   =     0x9628;            // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  268 
//  269     USBPHYCTL   =     PUSEL;             // use DP and DM as USB terminals (not needed because an external PHY is connected to port 9)
        MOV.W   #0x80, &0x904
//  270 
//  271     USBPWRCTL   =     VUSBEN + SLDOAON; // enable primary and secondary LDO (3.3 and 1.8 V)
        MOV.W   #0x840, &0x908
//  272     {
//  273     	volatile unsigned int i;
//  274     	for (i =0; i < USB_MCLK_FREQ/1000*2/10; i++);      // wait some time for LDOs (1ms delay)
        MOV.W   #0x0, 0(SP)
??USB_init_0:
        CMP.W   #0x1388, 0(SP)
        JC      ??USB_init_1
        MOV.W   @SP, R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0(SP)
        JMP     ??USB_init_0
//  275     }
//  276 
//  277     USBPWRCTL   =   VUSBEN + SLDOAON + VBONIE;  // enable interrupt VBUSon
??USB_init_1:
        MOV.W   #0xa40, &0x908
//  278     USBKEYPID   =    0x9600;            // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  279 
//  280     //reset events mask
//  281     wUsbEventMask = 0;
        MOVX.W  #0x0, &wUsbEventMask
//  282 
//  283     //init Serial Number
//  284 #if (USB_STR_INDEX_SERNUM != 0)
//  285     USB_InitSerialStringDescriptor();
        CALLA   #USB_InitSerialStringDescriptor
//  286 #endif
//  287 
//  288     // init memcpy() function: DMA or non-DMA
//  289     USB_initMemcpy();
        CALLA   #USB_initMemcpy
//  290 #ifdef _MSC_
//  291     MscResetCtrlLun();
        CALLA   #MscResetCtrlLun
//  292 #endif
//  293 
//  294     __bis_SR_register(bGIE); //restore interrupt status
        BIS.W   R10, SR
//  295     return kUSB_succeed;
        MOV.B   #0x0, R12
        ADD.W   #0x2, SP
          CFI CFA SP+8
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBPHYCTL_L
        REQUIRE _A_USBPWRCTL_L
//  296 }
//  297 
//  298 //----------------------------------------------------------------------------
//  299 // This function will be compiled only if
//  300 #if (USB_STR_INDEX_SERNUM != 0)

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  301 VOID USB_InitSerialStringDescriptor(VOID)
USB_InitSerialStringDescriptor:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function USB_InitSerialStringDescriptor
//  302 {
        FUNCALL USB_InitSerialStringDescriptor, Get_TLV_Info
        LOCFRAME CSTACK, 26, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x6, SP
          CFI CFA SP+26
//  303     BYTE i,j,hexValue;
//  304     PBYTE pbSerNum;
//  305     BYTE bBytes;
//  306 
//  307     j=1;                   // we start with second byte, first byte (lenght) will be filled later
        MOV.B   #0x1, R10
//  308     pbSerNum=0;
        MOVX.A  #0x0, 0x2(SP)
//  309     abramSerialStringDescriptor[j++] = DESC_TYPE_STRING;
        MOV.B   R10, R15
        MOVX.B  #0x3, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  310 
//  311     // TLV access Function Call
//  312     Get_TLV_Info(TLV_DIERECORD, 0, (uint8_t *)&bBytes, (uint16_t **)&pbSerNum); //The die record used for serial number
        MOV.W   SP, R15
        ADD.W   #0x2, R15
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.B   #0x0, R13
        MOV.B   #0x8, R12
        CALLA   #Get_TLV_Info
//  313     if (bBytes == 0)    // no serial number available
        CMP.B   #0x0, 0(SP)
        JNE     ??USB_InitSerialStringDescriptor_1
//  314     {
//  315         // use 00 as serial number = no serial number available
//  316         abramSerialStringDescriptor[0] = 4;      //length
        MOVX.B  #0x4, &abramSerialStringDescriptor
//  317         abramSerialStringDescriptor[j++] = 0;    // no serial number available
        MOV.B   R10, R15
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  318         abramSerialStringDescriptor[j++] = 0;    // no serial number available
        MOV.B   R10, R15
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
        JMP     ??USB_InitSerialStringDescriptor_2
//  319     }
//  320     else
//  321     {
//  322         for(i=0; (i<bBytes)&&(i<8); i++,pbSerNum++)
??USB_InitSerialStringDescriptor_1:
        MOV.B   #0x0, R11
??USB_InitSerialStringDescriptor_0:
        CMP.B   @SP, R11
        JC      ??USB_InitSerialStringDescriptor_3
        CMP.B   #0x8, R11
        JC      ??USB_InitSerialStringDescriptor_3
//  323         {
//  324             hexValue = (*pbSerNum & 0xF0)>> 4;
        MOVA    0x2(SP), R15
        MOV.B   @R15, R14
        RPT     #0x4
        RRUX.B  R14
        MOV.B   R14, R8
//  325             if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
        CMP.B   #0xa, R8
        JC      ??USB_InitSerialStringDescriptor_4
        MOV.B   R8, R14
        ADD.B   #0x30, R14
        MOV.B   R10, R15
        MOVX.B  R14, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
        JMP     ??USB_InitSerialStringDescriptor_5
//  326             else abramSerialStringDescriptor[j++] = (hexValue + 55);
??USB_InitSerialStringDescriptor_4:
        MOV.B   R8, R14
        ADD.B   #0x37, R14
        MOV.B   R10, R15
        MOVX.B  R14, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  327             abramSerialStringDescriptor[j++] = 0x00;  // needed for UNI-Code
??USB_InitSerialStringDescriptor_5:
        MOV.B   R10, R15
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  328 
//  329             hexValue = (*pbSerNum & 0x0F);
        MOVA    0x2(SP), R15
        MOV.B   #0xf, R14
        AND.B   @R15, R14
        MOV.B   R14, R8
//  330             if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
        CMP.B   #0xa, R8
        JC      ??USB_InitSerialStringDescriptor_6
        MOV.B   R8, R14
        ADD.B   #0x30, R14
        MOV.B   R10, R15
        MOVX.B  R14, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
        JMP     ??USB_InitSerialStringDescriptor_7
//  331             else abramSerialStringDescriptor[j++] = (hexValue + 55);
??USB_InitSerialStringDescriptor_6:
        MOV.B   R8, R14
        ADD.B   #0x37, R14
        MOV.B   R10, R15
        MOVX.B  R14, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  332             abramSerialStringDescriptor[j++] = 0x00;    // needed for UNI-Code
??USB_InitSerialStringDescriptor_7:
        MOV.B   R10, R15
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
//  333         }
        ADD.B   #0x1, R11
        MOVA    0x2(SP), R15
        ADDA    #0x1, R15
        MOVA    R15, 0x2(SP)
        JMP     ??USB_InitSerialStringDescriptor_0
//  334         abramSerialStringDescriptor[0] = i*4 +2;        // calculate the length
??USB_InitSerialStringDescriptor_3:
        MOV.B   R11, R14
        RPT     #0x2
        RLAX.B  R14
        ADD.B   #0x2, R14
        MOVX.B  R14, &abramSerialStringDescriptor
//  335     }
//  336 }
??USB_InitSerialStringDescriptor_2:
        ADD.W   #0x6, SP
          CFI CFA SP+20
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  337 #endif
//  338 
//  339 //----------------------------------------------------------------------------
//  340 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  341 BYTE USB_enable()
USB_enable:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function USB_enable
//  342 {
        FUNCALL USB_enable, XT2_Start
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
//  343     volatile unsigned int i;
//  344     volatile unsigned int j = 0;
        MOV.W   #0x0, 0x2(SP)
//  345 
//  346     if (!(USBPWRCTL & USBBGVBV))            // check USB Bandgap and VBUS valid
        BIT.W   #0x8, &0x908
        JC      ??USB_enable_2
//  347     {
//  348         return kUSB_generalError;
        MOV.B   #0x1, R12
        JMP     ??USB_enable_3
//  349     }
//  350 
//  351     if ((USBCNF & USB_EN) &&
//  352         (USBPLLCTL & UPLLEN))
??USB_enable_2:
        BIT.W   #0x1, &0x902
        JNC     ??USB_enable_4
        BIT.W   #0x100, &0x910
        JNC     ??USB_enable_4
//  353     {
//  354         return kUSB_succeed;                // exit if PLL is already enalbed
        MOV.B   #0x0, R12
        JMP     ??USB_enable_3
//  355     }
//  356 
//  357     USBKEYPID = 0x9628;                     // set KEY and PID to 0x9628 -> access to configuration registers enabled
??USB_enable_4:
        MOV.W   #0x9628, &0x900
//  358     XT2_Start(XT2DRIVE_3);
        MOV.W   #0xc000, R12
        CALLA   #XT2_Start
//  359     USBPLLDIVB = USB_XT_FREQ;               // Settings desired frequency
        MOV.W   #0x117, &0x912
//  360 
//  361     if (USB_PLL_XT == 2)
//  362     {
//  363         USBPLLCTL = UPCS0 + UPFDEN + UPLLEN;// Select XT2 as Ref / Select PLL for USB / Discrim. on, enable PLL
        MOV.W   #0x1300, &0x910
//  364     }
//  365     else
//  366     {
//  367         USBPLLCTL = UPFDEN + UPLLEN;        // Select XT1 as Ref / Select PLL for USB / Discrim. on, enable PLL
//  368     }
//  369 
//  370     //Wait some time till PLL is settled
//  371     do
//  372     {
//  373         USBPLLIR    =     0x0000;           // make sure no interrupts can occur on PLL-module
??USB_enable_1:
        MOV.W   #0x0, &0x914
//  374 
//  375 #ifdef __MSP430F6638
//  376         //wait 1 ms till enable USB
//  377         for (i =0; i < USB_MCLK_FREQ/1000*1/10; i++);
//  378 #else
//  379         //wait 1/2 ms till enable USB
//  380         for (i =0; i < USB_MCLK_FREQ/1000* 1/2 /10; i++);
        MOV.W   #0x0, 0(SP)
??USB_enable_0:
        CMP.W   #0x4e2, 0(SP)
        JC      ??USB_enable_5
        MOV.W   @SP, R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0(SP)
        JMP     ??USB_enable_0
//  381 #endif
//  382 
//  383         if (j++ > 10)
??USB_enable_5:
        MOV.W   0x2(SP), R15
        MOV.W   R15, R14
        ADD.W   #0x1, R14
        MOV.W   R14, 0x2(SP)
        CMP.W   #0xb, R15
        JNC     ??USB_enable_6
//  384         {
//  385             USBKEYPID   =    0x9600;        // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  386             return kUSB_generalError;
        MOV.B   #0x1, R12
        JMP     ??USB_enable_3
//  387         }
//  388     }while (USBPLLIR != 0);
??USB_enable_6:
        CMP.W   #0x0, &0x914
        JNE     ??USB_enable_1
//  389 
//  390     USBCNF     |=    USB_EN;                // enable USB module
        BIS.W   #0x1, &0x902
//  391     USBKEYPID   =    0x9600;                // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  392     return kUSB_succeed;
        MOV.B   #0x0, R12
??USB_enable_3:
        ADD.W   #0x4, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPLLCTL_L
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBPLLDIVB_L
        REQUIRE _A_USBPLLIR_L
//  393 }
//  394 
//  395 /*
//  396 Disables the USB module and PLL.
//  397 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  398 BYTE USB_disable(VOID)
USB_disable:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function USB_disable
//  399 {
//  400     USBKEYPID = 0x9628;        // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  401     USBCNF    = 0;             // disable USB module
        MOV.W   #0x0, &0x902
//  402     USBPLLCTL &= ~UPLLEN;      // disable PLL
        BIC.W   #0x100, &0x910
//  403     USBKEYPID = 0x9600;        // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  404     bEnumerationStatus = 0x00; // device is not enumerated
        MOVX.B  #0x0, &bEnumerationStatus
//  405     bFunctionSuspended = FALSE;// device is not suspended
        MOVX.B  #0x0, &bFunctionSuspended
//  406     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock3
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPLLCTL_L
//  407 }
//  408 
//  409 /*
//  410 Enables/disables various USB events.
//  411 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  412 BYTE USB_setEnabledEvents(WORD events)
USB_setEnabledEvents:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function USB_setEnabledEvents
//  413 {
        MOV.W   R12, R15
//  414     wUsbEventMask = events;
        MOVX.W  R15, &wUsbEventMask
//  415     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock4
//  416 }
//  417 
//  418 /*
//  419 Returns which events are enabled and which are disabled.
//  420 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  421 WORD USB_getEnabledEvents()
USB_getEnabledEvents:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function USB_getEnabledEvents
//  422 {
//  423     return wUsbEventMask;
        MOVX.W  &wUsbEventMask, R12
        RETA
          CFI EndBlock cfiBlock5
//  424 }
//  425 
//  426 /*
//  427 Reset USB-SIE and global variables.
//  428 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  429 BYTE USB_reset()
USB_reset:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function USB_reset
//  430 {
        FUNCALL USB_reset, HidResetData
        LOCFRAME CSTACK, 8, STACK
        FUNCALL USB_reset, MscResetData
        LOCFRAME CSTACK, 8, STACK
        FUNCALL USB_reset, CdcResetData
        LOCFRAME CSTACK, 8, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
//  431     int i;
//  432     USBKEYPID = 0x9628;                   // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  433 
//  434     //reset should be on the bus after this!
//  435     bEnumerationStatus = 0x00;            // Device not enumerated yet
        MOVX.B  #0x0, &bEnumerationStatus
//  436     bFunctionSuspended = FALSE;           // Device is not in suspend mode
        MOVX.B  #0x0, &bFunctionSuspended
//  437 
//  438     bRemoteWakeup = DISABLE;
        MOVX.B  #0x0, &bRemoteWakeup
//  439 
//  440     bConfigurationNumber    = 0x00;       // device unconfigured
        MOVX.B  #0x0, &bConfigurationNumber
//  441     bInterfaceNumber        = 0x00;
        MOVX.B  #0x0, &bInterfaceNumber
//  442 
//  443     // FRSTE handling:
//  444     // Clear FRSTE in the RESRIFG interrupt service routine before re-configuring USB control registers.
//  445     // Set FRSTE at the beginning of SUSRIFG, SETUP, IEPIFG.EP0 and OEPIFG.EP0 interrupt service routines.
//  446     USBCTL = 0;                           // Function Reset Connection disable (FRSTE)
        MOV.B   #0x0, &0x93c
//  447 
//  448     wBytesRemainingOnIEP0   = NO_MORE_DATA;
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
//  449     wBytesRemainingOnOEP0   = NO_MORE_DATA;
        MOVX.W  #0xffff, &wBytesRemainingOnOEP0
//  450     bStatusAction           = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
//  451 
//  452     //The address reset normally will be done automatically during bus function reset
//  453     USBFUNADR   =     0x00;               // reset address of USB device (unconfigured)
        MOV.B   #0x0, &0x93f
//  454 
//  455     /* Set settings for EP0 */
//  456     // NAK both 0 endpoints and enable endpoint 0 interrupt
//  457     tEndPoint0DescriptorBlock.bIEPBCNT = EPBCNT_NAK;
        MOV.B   #0x80, &0x921
//  458     tEndPoint0DescriptorBlock.bOEPBCNT = EPBCNT_NAK;
        MOV.B   #0x80, &0x923
//  459     tEndPoint0DescriptorBlock.bIEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
        MOV.B   #0x8c, &0x920
//  460     tEndPoint0DescriptorBlock.bOEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
        MOV.B   #0x8c, &0x922
//  461 
//  462     USBOEPIE = USB_OUTEP_INT_EN;
        MOV.B   #0x1b, &0x92f
//  463     USBIEPIE = USB_INEP_INT_EN;
        MOV.B   #0x1f, &0x92e
//  464 
//  465     // loop for initialization all of used enpoints
//  466     for(i=0; i < (CDC_NUM_INTERFACES + HID_NUM_INTERFACES + MSC_NUM_INTERFACES); i++)
        MOV.W   #0x0, R10
??USB_reset_0:
        CMP.W   #0x3, R10
        JGE     ??USB_reset_1
//  467     {
//  468         BYTE edbIndex = stUsbHandle[i].edb_Index;
        MOV.W   R10, R15
        XOR.W   #0x8000, R15
        RLAM.A  #0x4, R15
        MOVX.B  stUsbHandle - 524286(R15), R14
//  469 
//  470         /* Set settings for IEPx */
//  471         tInputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x94, 0x23c8(R15)
//  472         tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].iep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524276(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x23c9(R13)
//  473         tInputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].iep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524274(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x23cd(R13)
//  474         tInputEndPointDescriptorBlock[edbIndex].bEPBCTX  = EPBCNT_NAK;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x80, 0x23ca(R15)
//  475         tInputEndPointDescriptorBlock[edbIndex].bEPBCTY  = EPBCNT_NAK;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x80, 0x23ce(R15)
//  476         tInputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x40, 0x23cf(R15)
//  477 
//  478         /* Set settings for OEPx */
//  479         tOutputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF ; //double buffering
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x94, 0x2388(R15)
//  480         tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].oep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524280(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x2389(R13)
//  481         tOutputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].oep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524278(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x238d(R13)
//  482         tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX  = 0x00;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x0, 0x238a(R15)
//  483         tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY  = 0x00;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x0, 0x238e(R15)
//  484         tOutputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x40, 0x238f(R15)
//  485 
//  486 #       ifdef _CDC_
//  487         /* Additional interrupt end point for CDC */
//  488         if(stUsbHandle[i].dev_Class == CDC_CLASS)
        MOV.W   R10, R15
        XOR.W   #0x8000, R15
        RLAM.A  #0x4, R15
        CMPX.B  #0x2, stUsbHandle - 524285(R15)
        JNE     ??USB_reset_2
//  489         {
//  490             // The decriptor tool always generates the managemnet endpoint before the data endpoint
//  491             tInputEndPointDescriptorBlock[edbIndex-1].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x94, 0x23c0(R15)
//  492             tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAX  = (BYTE)(((stUsbHandle[i].intepEP_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524284(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x23c1(R13)
//  493             tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAY  = (BYTE)(((stUsbHandle[i].intepEP_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
        MOV.W   R10, R13
        XOR.W   #0x8000, R13
        RLAM.A  #0x4, R13
        MOV.W   #0xe400, R15
        ADDX.W  stUsbHandle - 524282(R13), R15
        RRUM.W  #0x3, R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        MOV.B   R15, 0x23c5(R13)
//  494             tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTX  = EPBCNT_NAK;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x80, 0x23c2(R15)
//  495             tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTY  = EPBCNT_NAK;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        MOV.B   #0x80, 0x23c6(R15)
//  496             tInputEndPointDescriptorBlock[edbIndex-1].bEPSIZXY = MAX_PACKET_SIZE;
        MOV.B   R14, R14
        RLAM.W  #0x3, R14
        MOV.B   #0x40, 0x23c7(R14)
//  497         }
//  498 #       endif
//  499     }
??USB_reset_2:
        ADD.W   #0x1, R10
        JMP     ??USB_reset_0
//  500 
//  501 #   ifdef _HID_
//  502         HidResetData();                     // reset HID specific data structures
??USB_reset_1:
        CALLA   #HidResetData
//  503 #   endif // _HID_
//  504 
//  505 #   ifdef _MSC_
//  506         isMSCConfigured = FALSE;
        MOVX.W  #0x0, &isMSCConfigured
//  507         MscResetData();
        CALLA   #MscResetData
//  508 #   endif
//  509 
//  510 #   ifdef _CDC_
//  511         CdcResetData();                     // reset CDC specific data structures
        CALLA   #CdcResetData
//  512 #   endif // _CDC_
//  513 
//  514     USBCTL = FEN;                       // enable function
        MOV.B   #0x40, &0x93c
//  515     USBIFG = 0;                         // make sure no interrupts are pending
        MOV.B   #0x0, &0x93e
//  516 
//  517     USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
        MOV.B   #0xc4, &0x93d
//  518     USBKEYPID = 0x9600;                 // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  519     return kUSB_succeed;
        MOV.B   #0x0, R12
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
        REQUIRE _A_USBKEYID_L
        REQUIRE USBCTL
        REQUIRE USBFUNADR
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE USBOEPIE
        REQUIRE USBIEPIE
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
        REQUIRE USBIFG
        REQUIRE USBIE
//  520 }
//  521 
//  522 /*
//  523 Instruct USB module to make itself available to the PC for connection, by pulling PUR high.
//  524 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  525 BYTE USB_connect()
USB_connect:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function USB_connect
//  526 {
//  527     USBKEYPID = 0x9628;   // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  528     USBCNF |= PUR_EN;     // generate rising edge on DP -> the host enumerates our device as full speed device
        BIS.W   #0x2, &0x902
//  529     USBPWRCTL |= VBOFFIE; // enable interrupt VUSBoff
        BIS.W   #0x400, &0x908
//  530     USBKEYPID = 0x9600;   // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  531 
//  532     // after this the enumeration may take place
//  533     __no_operation();
        NOP
//  534     __no_operation();
        NOP
//  535     __no_operation();
        NOP
//  536     __no_operation();
        NOP
//  537     __no_operation();
        NOP
//  538     __no_operation();
        NOP
//  539     __no_operation();
        NOP
//  540 
//  541     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock7
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPWRCTL_L
//  542 }
//  543 
//  544 /*
//  545 Force a disconnect from the PC by pulling PUR low.
//  546 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  547 BYTE USB_disconnect()
USB_disconnect:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function USB_disconnect
//  548 {
//  549     USBKEYPID = 0x9628;     // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  550     USBCNF &= ~PUR_EN;      // disconnect pull up resistor - logical disconnect from HOST
        BIC.W   #0x2, &0x902
//  551     USBPWRCTL &= ~VBOFFIE;  // disable interrupt VUSBoff
        BIC.W   #0x400, &0x908
//  552     USBKEYPID = 0x9600;     // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  553     bEnumerationStatus = 0; // not enumerated
        MOVX.B  #0x0, &bEnumerationStatus
//  554     bFunctionSuspended = FALSE;     // device is not suspended
        MOVX.B  #0x0, &bFunctionSuspended
//  555     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock8
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPWRCTL_L
//  556 }
//  557 
//  558 /*
//  559 Force a remote wakeup of the USB host.
//  560 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  561 BYTE USB_forceRemoteWakeup()
USB_forceRemoteWakeup:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function USB_forceRemoteWakeup
//  562 {
//  563     if (bFunctionSuspended == FALSE) // device is not suspended
        CMPX.B  #0x0, &bFunctionSuspended
        JNE     ??USB_forceRemoteWakeup_0
//  564     {
//  565         return kUSB_NotSuspended;
        MOV.B   #0x10, R12
        RETA
//  566     }
//  567     if(bRemoteWakeup == ENABLE)
??USB_forceRemoteWakeup_0:
        CMPX.B  #0x1, &bRemoteWakeup
        JNE     ??USB_forceRemoteWakeup_1
//  568     {
//  569     	volatile unsigned int i;
//  570         USBCTL |= RWUP;             // USB - Device Remote Wakeup Request - this bit is self-cleaned
        BIS.B   #0x20, &0x93c
//  571         return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
//  572     }
//  573     return kUSB_generalError;
??USB_forceRemoteWakeup_1:
        MOV.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock9
        REQUIRE USBCTL
//  574 }
//  575 
//  576 /*
//  577 Returns the status of the USB connection.
//  578 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  579 BYTE USB_connectionInfo()
USB_connectionInfo:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function USB_connectionInfo
//  580 {
//  581     BYTE retVal = 0;
        MOV.B   #0x0, R12
//  582     if (USBPWRCTL & USBBGVBV)
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionInfo_0
//  583     {
//  584         retVal |= kUSB_vbusPresent;
        BIS.B   #0x1, R12
//  585     }
//  586 
//  587     if (bEnumerationStatus == ENUMERATION_COMPLETE)
??USB_connectionInfo_0:
        CMPX.B  #0x1, &bEnumerationStatus
        JNE     ??USB_connectionInfo_1
//  588     {
//  589         retVal |= kUSB_Enumerated;
        BIS.B   #0x20, R12
//  590     }
//  591 
//  592     if (USBCNF & PUR_EN)
??USB_connectionInfo_1:
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionInfo_2
//  593     {
//  594         retVal |= kUSB_purHigh;
        BIS.B   #0x40, R12
//  595     }
//  596 
//  597     if (bFunctionSuspended == TRUE)
??USB_connectionInfo_2:
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionInfo_3
//  598     {
//  599         retVal |= kUSB_suspended;
        BIS.B   #0x8, R12
        RETA
//  600     }
//  601     else
//  602     {
//  603         retVal |= kUSB_NotSuspended;
??USB_connectionInfo_3:
        BIS.B   #0x10, R12
//  604     }
//  605     return retVal;
        RETA
          CFI EndBlock cfiBlock10
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L
//  606 }
//  607 
//  608 /*
//  609 Returns the state of the USB connection.
//  610 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  611 BYTE USB_connectionState()
USB_connectionState:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function USB_connectionState
//  612 {
//  613     // If no VBUS present
//  614     if (!(USBPWRCTL & USBBGVBV))
        BIT.W   #0x8, &0x908
        JC      ??USB_connectionState_0
//  615     {
//  616         return ST_USB_DISCONNECTED;
        MOV.B   #0x80, R12
        RETA
//  617     }
//  618 
//  619     // If VBUS present, but PUR is low
//  620     if ((USBPWRCTL & USBBGVBV)&&(!(USBCNF & PUR_EN)))
??USB_connectionState_0:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_1
        BIT.W   #0x2, &0x902
        JC      ??USB_connectionState_1
//  621     {
//  622         return ST_USB_CONNECTED_NO_ENUM;
        MOV.B   #0x81, R12
        RETA
//  623     }
//  624 
//  625     // If VBUS present, PUR is high, and enumeration is complete, and not suspended
//  626     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  627         && (bEnumerationStatus == ENUMERATION_COMPLETE)
//  628         && (!(bFunctionSuspended == TRUE)))
??USB_connectionState_1:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_2
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_2
        CMPX.B  #0x1, &bEnumerationStatus
        JNE     ??USB_connectionState_2
        CMPX.B  #0x1, &bFunctionSuspended
        JEQ     ??USB_connectionState_2
//  629     {
//  630         return ST_ENUM_ACTIVE;
        MOV.B   #0x83, R12
        RETA
//  631     }
//  632 
//  633     // If VBUS present, PUR is high, and enumeration is NOT complete, and  suspended
//  634     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  635         && (!(bEnumerationStatus == ENUMERATION_COMPLETE))
//  636         && (bFunctionSuspended == TRUE))
??USB_connectionState_2:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_3
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_3
        CMPX.B  #0x1, &bEnumerationStatus
        JEQ     ??USB_connectionState_3
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionState_3
//  637     {
//  638         return ST_NOENUM_SUSPENDED;
        MOV.B   #0x87, R12
        RETA
//  639     }
//  640 
//  641     // If VBUS present, PUR is high, and enumeration is complete, and  suspended
//  642     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  643         && (bEnumerationStatus == ENUMERATION_COMPLETE)
//  644         && (bFunctionSuspended == TRUE))
??USB_connectionState_3:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_4
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_4
        CMPX.B  #0x1, &bEnumerationStatus
        JNE     ??USB_connectionState_4
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionState_4
//  645     {
//  646         return ST_ENUM_SUSPENDED;
        MOV.B   #0x84, R12
        RETA
//  647     }
//  648 
//  649     // If VBUS present, PUR is high, but no enumeration yet
//  650     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  651         && (!(bEnumerationStatus == ENUMERATION_COMPLETE)))
??USB_connectionState_4:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_5
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_5
        CMPX.B  #0x1, &bEnumerationStatus
        JEQ     ??USB_connectionState_5
//  652     {
//  653         return ST_ENUM_IN_PROGRESS;
        MOV.B   #0x82, R12
        RETA
//  654     }
//  655 
//  656     return ST_ERROR;
??USB_connectionState_5:
        MOV.B   #0x86, R12
        RETA
          CFI EndBlock cfiBlock11
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L
//  657 }
//  658 
//  659 //----------------------------------------------------------------------------
//  660 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  661 BYTE USB_suspend(VOID)
USB_suspend:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function USB_suspend
//  662 {
//  663 
//  664     bFunctionSuspended  = TRUE;
        MOVX.B  #0x1, &bFunctionSuspended
//  665     USBKEYPID = 0x9628;         // set KEY and PID to 0x9628 -> access to configuration registers enabled
        MOV.W   #0x9628, &0x900
//  666     USBCTL |= FRSTE;            // Function Reset Connection Enable
        BIS.B   #0x10, &0x93c
//  667     USBIFG &= ~SUSRIFG;         // clear interrupt flag
        BIC.B   #0x40, &0x93e
//  668 
//  669     if(USB_DISABLE_XT_SUSPEND)
//  670     {
//  671         if (USB_PLL_XT == 2)
//  672         {
//  673             USBPLLCTL &= ~UPLLEN;         // disable PLL
        BIC.W   #0x100, &0x910
//  674             UCSCTL6   |= XT2OFF;         // disable XT2
        BIS.W   #0x100, &0x16c
//  675         }
//  676         else
//  677         {
//  678             USBPLLCTL &= ~UPLLEN;           // disable PLL
//  679             UCSCTL6 |= XT1OFF;
//  680         }
//  681     }
//  682 
//  683     USBIE = RESRIE;             // disable USB specific interrupts (setup, suspend, reset), enable resume.
        MOV.B   #0x20, &0x93d
//  684                                 // If the reset occured during device in suspend, the resume-interrupt will come, after - reset interrupt
//  685     USBKEYPID = 0x9600;         // access to configuration registers disabled
        MOV.W   #0x9600, &0x900
//  686 
//  687     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock12
        REQUIRE _A_USBKEYID_L
        REQUIRE USBCTL
        REQUIRE USBIFG
        REQUIRE _A_USBPLLCTL_L
        REQUIRE _A_UCSCTL6_L
        REQUIRE USBIE
//  688 }
//  689 
//  690 //----------------------------------------------------------------------------
//  691 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  692 BYTE USB_resume(VOID)
USB_resume:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function USB_resume
//  693 {
//  694     USB_enable();                       // enable PLL
        FUNCALL USB_resume, USB_enable
        LOCFRAME CSTACK, 4, STACK
        CALLA   #USB_enable
//  695 
//  696     USBIFG &= ~(RESRIFG | SUSRIFG);     // clear interrupt flags
        AND.B   #0x9f, &0x93e
//  697     USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
        MOV.B   #0xc4, &0x93d
//  698 
//  699     bFunctionSuspended  = FALSE;
        MOVX.B  #0x0, &bFunctionSuspended
//  700     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock13
        REQUIRE USBIFG
        REQUIRE USBIE
//  701 }
//  702 
//  703 //----------------------------------------------------------------------------
//  704 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  705 VOID usbStallEndpoint0(VOID)
usbStallEndpoint0:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function usbStallEndpoint0
//  706 {
//  707     tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
        BIS.B   #0x8, &0x920
//  708     tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
        BIS.B   #0x8, &0x922
//  709 }
        RETA
          CFI EndBlock cfiBlock14
        REQUIRE tEndPoint0DescriptorBlock
//  710 
//  711 //----------------------------------------------------------------------------
//  712 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  713 VOID usbClearOEP0ByteCount(VOID)
usbClearOEP0ByteCount:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function usbClearOEP0ByteCount
//  714 {
//  715     tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
        MOV.B   #0x0, &0x923
//  716 }
        RETA
          CFI EndBlock cfiBlock15
        REQUIRE tEndPoint0DescriptorBlock
//  717 
//  718 //----------------------------------------------------------------------------
//  719 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  720 VOID usbStallOEP0(VOID)
usbStallOEP0:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function usbStallOEP0
//  721 {
//  722     // in standard USB request, there is not control write request with data stage
//  723     // control write, stall output endpoint 0
//  724     // wLength should be 0 in all cases
//  725     tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
        BIS.B   #0x8, &0x922
//  726 }
        RETA
          CFI EndBlock cfiBlock16
        REQUIRE tEndPoint0DescriptorBlock
//  727 
//  728 //----------------------------------------------------------------------------
//  729 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  730 VOID usbSendNextPacketOnIEP0(VOID)
usbSendNextPacketOnIEP0:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function usbSendNextPacketOnIEP0
//  731 {
//  732     BYTE bPacketSize,bIndex;
//  733 
//  734     // First check if there are bytes remaining to be transferred
//  735     if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
        CMPX.W  #0xffff, &wBytesRemainingOnIEP0
        JEQ     ??usbSendNextPacketOnIEP0_1
//  736     {
//  737         if(wBytesRemainingOnIEP0 > EP0_PACKET_SIZE)
        CMPX.W  #0x9, &wBytesRemainingOnIEP0
        JNC     ??usbSendNextPacketOnIEP0_2
//  738         {
//  739             // More bytes are remaining than will fit in one packet
//  740             // there will be More IN Stage
//  741             bPacketSize = EP0_PACKET_SIZE;
        MOV.B   #0x8, R14
//  742             wBytesRemainingOnIEP0 -= EP0_PACKET_SIZE;
        ADDX.W  #0xfff8, &wBytesRemainingOnIEP0
//  743             bStatusAction = STATUS_ACTION_DATA_IN;
        MOVX.B  #0x1, &bStatusAction
        JMP     ??usbSendNextPacketOnIEP0_3
//  744         }
//  745         else if (wBytesRemainingOnIEP0 < EP0_PACKET_SIZE)
??usbSendNextPacketOnIEP0_2:
        CMPX.W  #0x8, &wBytesRemainingOnIEP0
        JC      ??usbSendNextPacketOnIEP0_4
//  746         {
//  747             // The remaining data will fit in one packet.
//  748             // This case will properly handle wBytesRemainingOnIEP0 == 0
//  749             bPacketSize = (BYTE)wBytesRemainingOnIEP0;
        MOVX.B  &wBytesRemainingOnIEP0, R14
//  750             wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
//  751             bStatusAction = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
        JMP     ??usbSendNextPacketOnIEP0_3
//  752         }
//  753         else
//  754         {
//  755             bPacketSize = EP0_PACKET_SIZE;
??usbSendNextPacketOnIEP0_4:
        MOV.B   #0x8, R14
//  756             if(bHostAskMoreDataThanAvailable == TRUE)
        CMPX.B  #0x1, &bHostAskMoreDataThanAvailable
        JNE     ??usbSendNextPacketOnIEP0_5
//  757             {
//  758                 wBytesRemainingOnIEP0 = 0;
        MOVX.W  #0x0, &wBytesRemainingOnIEP0
//  759                 bStatusAction = STATUS_ACTION_DATA_IN;
        MOVX.B  #0x1, &bStatusAction
        JMP     ??usbSendNextPacketOnIEP0_3
//  760             }
//  761             else
//  762             {
//  763                 wBytesRemainingOnIEP0 = NO_MORE_DATA;
??usbSendNextPacketOnIEP0_5:
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
//  764                 bStatusAction = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
//  765             }
//  766         }
//  767 
//  768         for(bIndex=0; bIndex<bPacketSize; bIndex++)
??usbSendNextPacketOnIEP0_3:
        MOV.B   #0x0, R15
??usbSendNextPacketOnIEP0_0:
        CMP.B   R14, R15
        JC      ??usbSendNextPacketOnIEP0_6
//  769         {
//  770             abIEP0Buffer[bIndex] = *pbIEP0Buffer;
        MOVA    &pbIEP0Buffer, R13
        MOV.B   R15, R15
        MOV.B   @R13, 0x2378(R15)
//  771             pbIEP0Buffer++;
        ADDX.A  #0x1, &pbIEP0Buffer
//  772         }
        ADD.B   #0x1, R15
        JMP     ??usbSendNextPacketOnIEP0_0
//  773         tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;
??usbSendNextPacketOnIEP0_6:
        MOV.B   R14, &0x921
        RETA
//  774     }
//  775     else
//  776     {
//  777         bStatusAction = STATUS_ACTION_NOTHING;
??usbSendNextPacketOnIEP0_1:
        MOVX.B  #0x0, &bStatusAction
//  778     }
//  779 }
        RETA
          CFI EndBlock cfiBlock17
        REQUIRE abIEP0Buffer
        REQUIRE tEndPoint0DescriptorBlock
//  780 
//  781 //----------------------------------------------------------------------------
//  782 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  783 VOID usbSendDataPacketOnEP0(PBYTE pbBuffer)
usbSendDataPacketOnEP0:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function usbSendDataPacketOnEP0
//  784 {
        FUNCALL usbSendDataPacketOnEP0, usbSendNextPacketOnIEP0
        LOCFRAME CSTACK, 8, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
//  785     WORD wTemp;
//  786 
//  787     pbIEP0Buffer = pbBuffer;
        MOVA    R12, &pbIEP0Buffer
//  788     wTemp = tSetupPacket.wLength;
        MOV.W   &0x2386, R10
//  789 
//  790     // Limit transfer size to wLength if needed
//  791     // this prevent USB device sending 'more than require' data back to host
//  792     if(wBytesRemainingOnIEP0 >= wTemp)
        CMPX.W  R10, &wBytesRemainingOnIEP0
        JNC     ??usbSendDataPacketOnEP0_0
//  793     {
//  794         wBytesRemainingOnIEP0 = wTemp;
        MOVX.W  R10, &wBytesRemainingOnIEP0
//  795         bHostAskMoreDataThanAvailable = FALSE;
        MOVX.B  #0x0, &bHostAskMoreDataThanAvailable
        JMP     ??usbSendDataPacketOnEP0_1
//  796     }
//  797     else
//  798     {
//  799         bHostAskMoreDataThanAvailable = TRUE;
??usbSendDataPacketOnEP0_0:
        MOVX.B  #0x1, &bHostAskMoreDataThanAvailable
//  800     }
//  801     usbSendNextPacketOnIEP0();
??usbSendDataPacketOnEP0_1:
        CALLA   #usbSendNextPacketOnIEP0
//  802 }
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock18
        REQUIRE tSetupPacket
//  803 
//  804 //----------------------------------------------------------------------------

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  805 VOID usbReceiveNextPacketOnOEP0(VOID)
usbReceiveNextPacketOnOEP0:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function usbReceiveNextPacketOnOEP0
//  806 {
//  807     BYTE bIndex,bByte;
//  808 
//  809     bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCNT_BYTECNT_MASK;
        FUNCALL usbReceiveNextPacketOnOEP0, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbReceiveNextPacketOnOEP0, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbReceiveNextPacketOnOEP0, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x923, R13
        AND.B   #0x7f, R13
        MOV.B   R13, R15
//  810 
//  811     if(wBytesRemainingOnOEP0 >= (WORD)bByte)
        MOV.B   R15, R15
        CMPX.W  R15, &wBytesRemainingOnOEP0
        JNC     ??usbReceiveNextPacketOnOEP0_1
//  812     {
//  813         for(bIndex=0;bIndex<bByte;bIndex++)
        MOV.B   #0x0, R14
??usbReceiveNextPacketOnOEP0_0:
        CMP.B   R15, R14
        JC      ??usbReceiveNextPacketOnOEP0_2
//  814         {
//  815             *pbOEP0Buffer = abOEP0Buffer[bIndex];
        MOV.B   R14, R14
        MOV.B   0x2370(R14), R13
        MOVA    &pbOEP0Buffer, R12
        MOV.B   R13, 0(R12)
//  816             pbOEP0Buffer++;
        ADDX.A  #0x1, &pbOEP0Buffer
//  817         }
        ADD.B   #0x1, R14
        JMP     ??usbReceiveNextPacketOnOEP0_0
//  818         wBytesRemainingOnOEP0 -= (WORD)bByte;
??usbReceiveNextPacketOnOEP0_2:
        MOV.B   R15, R15
        SUBX.W  R15, &wBytesRemainingOnOEP0
//  819 
//  820         // clear the NAK bit for next packet
//  821         if(wBytesRemainingOnOEP0 > 0)
        CMPX.W  #0x0, &wBytesRemainingOnOEP0
        JEQ     ??usbReceiveNextPacketOnOEP0_3
//  822         {
//  823             usbClearOEP0ByteCount();
        CALLA   #usbClearOEP0ByteCount
//  824             bStatusAction = STATUS_ACTION_DATA_OUT;
        MOVX.B  #0x2, &bStatusAction
        RETA
//  825         }
//  826         else
//  827         {
//  828             usbStallOEP0();
??usbReceiveNextPacketOnOEP0_3:
        CALLA   #usbStallOEP0
//  829             bStatusAction = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
        RETA
//  830         }
//  831     }
//  832     else
//  833     {
//  834         usbStallOEP0();
??usbReceiveNextPacketOnOEP0_1:
        CALLA   #usbStallOEP0
//  835         bStatusAction = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
//  836     }
//  837 }
        RETA
          CFI EndBlock cfiBlock19
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE abOEP0Buffer
//  838 
//  839 //----------------------------------------------------------------------------
//  840 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  841 VOID usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
usbReceiveDataPacketOnEP0:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function usbReceiveDataPacketOnEP0
//  842 {
//  843 
//  844     pbOEP0Buffer = pbBuffer;
        FUNCALL usbReceiveDataPacketOnEP0, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        MOVA    R12, &pbOEP0Buffer
//  845 
//  846     wBytesRemainingOnOEP0 = tSetupPacket.wLength;
        MOVX.W  &0x2386, &wBytesRemainingOnOEP0
//  847     bStatusAction = STATUS_ACTION_DATA_OUT;
        MOVX.B  #0x2, &bStatusAction
//  848 
//  849     usbClearOEP0ByteCount();
        BRA     #usbClearOEP0ByteCount
          CFI EndBlock cfiBlock20
        REQUIRE tSetupPacket
//  850 }
//  851 
//  852 //----------------------------------------------------------------------------
//  853 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  854 VOID usbSendZeroLengthPacketOnIEP0(VOID)
usbSendZeroLengthPacketOnIEP0:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function usbSendZeroLengthPacketOnIEP0
//  855 {
//  856     wBytesRemainingOnIEP0 = NO_MORE_DATA;
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
//  857     bStatusAction = STATUS_ACTION_NOTHING;
        MOVX.B  #0x0, &bStatusAction
//  858     tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
        MOV.B   #0x0, &0x921
//  859 }
        RETA
          CFI EndBlock cfiBlock21
        REQUIRE tEndPoint0DescriptorBlock
//  860 
//  861 //----------------------------------------------------------------------------
//  862 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  863 VOID usbClearEndpointFeature(VOID)
usbClearEndpointFeature:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function usbClearEndpointFeature
//  864 {
//  865     BYTE bEndpointNumber;
//  866 
//  867     // EP is from EP1 to EP7 while C language start from 0
//  868     bEndpointNumber = (tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM);
        FUNCALL usbClearEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbClearEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x2384, R15
        AND.B   #0xf, R15
        MOV.B   R15, R14
//  869     if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();
        CMP.B   #0x0, R14
        JNE     ??usbClearEndpointFeature_0
        BRA     #usbSendZeroLengthPacketOnIEP0
//  870     else
//  871     {
//  872         bEndpointNumber--;
??usbClearEndpointFeature_0:
        ADD.B   #0xff, R14
//  873         if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
        CMP.B   #0x7, R14
        JC      ??usbClearEndpointFeature_1
//  874         {
//  875             if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
        CMP.B   #0x0, &0x2384
        JGE     ??usbClearEndpointFeature_2
//  876             {
//  877 #ifdef _MSC_
//  878                 if (!bMscResetRequired) {
        CMPX.B  #0x0, &bMscResetRequired
        JNE     ??usbClearEndpointFeature_3
//  879 #endif
//  880                   tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        AND.B   #0xd7, 0x23c8(R15)
//  881 #ifdef _MSC_
//  882                 }
//  883 #endif
//  884 #               ifdef _MSC_
//  885                     if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
??usbClearEndpointFeature_3:
        CMPX.B  R14, &stUsbHandle + 2
        JNE     ??usbClearEndpointFeature_4
//  886                     {
//  887                         MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscReadControl + 25
//  888                         bMcsCommandSupported = TRUE;
        MOVX.W  #0x1, &bMcsCommandSupported
        JMP     ??usbClearEndpointFeature_4
//  889                     }
//  890 #               endif
//  891             }
//  892             else
//  893             {
//  894 #ifdef _MSC_
//  895                 if (!bMscResetRequired) {
??usbClearEndpointFeature_2:
        CMPX.B  #0x0, &bMscResetRequired
        JNE     ??usbClearEndpointFeature_5
//  896 #endif
//  897                     tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        AND.B   #0xd7, 0x2388(R15)
//  898 #ifdef _MSC_
//  899                 }
//  900 #endif
//  901 #               ifdef _MSC_
//  902                     if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
??usbClearEndpointFeature_5:
        CMPX.B  R14, &stUsbHandle + 2
        JNE     ??usbClearEndpointFeature_4
//  903                     {
//  904                         MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscWriteControl + 30
//  905                         bMcsCommandSupported = TRUE;
        MOVX.W  #0x1, &bMcsCommandSupported
//  906                     }
//  907 #               endif
//  908             }
//  909             usbSendZeroLengthPacketOnIEP0();
??usbClearEndpointFeature_4:
        CALLA   #usbSendZeroLengthPacketOnIEP0
//  910         }
//  911     }
//  912 }
??usbClearEndpointFeature_1:
        RETA
          CFI EndBlock cfiBlock22
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
//  913 
//  914 //----------------------------------------------------------------------------
//  915 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  916 VOID usbGetConfiguration(VOID)
usbGetConfiguration:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function usbGetConfiguration
//  917 {
//  918     usbClearOEP0ByteCount();                    // for status stage
        FUNCALL usbGetConfiguration, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetConfiguration, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbClearOEP0ByteCount
//  919     wBytesRemainingOnIEP0 = 1;
        MOVX.W  #0x1, &wBytesRemainingOnIEP0
//  920     usbSendDataPacketOnEP0((PBYTE)&bConfigurationNumber);
        MOVA    #bConfigurationNumber, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock23
//  921 }
//  922 
//  923 //----------------------------------------------------------------------------
//  924 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  925 VOID usbGetDeviceDescriptor(VOID)
usbGetDeviceDescriptor:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function usbGetDeviceDescriptor
//  926 {
//  927     usbClearOEP0ByteCount();
        FUNCALL usbGetDeviceDescriptor, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetDeviceDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbClearOEP0ByteCount
//  928     wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
        MOVX.W  #0x12, &wBytesRemainingOnIEP0
//  929     usbSendDataPacketOnEP0((PBYTE) &abromDeviceDescriptor);
        MOVA    #abromDeviceDescriptor, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock24
//  930 }
//  931 
//  932 //----------------------------------------------------------------------------
//  933 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  934 VOID usbGetConfigurationDescriptor(VOID)
usbGetConfigurationDescriptor:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function usbGetConfigurationDescriptor
//  935 {
//  936     usbClearOEP0ByteCount();
        FUNCALL usbGetConfigurationDescriptor, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetConfigurationDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbClearOEP0ByteCount
//  937     wBytesRemainingOnIEP0 = sizeof(abromConfigurationDescriptorGroup);
        MOVX.W  #0x82, &wBytesRemainingOnIEP0
//  938     usbSendDataPacketOnEP0((PBYTE)&abromConfigurationDescriptorGroup);
        MOVA    #abromConfigurationDescriptorGroup, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock25
//  939 }
//  940 
//  941 //----------------------------------------------------------------------------
//  942 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  943 VOID usbGetStringDescriptor(VOID)
usbGetStringDescriptor:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function usbGetStringDescriptor
//  944 {
        FUNCALL usbGetStringDescriptor, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 12, STACK
        FUNCALL usbGetStringDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 12, STACK
        FUNCALL usbGetStringDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  945     WORD bIndex;
//  946     BYTE bVal = (BYTE)tSetupPacket.wValue;
        MOV.B   &0x2382, R11
//  947 
//  948     usbClearOEP0ByteCount();                    // for status stage
        CALLA   #usbClearOEP0ByteCount
//  949 #if (USB_STR_INDEX_SERNUM != 0)
//  950 
//  951     if(bVal == 0x03)
        CMP.B   #0x3, R11
        JNE     ??usbGetStringDescriptor_1
//  952     {
//  953         wBytesRemainingOnIEP0 = abramSerialStringDescriptor[0];
        MOVX.B  &abramSerialStringDescriptor, R15
        MOV.B   R15, R15
        MOVX.W  R15, &wBytesRemainingOnIEP0
//  954         usbSendDataPacketOnEP0((PBYTE)&abramSerialStringDescriptor);
        MOVA    #abramSerialStringDescriptor, R12
        CALLA   #usbSendDataPacketOnEP0
        JMP     ??usbGetStringDescriptor_2
//  955     }
//  956     else
//  957 #endif
//  958     {
//  959         bIndex = 0x00;
??usbGetStringDescriptor_1:
        MOV.W   #0x0, R10
//  960         while(bVal-- >  0x00) bIndex += abromStringDescriptor[bIndex];
??usbGetStringDescriptor_0:
        MOV.B   R11, R14
        MOV.B   R14, R11
        ADD.B   #0xff, R11
        CMP.B   #0x1, R14
        JNC     ??usbGetStringDescriptor_3
        MOVX.B  abromStringDescriptor(R10), R15
        MOV.B   R15, R15
        ADD.W   R15, R10
        JMP     ??usbGetStringDescriptor_0
//  961         wBytesRemainingOnIEP0 = abromStringDescriptor[bIndex];
??usbGetStringDescriptor_3:
        MOVX.B  abromStringDescriptor(R10), R15
        MOV.B   R15, R15
        MOVX.W  R15, &wBytesRemainingOnIEP0
//  962         usbSendDataPacketOnEP0((PBYTE)&abromStringDescriptor[bIndex]);
        MOV.W   R10, R12
        ADDA    #abromStringDescriptor, R12
        CALLA   #usbSendDataPacketOnEP0
//  963     }
//  964 }
??usbGetStringDescriptor_2:
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock26
        REQUIRE tSetupPacket
//  965 
//  966 //----------------------------------------------------------------------------
//  967 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  968 VOID usbGetInterface(VOID)
usbGetInterface:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function usbGetInterface
//  969 {
//  970 
//  971     // not fully supported, return one byte, zero
//  972     usbClearOEP0ByteCount();                    // for status stage
        FUNCALL usbGetInterface, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetInterface, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbClearOEP0ByteCount
//  973     wBytesRemainingOnIEP0 = 0x02;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
//  974     abUsbRequestReturnData[0] = 0x00;           // changed to report alternative setting byte
        MOVX.B  #0x0, &abUsbRequestReturnData
//  975     abUsbRequestReturnData[1] = bInterfaceNumber;
        MOVX.B  &bInterfaceNumber, &abUsbRequestReturnData + 1
//  976     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        MOVA    #abUsbRequestReturnData, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock27
//  977 }
//  978 
//  979 //----------------------------------------------------------------------------
//  980 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  981 VOID usbGetDeviceStatus(VOID)
usbGetDeviceStatus:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function usbGetDeviceStatus
//  982 {
//  983     if((abromConfigurationDescriptorGroup.abromConfigurationDescriptorGenric.mattributes &
//  984         CFG_DESC_ATTR_SELF_POWERED) == CFG_DESC_ATTR_SELF_POWERED)
        FUNCALL usbGetDeviceStatus, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetDeviceStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        BITX.B  #0x40, &abromConfigurationDescriptorGroup + 7
        JNC     ??usbGetDeviceStatus_0
//  985     {
//  986         abUsbRequestReturnData[0] = DEVICE_STATUS_SELF_POWER;
        MOVX.B  #0x1, &abUsbRequestReturnData
//  987     }
//  988     if(bRemoteWakeup == ENABLE)
??usbGetDeviceStatus_0:
        CMPX.B  #0x1, &bRemoteWakeup
        JNE     ??usbGetDeviceStatus_1
//  989     {
//  990         abUsbRequestReturnData[0] |= DEVICE_STATUS_REMOTE_WAKEUP;
        BISX.B  #0x2, &abUsbRequestReturnData
//  991     }
//  992     usbClearOEP0ByteCount();                    // for status stage
??usbGetDeviceStatus_1:
        CALLA   #usbClearOEP0ByteCount
//  993 
//  994     // Return self power status and remote wakeup status
//  995     wBytesRemainingOnIEP0 = 2;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
//  996     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        MOVA    #abUsbRequestReturnData, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock28
//  997 }
//  998 
//  999 //----------------------------------------------------------------------------
// 1000 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1001 VOID usbGetInterfaceStatus(VOID)
usbGetInterfaceStatus:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function usbGetInterfaceStatus
// 1002 {
// 1003     // check bIndexL for index number (not supported)
// 1004     usbClearOEP0ByteCount();                    // for status stage
        FUNCALL usbGetInterfaceStatus, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetInterfaceStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbClearOEP0ByteCount
// 1005 
// 1006     // Return two zero bytes
// 1007     wBytesRemainingOnIEP0 = 2;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
// 1008     abUsbRequestReturnData[0] = 0x00;           // changed to support multiple interfaces
        MOVX.B  #0x0, &abUsbRequestReturnData
// 1009     abUsbRequestReturnData[1] = bInterfaceNumber;
        MOVX.B  &bInterfaceNumber, &abUsbRequestReturnData + 1
// 1010     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        MOVA    #abUsbRequestReturnData, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock29
// 1011 }
// 1012 
// 1013 //----------------------------------------------------------------------------
// 1014 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1015 VOID usbGetEndpointStatus(VOID)
usbGetEndpointStatus:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function usbGetEndpointStatus
// 1016 {
        FUNCALL usbGetEndpointStatus, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 8, STACK
        FUNCALL usbGetEndpointStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 8, STACK
        FUNCALL usbGetEndpointStatus, usbClearOEP0ByteCount
        LOCFRAME CSTACK, 8, STACK
        FUNCALL usbGetEndpointStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 8, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
// 1017     BYTE bEndpointNumber;
// 1018 
// 1019     // Endpoint number is bIndexL
// 1020     bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
        MOV.B   &0x2384, R14
        AND.B   #0xf, R14
        MOV.B   R14, R10
// 1021     if(bEndpointNumber == 0x00)
        CMP.B   #0x0, R10
        JNE     ??usbGetEndpointStatus_0
// 1022     {
// 1023         if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
        CMP.B   #0x0, &0x2384
        JGE     ??usbGetEndpointStatus_1
// 1024         {
// 1025             // input endpoint 0
// 1026             abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bIEPCNFG & EPCNF_STALL);
        MOV.B   &0x920, R14
        AND.B   #0x8, R14
        MOVX.B  R14, &abUsbRequestReturnData
        JMP     ??usbGetEndpointStatus_2
// 1027         }
// 1028         else
// 1029         {
// 1030             // output endpoint 0
// 1031             abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bOEPCNFG & EPCNF_STALL);
??usbGetEndpointStatus_1:
        MOV.B   &0x922, R14
        AND.B   #0x8, R14
        MOVX.B  R14, &abUsbRequestReturnData
// 1032         }
// 1033         abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
??usbGetEndpointStatus_2:
        MOVX.B  &abUsbRequestReturnData, R14
        RPT     #0x3
        RRUX.B  R14
        MOVX.B  R14, &abUsbRequestReturnData
// 1034         usbClearOEP0ByteCount();                    // for status stage
        CALLA   #usbClearOEP0ByteCount
// 1035         wBytesRemainingOnIEP0 = 0x02;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
// 1036         usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        MOVA    #abUsbRequestReturnData, R12
        CALLA   #usbSendDataPacketOnEP0
        JMP     ??usbGetEndpointStatus_3
// 1037     }
// 1038     else
// 1039     {
// 1040         bEndpointNumber--;
??usbGetEndpointStatus_0:
        ADD.B   #0xff, R10
// 1041         // EP is from EP1 to EP7 while C language start from 0
// 1042         // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
// 1043         if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
        CMP.B   #0x7, R10
        JC      ??usbGetEndpointStatus_4
// 1044         {
// 1045             if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
        CMP.B   #0x0, &0x2384
        JGE     ??usbGetEndpointStatus_5
// 1046             {
// 1047                 // input endpoint
// 1048                 abUsbRequestReturnData[0] = (BYTE)(tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
        MOV.B   R10, R15
        RLAM.W  #0x3, R15
        MOV.B   0x23c8(R15), R14
        AND.B   #0x8, R14
        MOVX.B  R14, &abUsbRequestReturnData
        JMP     ??usbGetEndpointStatus_4
// 1049             }else
// 1050             {
// 1051                 // output endpoint
// 1052                 abUsbRequestReturnData[0] = (BYTE)(tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
??usbGetEndpointStatus_5:
        MOV.B   R10, R15
        RLAM.W  #0x3, R15
        MOV.B   0x2388(R15), R14
        AND.B   #0x8, R14
        MOVX.B  R14, &abUsbRequestReturnData
// 1053             }
// 1054         }   // no response if endpoint is not supported.
// 1055         abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
??usbGetEndpointStatus_4:
        MOVX.B  &abUsbRequestReturnData, R14
        RPT     #0x3
        RRUX.B  R14
        MOVX.B  R14, &abUsbRequestReturnData
// 1056         usbClearOEP0ByteCount();
        CALLA   #usbClearOEP0ByteCount
// 1057         wBytesRemainingOnIEP0 = 0x02;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
// 1058         usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        MOVA    #abUsbRequestReturnData, R12
        CALLA   #usbSendDataPacketOnEP0
// 1059     }
// 1060 }
??usbGetEndpointStatus_3:
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock30
        REQUIRE tSetupPacket
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
// 1061 
// 1062 //----------------------------------------------------------------------------

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1063 VOID usbSetAddress(VOID)
usbSetAddress:
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function usbSetAddress
// 1064 {
// 1065     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetAddress, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetAddress, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetAddress, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1066 
// 1067     // bValueL contains device address
// 1068     if(tSetupPacket.wValue < 128)
        CMP.W   #0x80, &0x2382
        JC      ??usbSetAddress_0
// 1069     {
// 1070         // hardware will update the address after status stage
// 1071         // therefore, firmware can set the address now.
// 1072         USBFUNADR = tSetupPacket.wValue;
        MOV.B   &0x2382, &0x93f
// 1073         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1074     }
// 1075     else
// 1076     {
// 1077         usbStallEndpoint0();
??usbSetAddress_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock31
        REQUIRE tSetupPacket
        REQUIRE USBFUNADR
// 1078     }
// 1079 }
// 1080 
// 1081 //----------------------------------------------------------------------------
// 1082 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1083 VOID usbSetConfiguration(VOID)
usbSetConfiguration:
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function usbSetConfiguration
// 1084 {
// 1085     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetConfiguration, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetConfiguration, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1086 
// 1087     // configuration number is in bValueL
// 1088     // change the code if more than one configuration is supported
// 1089     bConfigurationNumber = tSetupPacket.wValue;
        MOVX.B  &0x2382, &bConfigurationNumber
// 1090     usbSendZeroLengthPacketOnIEP0();
        CALLA   #usbSendZeroLengthPacketOnIEP0
// 1091 
// 1092     if (bConfigurationNumber == 1)
        CMPX.B  #0x1, &bConfigurationNumber
        JNE     ??usbSetConfiguration_0
// 1093     {
// 1094         bEnumerationStatus = ENUMERATION_COMPLETE;      // set device as enumerated
        MOVX.B  #0x1, &bEnumerationStatus
        RETA
// 1095     }
// 1096     else
// 1097     {
// 1098         bEnumerationStatus = 0; //device is not configured == config # is zero
??usbSetConfiguration_0:
        MOVX.B  #0x0, &bEnumerationStatus
// 1099     }
// 1100 }
        RETA
          CFI EndBlock cfiBlock32
        REQUIRE tSetupPacket
// 1101 
// 1102 //----------------------------------------------------------------------------
// 1103 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1104 VOID usbClearDeviceFeature(VOID)
usbClearDeviceFeature:
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function usbClearDeviceFeature
// 1105 {
// 1106     // bValueL contains feature selector
// 1107     if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
        FUNCALL usbClearDeviceFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbClearDeviceFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x1, &0x2382
        JNE     ??usbClearDeviceFeature_0
// 1108     {
// 1109         bRemoteWakeup = DISABLE;
        MOVX.B  #0x0, &bRemoteWakeup
// 1110         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1111     }
// 1112     else
// 1113     {
// 1114         usbStallEndpoint0();
??usbClearDeviceFeature_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock33
        REQUIRE tSetupPacket
// 1115     }
// 1116 }
// 1117 
// 1118 //----------------------------------------------------------------------------
// 1119 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1120 VOID usbSetDeviceFeature(VOID)
usbSetDeviceFeature:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function usbSetDeviceFeature
// 1121 {
// 1122     // bValueL contains feature selector
// 1123     if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
        FUNCALL usbSetDeviceFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetDeviceFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x1, &0x2382
        JNE     ??usbSetDeviceFeature_0
// 1124     {
// 1125         bRemoteWakeup = ENABLE;
        MOVX.B  #0x1, &bRemoteWakeup
// 1126         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1127     }
// 1128     else
// 1129     {
// 1130         usbStallEndpoint0();
??usbSetDeviceFeature_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock34
        REQUIRE tSetupPacket
// 1131     }
// 1132 }
// 1133 
// 1134 //----------------------------------------------------------------------------
// 1135 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1136 VOID usbSetEndpointFeature(VOID)
usbSetEndpointFeature:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function usbSetEndpointFeature
// 1137 {
// 1138     BYTE bEndpointNumber;
// 1139 
// 1140     // wValue contains feature selector
// 1141     // bIndexL contains endpoint number
// 1142     // Endpoint number is in low byte of wIndex
// 1143     if(tSetupPacket.wValue == FEATURE_ENDPOINT_STALL)
        FUNCALL usbSetEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetEndpointFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x0, &0x2382
        JNE     ??usbSetEndpointFeature_0
// 1144     {
// 1145         bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
        MOV.B   &0x2384, R15
        AND.B   #0xf, R15
        MOV.B   R15, R14
// 1146         if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();  // do nothing for endpoint 0
        CMP.B   #0x0, R14
        JNE     ??usbSetEndpointFeature_1
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1147         else
// 1148         {
// 1149             bEndpointNumber--;
??usbSetEndpointFeature_1:
        ADD.B   #0xff, R14
// 1150             // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
// 1151             if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
        CMP.B   #0x7, R14
        JC      ??usbSetEndpointFeature_2
// 1152             {
// 1153                 if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
        CMP.B   #0x0, &0x2384
        JGE     ??usbSetEndpointFeature_3
// 1154                 {
// 1155                     // input endpoint
// 1156                     tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        BIS.B   #0x8, 0x23c8(R15)
        JMP     ??usbSetEndpointFeature_4
// 1157                 }
// 1158                 else
// 1159                 {
// 1160                     // output endpoint
// 1161                     tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
??usbSetEndpointFeature_3:
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        BIS.B   #0x8, 0x2388(R15)
// 1162                 }
// 1163                 usbSendZeroLengthPacketOnIEP0();
??usbSetEndpointFeature_4:
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1164             } // no response if endpoint is not supported.
// 1165         }
// 1166     }
// 1167     else
// 1168     {
// 1169         usbStallEndpoint0();
??usbSetEndpointFeature_0:
        CALLA   #usbStallEndpoint0
// 1170     }
// 1171 }
??usbSetEndpointFeature_2:
        RETA
          CFI EndBlock cfiBlock35
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
// 1172 
// 1173 //----------------------------------------------------------------------------
// 1174 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1175 VOID usbSetInterface(VOID)
usbSetInterface:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function usbSetInterface
// 1176 {
// 1177     // bValueL contains alternative setting
// 1178     // bIndexL contains interface number
// 1179     // change code if more than one interface is supported
// 1180     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetInterface, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetInterface, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1181     bInterfaceNumber = tSetupPacket.wIndex;
        MOVX.B  &0x2384, &bInterfaceNumber
// 1182 #ifdef _MSC_
// 1183     tInputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
        MOVX.B  &stUsbHandle + 2, R15
        MOV.B   R15, R15
        RLAM.W  #0x3, R15
        BIC.B   #0x20, 0x23c8(R15)
// 1184     tOutputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
        MOVX.B  &stUsbHandle + 2, R15
        MOV.B   R15, R15
        RLAM.W  #0x3, R15
        BIC.B   #0x20, 0x2388(R15)
// 1185     MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscReadControl + 25
// 1186     MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscWriteControl + 30
// 1187 #endif
// 1188     usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
          CFI EndBlock cfiBlock36
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
// 1189 }
// 1190 
// 1191 //----------------------------------------------------------------------------
// 1192 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1193 VOID usbInvalidRequest(VOID)
usbInvalidRequest:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function usbInvalidRequest
// 1194 {
// 1195     // check if setup overwrite is set
// 1196     // if set, do nothing since we might decode it wrong
// 1197     // setup packet buffer could be modified by hardware if another setup packet
// 1198     // was sent while we are deocding setup packet
// 1199     if ((USBIFG & STPOWIFG) == 0x00)
        FUNCALL usbInvalidRequest, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        BIT.B   #0x1, &0x93e
        JC      ??usbInvalidRequest_0
// 1200     {
// 1201       usbStallEndpoint0();
        CALLA   #usbStallEndpoint0
// 1202     }
// 1203 }
??usbInvalidRequest_0:
        RETA
          CFI EndBlock cfiBlock37
        REQUIRE USBIFG
// 1204 
// 1205 typedef VOID (*tpF)(VOID);
// 1206 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1207 BYTE usbDecodeAndProcessUsbRequest(VOID)
usbDecodeAndProcessUsbRequest:
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function usbDecodeAndProcessUsbRequest
// 1208 {
        FUNCALL usbDecodeAndProcessUsbRequest
        LOCFRAME CSTACK, 40, STACK
        FUNCALL usbDecodeAndProcessUsbRequest, USB_handleEnumCompleteEvent
        LOCFRAME CSTACK, 40, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUB.W   #0x4, SP
          CFI CFA SP+40
// 1209     BYTE  bMask,bResult,bTemp;
// 1210     const BYTE* pbUsbRequestList;
// 1211     BYTE bWakeUp = FALSE;
        MOV.B   #0x0, R6
// 1212     ptDEVICE_REQUEST ptSetupPacket = &tSetupPacket;
        MOVX.A  #0x2380, 0(SP)
// 1213     BYTE  bRequestType,bRequest;
// 1214     tpF lAddrOfFunction;
// 1215 
// 1216     // point to beginning of the matrix
// 1217     pbUsbRequestList = (PBYTE)&tUsbRequestList[0];
        MOVA    #tUsbRequestList, R9
// 1218 
// 1219     while(1)
// 1220     {
// 1221         bRequestType = *pbUsbRequestList++;
??usbDecodeAndProcessUsbRequest_1:
        MOV.B   @R9, R5
        ADDA    #0x1, R9
// 1222         bRequest     = *pbUsbRequestList++;
        MOV.B   @R9, R7
        ADDA    #0x1, R9
// 1223 
// 1224         if(((bRequestType == 0xff) && (bRequest == 0xff)) ||
// 1225             (tSetupPacket.bmRequestType == (USB_REQ_TYPE_INPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)) ||
// 1226             (tSetupPacket.bmRequestType == (USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)))
        CMP.B   #0xff, R5
        JNE     ??usbDecodeAndProcessUsbRequest_2
        CMP.B   #0xff, R7
        JEQ     ??usbDecodeAndProcessUsbRequest_3
??usbDecodeAndProcessUsbRequest_2:
        CMP.B   #0xc0, &0x2380
        JEQ     ??usbDecodeAndProcessUsbRequest_3
        CMP.B   #0x40, &0x2380
        JNE     ??usbDecodeAndProcessUsbRequest_4
// 1227         {
// 1228             pbUsbRequestList -= 2;
??usbDecodeAndProcessUsbRequest_3:
        ADDA    #0xffffe, R9
// 1229             break;
        JMP     ??usbDecodeAndProcessUsbRequest_5
// 1230         }
// 1231 
// 1232         if((bRequestType == tSetupPacket.bmRequestType) && (bRequest == tSetupPacket.bRequest))
??usbDecodeAndProcessUsbRequest_4:
        CMP.B   &0x2380, R5
        JNE     ??usbDecodeAndProcessUsbRequest_6
        CMP.B   &0x2381, R7
        JNE     ??usbDecodeAndProcessUsbRequest_6
// 1233         {
// 1234             // compare the first two
// 1235             bResult = 0xc0;
        MOV.B   #0xc0, R8
// 1236             bMask   = 0x20;
        MOV.B   #0x20, R11
// 1237             // first two bytes matched, compare the rest
// 1238             for(bTemp = 2; bTemp < 8; bTemp++)
        MOV.B   #0x2, R10
??usbDecodeAndProcessUsbRequest_0:
        CMP.B   #0x8, R10
        JC      ??usbDecodeAndProcessUsbRequest_7
// 1239             {
// 1240                 if (*((BYTE*)ptSetupPacket + bTemp) == *pbUsbRequestList)
        MOVA    @SP, R15
        MOV.B   R10, R14
        ADDA    R15, R14
        CMP.B   @R9, 0(R14)
        JNE     ??usbDecodeAndProcessUsbRequest_8
// 1241                 {
// 1242                     bResult |= bMask;
        BIS.B   R11, R8
// 1243                 }
// 1244                 pbUsbRequestList++;
??usbDecodeAndProcessUsbRequest_8:
        ADDA    #0x1, R9
// 1245                 bMask = bMask >> 1;
        RRUX.B  R11
// 1246             }
        ADD.B   #0x1, R10
        JMP     ??usbDecodeAndProcessUsbRequest_0
// 1247             // now we have the result
// 1248             if((*pbUsbRequestList & bResult) == *pbUsbRequestList)
??usbDecodeAndProcessUsbRequest_7:
        MOV.B   R8, R14
        AND.B   @R9, R14
        CMP.B   @R9, R14
        JNE     ??usbDecodeAndProcessUsbRequest_9
// 1249             {
// 1250                 pbUsbRequestList -= 8;
        ADDA    #0xffff8, R9
// 1251                 break;
        JMP     ??usbDecodeAndProcessUsbRequest_5
// 1252             }
// 1253             else
// 1254             {
// 1255                 pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-8);
??usbDecodeAndProcessUsbRequest_9:
        ADDA    #0x6, R9
        JMP     ??usbDecodeAndProcessUsbRequest_1
// 1256             }
// 1257         }
// 1258         else
// 1259         {
// 1260             pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-2);
??usbDecodeAndProcessUsbRequest_6:
        ADDA    #0xc, R9
        JMP     ??usbDecodeAndProcessUsbRequest_1
// 1261         }
// 1262     }
// 1263 
// 1264     // if another setup packet comes before we have the chance to process current
// 1265     // setup request, we return here without processing the request
// 1266     // this check is not necessary but still kept here to reduce response(or simulation) time
// 1267 
// 1268     if((USBIFG & STPOWIFG) != 0x00)
??usbDecodeAndProcessUsbRequest_5:
        BIT.B   #0x1, &0x93e
        JNC     ??usbDecodeAndProcessUsbRequest_10
// 1269     {
// 1270         return bWakeUp;
        MOV.B   R6, R12
        JMP     ??usbDecodeAndProcessUsbRequest_11
// 1271     }
// 1272 
// 1273     // now we found the match and jump to the function accordingly.
// 1274     lAddrOfFunction = ((tDEVICE_REQUEST_COMPARE*)pbUsbRequestList)->pUsbFunction;
??usbDecodeAndProcessUsbRequest_10:
        MOVA    0xa(R9), R4
// 1275 
// 1276     // call function
// 1277     (*lAddrOfFunction)();
        CALLA   R4
// 1278 
// 1279     // perform enumeration complete event:
// 1280     // when SetAddress was called and USBADDR is not zero
// 1281     if ((lAddrOfFunction == &usbSetAddress) && (USBFUNADR != 0))
        CMPA    #usbSetAddress, R4
        JNE     ??usbDecodeAndProcessUsbRequest_12
        CMP.B   #0x0, &0x93f
        JEQ     ??usbDecodeAndProcessUsbRequest_12
// 1282     {
// 1283         bWakeUp = USB_handleEnumCompleteEvent();
        CALLA   #USB_handleEnumCompleteEvent
        MOV.B   R12, R6
// 1284     }
// 1285     return bWakeUp;
??usbDecodeAndProcessUsbRequest_12:
        MOV.B   R6, R12
??usbDecodeAndProcessUsbRequest_11:
        ADD.W   #0x4, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock38
        REQUIRE tSetupPacket
        REQUIRE USBIFG
        REQUIRE USBFUNADR
// 1286 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1287 
// 1288 /*----------------------------------------------------------------------------+
// 1289 | End of source file                                                          |
// 1290 +----------------------------------------------------------------------------*/
// 1291 /*------------------------ Nothing Below This Line --------------------------*/
// 
// 2 734 bytes in segment CODE
//   162 bytes in segment DATA16_AN
//    34 bytes in segment DATA20_N
//    37 bytes in segment DATA20_Z
// 
// 2 734 bytes of CODE memory
//    71 bytes of DATA memory (+ 162 bytes shared)
//
//Errors: none
//Warnings: none
