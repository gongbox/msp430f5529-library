///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:46 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_mutex.c                                       /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_mutex.c -D DEBUG -D RAM_VECTOR -lA            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug /
//                     \Obj\ --no_cse --no_unroll --no_inline                 /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \os_mutex.s43                                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME os_mutex

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?OneBitMask32
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC OSMutexAccept
        FUNCTION OSMutexAccept,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSMutexCreate
        FUNCTION OSMutexCreate,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSMutexDel
        FUNCTION OSMutexDel,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 38, STACK
        PUBLIC OSMutexPend
        FUNCTION OSMutexPend,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 42, STACK
        PUBLIC OSMutexPost
        FUNCTION OSMutexPost,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSMutexQuery
        FUNCTION OSMutexQuery,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        FUNCTION OSMutex_RdyAtPrio,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN OSRdyTbl
        EXTERN OSRdyGrp
        EXTERN OSPrioCur
        EXTERN OSTCBPrioTbl
        EXTERN OSIntNesting
        EXTERN OSCPUSaveSR
        FUNCTION OSCPUSaveSR,0202H
        EXTERN OSCPURestoreSR
        FUNCTION OSCPURestoreSR,0202H
        EXTERN OSTCBCur
        EXTERN OS_EventTaskRdy
        FUNCTION OS_EventTaskRdy,0202H
        EXTERN OS_Sched
        FUNCTION OS_Sched,0202H
        EXTERN OSLockNesting
        EXTERN OS_EventTaskWait
        FUNCTION OS_EventTaskWait,0202H
        EXTERN OS_EventTaskRemove
        FUNCTION OS_EventTaskRemove,0202H
        EXTERN OSEventFreeList
        EXTERN OS_EventWaitListInit
        FUNCTION OS_EventWaitListInit,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_mutex.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/OS-II
//    4 *                                          The Real-Time Kernel
//    5 *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
//    6 *
//    7 *                              (c) Copyright 1992-2009, Micrium, Weston, FL
//    8 *                                           All Rights Reserved
//    9 *
//   10 * File    : OS_MUTEX.C
//   11 * By      : Jean J. Labrosse
//   12 * Version : V2.91
//   13 *
//   14 * LICENSING TERMS:
//   15 * ---------------
//   16 *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
//   17 * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
//   18 * its use in your product. We provide ALL the source code for your convenience and to help you experience
//   19 * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
//   20 * licensing fee.
//   21 *********************************************************************************************************
//   22 */
//   23 
//   24 #ifndef  OS_MASTER_FILE
//   25 #include "ucos_ii.h"
//   26 #endif
//   27 
//   28 
//   29 #if OS_MUTEX_EN > 0u
//   30 /*
//   31 *********************************************************************************************************
//   32 *                                            LOCAL CONSTANTS
//   33 *********************************************************************************************************
//   34 */
//   35 
//   36 #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
//   37 #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
//   38 
//   39 #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
//   40 
//   41 /*
//   42 *********************************************************************************************************
//   43 *                                            LOCAL CONSTANTS
//   44 *********************************************************************************************************
//   45 */
//   46 
//   47 static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
//   48 
//   49 /*$PAGE*/
//   50 /*
//   51 *********************************************************************************************************
//   52 *                                   ACCEPT MUTUAL EXCLUSION SEMAPHORE
//   53 *
//   54 * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
//   55 *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
//   56 *              not available or the event did not occur.
//   57 *
//   58 * Arguments  : pevent     is a pointer to the event control block
//   59 *
//   60 *              perr       is a pointer to an error code which will be returned to your application:
//   61 *                            OS_ERR_NONE         if the call was successful.
//   62 *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
//   63 *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
//   64 *                            OS_ERR_PEND_ISR     if you called this function from an ISR
//   65 *                            OS_ERR_PIP_LOWER    If the priority of the task that owns the Mutex is
//   66 *                                                HIGHER (i.e. a lower number) than the PIP.  This error
//   67 *                                                indicates that you did not set the PIP higher (lower
//   68 *                                                number) than ALL the tasks that compete for the Mutex.
//   69 *                                                Unfortunately, this is something that could not be
//   70 *                                                detected when the Mutex is created because we don't know
//   71 *                                                what tasks will be using the Mutex.
//   72 *
//   73 * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
//   74 *              == OS_FALSE   a) if the resource is not available
//   75 *                            b) you didn't pass a pointer to a mutual exclusion semaphore
//   76 *                            c) you called this function from an ISR
//   77 *
//   78 * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
//   79 *              intended to be used by tasks only.
//   80 *********************************************************************************************************
//   81 */
//   82 
//   83 #if OS_MUTEX_ACCEPT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   84 BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
OSMutexAccept:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function OSMutexAccept
//   85                         INT8U     *perr)
//   86 {
        FUNCALL OSMutexAccept, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
        MOVA    R13, R11
//   87     INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
//   88 #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
//   89     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//   90 #endif
//   91 
//   92 
//   93 
//   94 #ifdef OS_SAFETY_CRITICAL
//   95     if (perr == (INT8U *)0) {
//   96         OS_SAFETY_CRITICAL_EXCEPTION();
//   97     }
//   98 #endif
//   99 
//  100 #if OS_ARG_CHK_EN > 0u
//  101     if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
//  102         *perr = OS_ERR_PEVENT_NULL;
//  103         return (OS_FALSE);
//  104     }
//  105 #endif
//  106     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
        CMP.B   #0x4, 0(R10)
        JEQ     ??OSMutexAccept_0
//  107         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  108         return (OS_FALSE);
        MOV.B   #0x0, R12
        JMP     ??OSMutexAccept_1
//  109     }
//  110     if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
??OSMutexAccept_0:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexAccept_2
//  111         *perr = OS_ERR_PEND_ISR;
        MOV.B   #0x2, 0(R11)
//  112         return (OS_FALSE);
        MOV.B   #0x0, R12
        JMP     ??OSMutexAccept_1
//  113     }
//  114     OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
??OSMutexAccept_2:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  115     pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
        MOV.B   0x7(R10), R8
//  116     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        MOV.B   0x6(R10), R14
        AND.B   #0xff, R14
        CMP.B   #0xff, R14
        JNE     ??OSMutexAccept_3
//  117         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
        AND.W   #0xff00, 0x6(R10)
//  118         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
        MOVA    &OSTCBCur, R15
        MOV.B   0x30(R15), R15
        MOV.B   R15, R15
        BIS.W   R15, 0x6(R10)
//  119         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
        MOVX.A  &OSTCBCur, 0x2(R10)
//  120         if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
        MOVA    &OSTCBCur, R15
        CMP.B   0x30(R15), R8
        JNC     ??OSMutexAccept_4
//  121             OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  122             *perr = OS_ERR_PIP_LOWER;
        MOV.B   #0x78, 0(R11)
        JMP     ??OSMutexAccept_5
//  123         } else {
//  124             OS_EXIT_CRITICAL();
??OSMutexAccept_4:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  125             *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  126         }
//  127         return (OS_TRUE);
??OSMutexAccept_5:
        MOV.B   #0x1, R12
        JMP     ??OSMutexAccept_1
//  128     }
//  129     OS_EXIT_CRITICAL();
??OSMutexAccept_3:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  130     *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  131     return (OS_FALSE);
        MOV.B   #0x0, R12
??OSMutexAccept_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  132 }
//  133 #endif
//  134 
//  135 /*$PAGE*/
//  136 /*
//  137 *********************************************************************************************************
//  138 *                                  CREATE A MUTUAL EXCLUSION SEMAPHORE
//  139 *
//  140 * Description: This function creates a mutual exclusion semaphore.
//  141 *
//  142 * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
//  143 *                            other words, when the semaphore is acquired and a higher priority task
//  144 *                            attempts to obtain the semaphore then the priority of the task owning the
//  145 *                            semaphore is raised to this priority.  It is assumed that you will specify
//  146 *                            a priority that is LOWER in value than ANY of the tasks competing for the
//  147 *                            mutex.
//  148 *
//  149 *              perr          is a pointer to an error code which will be returned to your application:
//  150 *                               OS_ERR_NONE         if the call was successful.
//  151 *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
//  152 *                               OS_ERR_PRIO_EXIST   if a task at the priority inheritance priority
//  153 *                                                   already exist.
//  154 *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
//  155 *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
//  156 *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
//  157 *
//  158 * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
//  159 *                            created mutex.
//  160 *              == (void *)0  if an error is detected.
//  161 *
//  162 * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' are used to hold the priority number
//  163 *                 of the task owning the mutex or 0xFF if no task owns the mutex.
//  164 *
//  165 *              2) The MOST  significant 8 bits of '.OSEventCnt' are used to hold the priority number
//  166 *                 to use to reduce priority inversion.
//  167 *********************************************************************************************************
//  168 */
//  169 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  170 OS_EVENT  *OSMutexCreate (INT8U   prio,
OSMutexCreate:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function OSMutexCreate
//  171                           INT8U  *perr)
//  172 {
        FUNCALL OSMutexCreate, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexCreate, OS_EventWaitListInit
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOVA    R13, R11
//  173     OS_EVENT  *pevent;
//  174 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  175     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  176 #endif
//  177 
//  178 
//  179 
//  180 #ifdef OS_SAFETY_CRITICAL
//  181     if (perr == (INT8U *)0) {
//  182         OS_SAFETY_CRITICAL_EXCEPTION();
//  183     }
//  184 #endif
//  185 
//  186 #ifdef OS_SAFETY_CRITICAL_IEC61508
//  187     if (OSSafetyCriticalStartFlag == OS_TRUE) {
//  188         OS_SAFETY_CRITICAL_EXCEPTION();
//  189     }
//  190 #endif
//  191 
//  192 #if OS_ARG_CHK_EN > 0u
//  193     if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
//  194         *perr = OS_ERR_PRIO_INVALID;
//  195         return ((OS_EVENT *)0);
//  196     }
//  197 #endif
//  198     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexCreate_0
//  199         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
        MOV.B   #0x10, 0(R11)
//  200         return ((OS_EVENT *)0);
        MOVA    #0x0, R12
        JMP     ??OSMutexCreate_1
//  201     }
//  202     OS_ENTER_CRITICAL();
??OSMutexCreate_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  203     if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  OSTCBPrioTbl(R15), R15
        CMPA    #0x0, R15
        JEQ     ??OSMutexCreate_2
//  204         OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  205         *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
        MOV.B   #0x28, 0(R11)
//  206         return ((OS_EVENT *)0);
        MOVA    #0x0, R12
        JMP     ??OSMutexCreate_1
//  207     }
//  208     OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
??OSMutexCreate_2:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  #0x1, OSTCBPrioTbl(R15)
//  209     pevent             = OSEventFreeList;                  /* Get next free event control block        */
        MOVA    &OSEventFreeList, R8
//  210     if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
        CMPA    #0x0, R8
        JNE     ??OSMutexCreate_3
//  211         OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  #0x0, OSTCBPrioTbl(R15)
//  212         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  213         *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
        MOV.B   #0x4, 0(R11)
//  214         return (pevent);
        MOVA    R8, R12
        JMP     ??OSMutexCreate_1
//  215     }
//  216     OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
??OSMutexCreate_3:
        MOVA    &OSEventFreeList, R15
        MOVX.A  0x2(R15), &OSEventFreeList
//  217     OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  218     pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
        MOV.B   #0x4, 0(R8)
//  219     pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
        MOV.B   R10, R15
        AND.W   #0xff, R15
        SWPB    R15
        BIS.W   #0xff, R15
        MOV.W   R15, 0x6(R8)
//  220     pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
        MOVX.A  #0x0, 0x2(R8)
//  221 #if OS_EVENT_NAME_EN > 0u
//  222     pevent->OSEventName    = (INT8U *)(void *)"?";
//  223 #endif
//  224     OS_EventWaitListInit(pevent);
        MOVA    R8, R12
        CALLA   #OS_EventWaitListInit
//  225     *perr                  = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  226     return (pevent);
        MOVA    R8, R12
??OSMutexCreate_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  227 }
//  228 
//  229 /*$PAGE*/
//  230 /*
//  231 *********************************************************************************************************
//  232 *                                          DELETE A MUTEX
//  233 *
//  234 * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
//  235 *
//  236 * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
//  237 *
//  238 *              opt           determines delete options as follows:
//  239 *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
//  240 *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
//  241 *                                                    In this case, all the tasks pending will be readied.
//  242 *
//  243 *              perr          is a pointer to an error code that can contain one of the following values:
//  244 *                            OS_ERR_NONE             The call was successful and the mutex was deleted
//  245 *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
//  246 *                            OS_ERR_INVALID_OPT      An invalid option was specified
//  247 *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
//  248 *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
//  249 *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
//  250 *
//  251 * Returns    : pevent        upon error
//  252 *              (OS_EVENT *)0 if the mutex was successfully deleted.
//  253 *
//  254 * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
//  255 *                 the mutex MUST check the return code of OSMutexPend().
//  256 *
//  257 *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
//  258 *                 time is directly proportional to the number of tasks waiting on the mutex.
//  259 *
//  260 *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
//  261 *                 resource(s) will no longer be guarded by the mutex.
//  262 *
//  263 *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
//  264 *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
//  265 *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
//  266 *                            that task will be made ready-to-run at its original priority.
//  267 *********************************************************************************************************
//  268 */
//  269 
//  270 #if OS_MUTEX_DEL_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  271 OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
OSMutexDel:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function OSMutexDel
//  272                        INT8U      opt,
//  273                        INT8U     *perr)
//  274 {
        FUNCALL OSMutexDel, OSCPUSaveSR
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OSCPURestoreSR
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OSCPURestoreSR
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OSMutex_RdyAtPrio
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OS_EventTaskRdy
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OSCPURestoreSR
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OS_Sched
        LOCFRAME CSTACK, 38, STACK
        FUNCALL OSMutexDel, OSCPURestoreSR
        LOCFRAME CSTACK, 38, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        PUSH.B  R13
          CFI CFA SP+38
        MOVA    R12, R11
        MOVA    R14, R8
//  275     BOOLEAN    tasks_waiting;
//  276     OS_EVENT  *pevent_return;
//  277     INT8U      pip;                                        /* Priority inheritance priority            */
//  278     INT8U      prio;
//  279     OS_TCB    *ptcb;
//  280 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  281     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  282 #endif
//  283 
//  284 
//  285 
//  286 #ifdef OS_SAFETY_CRITICAL
//  287     if (perr == (INT8U *)0) {
//  288         OS_SAFETY_CRITICAL_EXCEPTION();
//  289     }
//  290 #endif
//  291 
//  292 #if OS_ARG_CHK_EN > 0u
//  293     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  294         *perr = OS_ERR_PEVENT_NULL;
//  295         return (pevent);
//  296     }
//  297 #endif
//  298     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        CMP.B   #0x4, 0(R11)
        JEQ     ??OSMutexDel_3
//  299         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R8)
//  300         return (pevent);
        MOVA    R11, R12
        JMP     ??OSMutexDel_4
//  301     }
//  302     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
??OSMutexDel_3:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexDel_5
//  303         *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        MOV.B   #0xf, 0(R8)
//  304         return (pevent);
        MOVA    R11, R12
        JMP     ??OSMutexDel_4
//  305     }
//  306     OS_ENTER_CRITICAL();
??OSMutexDel_5:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  307     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
        CMP.B   #0x0, 0x8(R11)
        JEQ     ??OSMutexDel_6
//  308         tasks_waiting = OS_TRUE;                           /* Yes                                      */
        MOV.B   #0x1, R4
        JMP     ??OSMutexDel_7
//  309     } else {
//  310         tasks_waiting = OS_FALSE;                          /* No                                       */
??OSMutexDel_6:
        MOV.B   #0x0, R4
//  311     }
//  312     switch (opt) {
??OSMutexDel_7:
        MOV.B   @SP, R14
        SUB.B   #0x0, R14
        JEQ     ??OSMutexDel_8
        SUB.B   #0x1, R14
        JEQ     ??OSMutexDel_9
        JMP     ??OSMutexDel_10
//  313         case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
//  314              if (tasks_waiting == OS_FALSE) {
??OSMutexDel_8:
        CMP.B   #0x0, R4
        JNE     ??OSMutexDel_11
//  315 #if OS_EVENT_NAME_EN > 0u
//  316                  pevent->OSEventName = (INT8U *)(void *)"?";
//  317 #endif
//  318                  pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
        MOV.B   0x7(R11), R10
//  319                  OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  #0x0, OSTCBPrioTbl(R15)
//  320                  pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R11)
//  321                  pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R11)
//  322                  pevent->OSEventCnt  = 0u;
        MOV.W   #0x0, 0x6(R11)
//  323                  OSEventFreeList     = pevent;
        MOVA    R11, &OSEventFreeList
//  324                  OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  325                  *perr               = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  326                  pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
        MOVA    #0x0, R7
        JMP     ??OSMutexDel_2
//  327              } else {
//  328                  OS_EXIT_CRITICAL();
??OSMutexDel_11:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  329                  *perr               = OS_ERR_TASK_WAITING;
        MOV.B   #0x49, 0(R8)
//  330                  pevent_return       = pevent;
        MOVA    R11, R7
//  331              }
//  332              break;
        JMP     ??OSMutexDel_2
//  333 
//  334         case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
//  335              pip  = (INT8U)(pevent->OSEventCnt >> 8u);                    /* Get PIP of mutex          */
??OSMutexDel_9:
        MOV.B   0x7(R11), R10
//  336              prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
        MOV.B   0x6(R11), R5
//  337              ptcb = (OS_TCB *)pevent->OSEventPtr;
        MOVA    0x2(R11), R6
//  338              if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
        CMPA    #0x0, R6
        JEQ     ??OSMutexDel_0
//  339                  if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
        CMP.B   R10, 0x30(R6)
        JNE     ??OSMutexDel_0
//  340                      OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
        MOV.B   R5, R13
        MOVA    R6, R12
        CALLA   #OSMutex_RdyAtPrio
//  341                  }
//  342              }
//  343              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
??OSMutexDel_0:
        CMP.B   #0x0, 0x8(R11)
        JEQ     ??OSMutexDel_12
//  344                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x10, R14
        MOVA    #0x0, R13
        MOVA    R11, R12
        CALLA   #OS_EventTaskRdy
        JMP     ??OSMutexDel_0
//  345              }
//  346 #if OS_EVENT_NAME_EN > 0u
//  347              pevent->OSEventName = (INT8U *)(void *)"?";
//  348 #endif
//  349              pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
??OSMutexDel_12:
        MOV.B   0x7(R11), R10
//  350              OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  #0x0, OSTCBPrioTbl(R15)
//  351              pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R11)
//  352              pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R11)
//  353              pevent->OSEventCnt  = 0u;
        MOV.W   #0x0, 0x6(R11)
//  354              OSEventFreeList     = pevent;                 /* Get next free event control block        */
        MOVA    R11, &OSEventFreeList
//  355              OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  356              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
        CMP.B   #0x1, R4
        JNE     ??OSMutexDel_13
//  357                  OS_Sched();                               /* Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  358              }
//  359              *perr         = OS_ERR_NONE;
??OSMutexDel_13:
        MOV.B   #0x0, 0(R8)
//  360              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
        MOVA    #0x0, R7
//  361              break;
        JMP     ??OSMutexDel_2
//  362 
//  363         default:
//  364              OS_EXIT_CRITICAL();
??OSMutexDel_10:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  365              *perr         = OS_ERR_INVALID_OPT;
        MOV.B   #0x7, 0(R8)
//  366              pevent_return = pevent;
        MOVA    R11, R7
//  367              break;
//  368     }
//  369     return (pevent_return);
??OSMutexDel_2:
        MOVA    R7, R12
??OSMutexDel_4:
        ADD.W   #0x2, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  370 }
//  371 #endif
//  372 
//  373 /*$PAGE*/
//  374 /*
//  375 *********************************************************************************************************
//  376 *                                  PEND ON MUTUAL EXCLUSION SEMAPHORE
//  377 *
//  378 * Description: This function waits for a mutual exclusion semaphore.
//  379 *
//  380 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  381 *                            mutex.
//  382 *
//  383 *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
//  384 *                            wait for the resource up to the amount of time specified by this argument.
//  385 *                            If you specify 0, however, your task will wait forever at the specified
//  386 *                            mutex or, until the resource becomes available.
//  387 *
//  388 *              perr          is a pointer to where an error message will be deposited.  Possible error
//  389 *                            messages are:
//  390 *                               OS_ERR_NONE        The call was successful and your task owns the mutex
//  391 *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
//  392 *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
//  393 *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
//  394 *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
//  395 *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
//  396 *                                                  would lead to a suspension.
//  397 *                               OS_ERR_PIP_LOWER   If the priority of the task that owns the Mutex is
//  398 *                                                  HIGHER (i.e. a lower number) than the PIP.  This error
//  399 *                                                  indicates that you did not set the PIP higher (lower
//  400 *                                                  number) than ALL the tasks that compete for the Mutex.
//  401 *                                                  Unfortunately, this is something that could not be
//  402 *                                                  detected when the Mutex is created because we don't know
//  403 *                                                  what tasks will be using the Mutex.
//  404 *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
//  405 *
//  406 * Returns    : none
//  407 *
//  408 * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
//  409 *
//  410 *              2) You MUST NOT change the priority of the task that owns the mutex
//  411 *********************************************************************************************************
//  412 */
//  413 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  414 void  OSMutexPend (OS_EVENT  *pevent,
OSMutexPend:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function OSMutexPend
//  415                    INT32U     timeout,
//  416                    INT8U     *perr)
//  417 {
        FUNCALL OSMutexPend, OSCPUSaveSR
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OSCPURestoreSR
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OSCPURestoreSR
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OS_EventTaskWait
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OSCPURestoreSR
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OS_Sched
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OSCPUSaveSR
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OS_EventTaskRemove
        LOCFRAME CSTACK, 42, STACK
        FUNCALL OSMutexPend, OSCPURestoreSR
        LOCFRAME CSTACK, 42, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        PUSH.W  R15
          CFI CFA SP+38
        PUSH.W  R14
          CFI CFA SP+40
        SUB.W   #0x2, SP
          CFI CFA SP+42
        MOVA    R12, R10
        MOVA    R13, R9
//  418     INT8U      pip;                                        /* Priority Inheritance Priority (PIP)      */
//  419     INT8U      mprio;                                      /* Mutex owner priority                     */
//  420     BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
//  421     OS_TCB    *ptcb;
//  422     OS_EVENT  *pevent2;
//  423     INT8U      y;
//  424 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  425     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//  426 #endif
//  427 
//  428 
//  429 
//  430 #ifdef OS_SAFETY_CRITICAL
//  431     if (perr == (INT8U *)0) {
//  432         OS_SAFETY_CRITICAL_EXCEPTION();
//  433     }
//  434 #endif
//  435 
//  436 #if OS_ARG_CHK_EN > 0u
//  437     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  438         *perr = OS_ERR_PEVENT_NULL;
//  439         return;
//  440     }
//  441 #endif
//  442     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
        CMP.B   #0x4, 0(R10)
        JEQ     ??OSMutexPend_2
//  443         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R9)
//  444         return;
        JMP     ??OSMutexPend_1
//  445     }
//  446     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
??OSMutexPend_2:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexPend_3
//  447         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
        MOV.B   #0x2, 0(R9)
//  448         return;
        JMP     ??OSMutexPend_1
//  449     }
//  450     if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
??OSMutexPend_3:
        CMPX.B  #0x0, &OSLockNesting
        JEQ     ??OSMutexPend_4
//  451         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
        MOV.B   #0xd, 0(R9)
//  452         return;
        JMP     ??OSMutexPend_1
//  453     }
//  454 /*$PAGE*/
//  455     OS_ENTER_CRITICAL();
??OSMutexPend_4:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  456     pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
        MOV.B   0x7(R10), R4
//  457                                                            /* Is Mutex available?                      */
//  458     if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
        CMP.B   #0xff, 0x6(R10)
        JNE     ??OSMutexPend_5
//  459         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
        AND.W   #0xff00, 0x6(R10)
//  460         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
        MOVA    &OSTCBCur, R15
        MOV.B   0x30(R15), R15
        MOV.B   R15, R15
        BIS.W   R15, 0x6(R10)
//  461         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
        MOVX.A  &OSTCBCur, 0x2(R10)
//  462         if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
        MOVA    &OSTCBCur, R15
        CMP.B   0x30(R15), R4
        JNC     ??OSMutexPend_6
//  463             OS_EXIT_CRITICAL();                            /*      ... than current task!              */
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  464             *perr = OS_ERR_PIP_LOWER;
        MOV.B   #0x78, 0(R9)
        JMP     ??OSMutexPend_1
//  465         } else {
//  466             OS_EXIT_CRITICAL();
??OSMutexPend_6:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  467             *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R9)
//  468         }
//  469         return;
        JMP     ??OSMutexPend_1
//  470     }
//  471     mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
??OSMutexPend_5:
        MOV.B   0x6(R10), 0(SP)
//  472     ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
        MOVA    0x2(R10), R11
//  473     if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
        CMP.B   0x30(R11), R4
        JC      ??OSMutexPend_7
//  474         if (mprio > OSTCBCur->OSTCBPrio) {
        MOVA    &OSTCBCur, R15
        CMP.B   @SP, 0x30(R15)
        JC      ??OSMutexPend_7
//  475             y = ptcb->OSTCBY;
        MOV.B   0x32(R11), R7
//  476             if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {          /*     See if mutex owner is ready   */
        MOV.B   R7, R15
        MOVX.B  OSRdyTbl(R15), R14
        MOV.B   R14, R14
        MOV.B   0x33(R11), R15
        MOV.B   R15, R15
        AND.W   R15, R14
        CMP.B   #0x0, R14
        JEQ     ??OSMutexPend_8
//  477                 OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;         /*     Yes, Remove owner from Rdy ...*/
        MOV.B   R7, R15
        BICX.B  0x33(R11), OSRdyTbl(R15)
//  478                 if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
        MOV.B   R7, R15
        CMPX.B  #0x0, OSRdyTbl(R15)
        JNE     ??OSMutexPend_9
//  479                     OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
        BICX.B  0x34(R11), &OSRdyGrp
//  480                 }
//  481                 rdy = OS_TRUE;
??OSMutexPend_9:
        MOV.B   #0x1, R5
        JMP     ??OSMutexPend_10
//  482             } else {
//  483                 pevent2 = ptcb->OSTCBEventPtr;
??OSMutexPend_8:
        MOVA    0x1c(R11), R8
//  484                 if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
        CMPA    #0x0, R8
        JEQ     ??OSMutexPend_11
//  485                     y = ptcb->OSTCBY;
        MOV.B   0x32(R11), R7
//  486                     pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
        MOV.B   R7, R7
        MOVA    R8, R15
        ADDA    R7, R15
        BIC.B   0x33(R11), 0x9(R15)
//  487                     if (pevent2->OSEventTbl[y] == 0u) {
        MOV.B   R7, R7
        MOVA    R8, R15
        ADDA    R7, R15
        CMP.B   #0x0, 0x9(R15)
        JNE     ??OSMutexPend_11
//  488                         pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
        BIC.B   0x34(R11), 0x8(R8)
//  489                     }
//  490                 }
//  491                 rdy = OS_FALSE;                            /* No                                       */
??OSMutexPend_11:
        MOV.B   #0x0, R5
//  492             }
//  493             ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
??OSMutexPend_10:
        MOV.B   R4, 0x30(R11)
//  494 #if OS_LOWEST_PRIO <= 63u
//  495             ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
        MOV.B   0x30(R11), R14
        RPT     #0x3
        RRUX.B  R14
        MOV.B   R14, 0x32(R11)
//  496             ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
        MOV.B   0x30(R11), R14
        AND.B   #0x7, R14
        MOV.B   R14, 0x31(R11)
//  497 #else
//  498             ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
//  499             ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
//  500 #endif
//  501             ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
        MOV.B   0x32(R11), R12
        CALLA   #?OneBitMask32
        MOV.B   R12, 0x34(R11)
//  502             ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
        MOV.B   0x31(R11), R12
        CALLA   #?OneBitMask32
        MOV.B   R12, 0x33(R11)
//  503 
//  504             if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
        CMP.B   #0x1, R5
        JNE     ??OSMutexPend_12
//  505                 OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
        BISX.B  0x34(R11), &OSRdyGrp
//  506                 OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        MOV.B   0x32(R11), R15
        MOV.B   R15, R15
        BISX.B  0x33(R11), OSRdyTbl(R15)
        JMP     ??OSMutexPend_13
//  507             } else {
//  508                 pevent2 = ptcb->OSTCBEventPtr;
??OSMutexPend_12:
        MOVA    0x1c(R11), R8
//  509                 if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
        CMPA    #0x0, R8
        JEQ     ??OSMutexPend_13
//  510                     pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
        BIS.B   0x34(R11), 0x8(R8)
//  511                     pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        MOV.B   0x32(R11), R15
        MOV.B   R15, R15
        MOVA    R8, R14
        ADDA    R15, R14
        BIS.B   0x33(R11), 0x9(R14)
//  512                 }
//  513             }
//  514             OSTCBPrioTbl[pip] = ptcb;
??OSMutexPend_13:
        MOV.B   R4, R15
        RLAM.A  #0x2, R15
        MOVX.A  R11, OSTCBPrioTbl(R15)
//  515         }
//  516     }
//  517     OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
??OSMutexPend_7:
        MOVA    &OSTCBCur, R15
        BIS.B   #0x10, 0x2e(R15)
//  518     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  519     OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
        MOVA    &OSTCBCur, R15
        MOV.W   0x2(SP), 0x2a(R15)
        MOV.W   0x4(SP), 0x2c(R15)
//  520     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
        MOVA    R10, R12
        CALLA   #OS_EventTaskWait
//  521     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  522     OS_Sched();                                       /* Find next highest priority task ready         */
        CALLA   #OS_Sched
//  523     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  524     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        MOVA    &OSTCBCur, R15
        MOV.B   0x2f(R15), R14
        SUB.B   #0x0, R14
        JEQ     ??OSMutexPend_14
        SUB.B   #0x2, R14
        JEQ     ??OSMutexPend_15
        JMP     ??OSMutexPend_16
//  525         case OS_STAT_PEND_OK:
//  526              *perr = OS_ERR_NONE;
??OSMutexPend_14:
        MOV.B   #0x0, 0(R9)
//  527              break;
        JMP     ??OSMutexPend_17
//  528 
//  529         case OS_STAT_PEND_ABORT:
//  530              *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
??OSMutexPend_15:
        MOV.B   #0xe, 0(R9)
//  531              break;
        JMP     ??OSMutexPend_17
//  532 
//  533         case OS_STAT_PEND_TO:
//  534         default:
//  535              OS_EventTaskRemove(OSTCBCur, pevent);
??OSMutexPend_16:
        MOVA    R10, R13
        MOVA    &OSTCBCur, R12
        CALLA   #OS_EventTaskRemove
//  536              *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
        MOV.B   #0xa, 0(R9)
//  537              break;
//  538     }
//  539     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
??OSMutexPend_17:
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2e(R15)
//  540     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  541     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
        MOVA    &OSTCBCur, R15
        MOVX.A  #0x0, 0x1c(R15)
//  542 #if (OS_EVENT_MULTI_EN > 0u)
//  543     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
//  544 #endif
//  545     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  546 }
??OSMutexPend_1:
        ADD.W   #0x6, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  547 /*$PAGE*/
//  548 /*
//  549 *********************************************************************************************************
//  550 *                                  POST TO A MUTUAL EXCLUSION SEMAPHORE
//  551 *
//  552 * Description: This function signals a mutual exclusion semaphore
//  553 *
//  554 * Arguments  : pevent              is a pointer to the event control block associated with the desired
//  555 *                                  mutex.
//  556 *
//  557 * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
//  558 *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
//  559 *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
//  560 *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
//  561 *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
//  562 *              OS_ERR_PIP_LOWER        If the priority of the new task that owns the Mutex is
//  563 *                                      HIGHER (i.e. a lower number) than the PIP.  This error
//  564 *                                      indicates that you did not set the PIP higher (lower
//  565 *                                      number) than ALL the tasks that compete for the Mutex.
//  566 *                                      Unfortunately, this is something that could not be
//  567 *                                      detected when the Mutex is created because we don't know
//  568 *                                      what tasks will be using the Mutex.
//  569 *********************************************************************************************************
//  570 */
//  571 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  572 INT8U  OSMutexPost (OS_EVENT *pevent)
OSMutexPost:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function OSMutexPost
//  573 {
        FUNCALL OSMutexPost, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OSMutex_RdyAtPrio
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OS_EventTaskRdy
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OS_Sched
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OS_Sched
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSMutexPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R11
//  574     INT8U      pip;                                   /* Priority inheritance priority                 */
//  575     INT8U      prio;
//  576 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  577     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R8
//  578 #endif
//  579 
//  580 
//  581 
//  582     if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexPost_0
//  583         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
        MOV.B   #0x5, R12
        JMP     ??OSMutexPost_1
//  584     }
//  585 #if OS_ARG_CHK_EN > 0u
//  586     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  587         return (OS_ERR_PEVENT_NULL);
//  588     }
//  589 #endif
//  590     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
??OSMutexPost_0:
        CMP.B   #0x4, 0(R11)
        JEQ     ??OSMutexPost_2
//  591         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSMutexPost_1
//  592     }
//  593     OS_ENTER_CRITICAL();
??OSMutexPost_2:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R8
//  594     pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
        MOV.B   0x7(R11), R9
//  595     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
        MOV.B   0x6(R11), R10
//  596     if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
        MOVA    &OSTCBCur, R15
        MOVA    0x2(R11), R14
        CMPA    R14, R15
        JEQ     ??OSMutexPost_3
//  597         OS_EXIT_CRITICAL();
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  598         return (OS_ERR_NOT_MUTEX_OWNER);
        MOV.B   #0x64, R12
        JMP     ??OSMutexPost_1
//  599     }
//  600     if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
??OSMutexPost_3:
        MOVA    &OSTCBCur, R15
        CMP.B   R9, 0x30(R15)
        JNE     ??OSMutexPost_4
//  601         OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
        MOV.B   R10, R13
        MOVA    &OSTCBCur, R12
        CALLA   #OSMutex_RdyAtPrio
//  602     }
//  603     OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
??OSMutexPost_4:
        MOV.B   R9, R15
        RLAM.A  #0x2, R15
        MOVX.A  #0x1, OSTCBPrioTbl(R15)
//  604     if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
        CMP.B   #0x0, 0x8(R11)
        JEQ     ??OSMutexPost_5
//  605                                                       /* Yes, Make HPT waiting for mutex ready         */
//  606         prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x10, R14
        MOVA    #0x0, R13
        MOVA    R11, R12
        CALLA   #OS_EventTaskRdy
        MOV.B   R12, R10
//  607         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
        AND.W   #0xff00, 0x6(R11)
//  608         pevent->OSEventCnt |= prio;
        MOV.B   R10, R10
        BIS.W   R10, 0x6(R11)
//  609         pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  OSTCBPrioTbl(R15), 0x2(R11)
//  610         if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
        CMP.B   R10, R9
        JNC     ??OSMutexPost_6
//  611             OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  612             OS_Sched();                               /*      Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  613             return (OS_ERR_PIP_LOWER);
        MOV.B   #0x78, R12
        JMP     ??OSMutexPost_1
//  614         } else {
//  615             OS_EXIT_CRITICAL();
??OSMutexPost_6:
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  616             OS_Sched();                               /*      Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  617             return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        JMP     ??OSMutexPost_1
//  618         }
//  619     }
//  620     pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
??OSMutexPost_5:
        BIS.W   #0xff, 0x6(R11)
//  621     pevent->OSEventPtr  = (void *)0;
        MOVX.A  #0x0, 0x2(R11)
//  622     OS_EXIT_CRITICAL();
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  623     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSMutexPost_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  624 }
//  625 /*$PAGE*/
//  626 /*
//  627 *********************************************************************************************************
//  628 *                                     QUERY A MUTUAL EXCLUSION SEMAPHORE
//  629 *
//  630 * Description: This function obtains information about a mutex
//  631 *
//  632 * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
//  633 *
//  634 *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
//  635 *
//  636 * Returns    : OS_ERR_NONE          The call was successful and the message was sent
//  637 *              OS_ERR_QUERY_ISR     If you called this function from an ISR
//  638 *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
//  639 *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
//  640 *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
//  641 *********************************************************************************************************
//  642 */
//  643 
//  644 #if OS_MUTEX_QUERY_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  645 INT8U  OSMutexQuery (OS_EVENT       *pevent,
OSMutexQuery:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function OSMutexQuery
//  646                      OS_MUTEX_DATA  *p_mutex_data)
//  647 {
        FUNCALL OSMutexQuery, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSMutexQuery, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R7
        MOVA    R13, R10
//  648     INT8U       i;
//  649     OS_PRIO    *psrc;
//  650     OS_PRIO    *pdest;
//  651 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//  652     OS_CPU_SR   cpu_sr = 0u;
        MOV.W   #0x0, R6
//  653 #endif
//  654 
//  655 
//  656 
//  657     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSMutexQuery_1
//  658         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
        MOV.B   #0x6, R12
        JMP     ??OSMutexQuery_2
//  659     }
//  660 #if OS_ARG_CHK_EN > 0u
//  661     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  662         return (OS_ERR_PEVENT_NULL);
//  663     }
//  664     if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
//  665         return (OS_ERR_PDATA_NULL);
//  666     }
//  667 #endif
//  668     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
??OSMutexQuery_1:
        CMP.B   #0x4, 0(R7)
        JEQ     ??OSMutexQuery_3
//  669         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSMutexQuery_2
//  670     }
//  671     OS_ENTER_CRITICAL();
??OSMutexQuery_3:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  672     p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8u);
        MOV.B   0x7(R7), 0xb(R10)
//  673     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
        MOV.B   0x6(R7), 0xa(R10)
//  674     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
        CMP.B   #0xff, 0xa(R10)
        JNE     ??OSMutexQuery_4
//  675         p_mutex_data->OSValue = OS_TRUE;
        MOV.B   #0x1, 0x9(R10)
        JMP     ??OSMutexQuery_5
//  676     } else {
//  677         p_mutex_data->OSValue = OS_FALSE;
??OSMutexQuery_4:
        MOV.B   #0x0, 0x9(R10)
//  678     }
//  679     p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
??OSMutexQuery_5:
        MOV.B   0x8(R7), 0x8(R10)
//  680     psrc                      = &pevent->OSEventTbl[0];
        MOVA    R7, R15
        ADDA    #0x9, R15
        MOVA    R15, R8
//  681     pdest                     = &p_mutex_data->OSEventTbl[0];
        MOVA    R10, R9
//  682     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        MOV.B   #0x0, R11
??OSMutexQuery_0:
        CMP.B   #0x8, R11
        JC      ??OSMutexQuery_6
//  683         *pdest++ = *psrc++;
        MOV.B   @R8, 0(R9)
        ADDA    #0x1, R8
        ADDA    #0x1, R9
//  684     }
        ADD.B   #0x1, R11
        JMP     ??OSMutexQuery_0
//  685     OS_EXIT_CRITICAL();
??OSMutexQuery_6:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  686     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSMutexQuery_2:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  687 }
//  688 #endif                                                     /* OS_MUTEX_QUERY_EN                        */
//  689 
//  690 /*$PAGE*/
//  691 /*
//  692 *********************************************************************************************************
//  693 *                                RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
//  694 *
//  695 * Description: This function makes a task ready at the specified priority
//  696 *
//  697 * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
//  698 *
//  699 *              prio            is the desired priority
//  700 *
//  701 * Returns    : none
//  702 *********************************************************************************************************
//  703 */
//  704 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  705 static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
OSMutex_RdyAtPrio:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function OSMutex_RdyAtPrio
//  706                                  INT8U    prio)
//  707 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R8
        MOV.B   R13, R10
//  708     INT8U  y;
//  709 
//  710 
//  711     y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
        MOV.B   0x32(R8), R11
//  712     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
        MOV.B   R11, R15
        BICX.B  0x33(R8), OSRdyTbl(R15)
//  713     if (OSRdyTbl[y] == 0u) {
        MOV.B   R11, R15
        CMPX.B  #0x0, OSRdyTbl(R15)
        JNE     ??OSMutex_RdyAtPrio_0
//  714         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
        BICX.B  0x34(R8), &OSRdyGrp
//  715     }
//  716     ptcb->OSTCBPrio         = prio;
??OSMutex_RdyAtPrio_0:
        MOV.B   R10, 0x30(R8)
//  717     OSPrioCur               = prio;                        /* The current task is now at this priority */
        MOVX.B  R10, &OSPrioCur
//  718 #if OS_LOWEST_PRIO <= 63u
//  719     ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
        MOV.B   R10, R14
        RPT     #0x3
        RRUX.B  R14
        AND.B   #0x7, R14
        MOV.B   R14, 0x32(R8)
//  720     ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
        MOV.B   R10, R14
        AND.B   #0x7, R14
        MOV.B   R14, 0x31(R8)
//  721 #else
//  722     ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
//  723     ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
//  724 #endif
//  725     ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
        MOV.B   0x32(R8), R12
        CALLA   #?OneBitMask32
        MOV.B   R12, 0x34(R8)
//  726     ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
        MOV.B   0x31(R8), R12
        CALLA   #?OneBitMask32
        MOV.B   R12, 0x33(R8)
//  727     OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
        BISX.B  0x34(R8), &OSRdyGrp
//  728     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        MOV.B   0x32(R8), R15
        MOV.B   R15, R15
        BISX.B  0x33(R8), OSRdyTbl(R15)
//  729     OSTCBPrioTbl[prio]      = ptcb;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  R8, OSTCBPrioTbl(R15)
//  730 
//  731 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  732 
//  733 
//  734 #endif                                                     /* OS_MUTEX_EN                              */
//  735 	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
// 
// 1 552 bytes in segment CODE
// 
// 1 552 bytes of CODE memory
//
//Errors: none
//Warnings: 11
