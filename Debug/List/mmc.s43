///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:57 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\ /
//                     mmc.c                                                  /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\ /
//                     mmc.c -D DEBUG -D RAM_VECTOR -lA                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug /
//                     \Obj\ --no_cse --no_unroll --no_inline                 /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \mmc.s43                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME mmc

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?ShiftLeft32_10
        EXTERN ?ShiftLeft32
        EXTERN ?ShiftLeft32_9
        EXTERN ?Mul32
        EXTERN ?cstart_init_copy20
        EXTERN ?cstart_init_zero20
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC INS
        FUNCTION deselect,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC detectCard
        FUNCTION detectCard,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC disk_initialize
        FUNCTION disk_initialize,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 32, STACK
        PUBLIC disk_ioctl
        FUNCTION disk_ioctl,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 44, STACK
        PUBLIC disk_read
        FUNCTION disk_read,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC disk_status
        FUNCTION disk_status,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC disk_write
        FUNCTION disk_write,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC get_fattime
        FUNCTION get_fattime,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rcvr_datablock,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 22, STACK
        FUNCTION rcvr_mmc,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION select,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION send_cmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC validateCSD
        FUNCTION validateCSD,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 44, STACK
        FUNCTION wait_ready,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 10, STACK
        FUNCTION xmit_datablock,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        FUNCTION xmit_mmc,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN SDCard_readFrame
        FUNCTION SDCard_readFrame,0202H
        EXTERN SDCard_setCSHigh
        FUNCTION SDCard_setCSHigh,0202H
        EXTERN SDCard_sendFrame
        FUNCTION SDCard_sendFrame,0202H
        EXTERN SDCard_setCSLow
        FUNCTION SDCard_setCSLow,0202H
        EXTERN SDCard_init
        FUNCTION SDCard_init,0202H
        EXTERN SDCard_fastMode
        FUNCTION SDCard_fastMode,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\mmc.c
//    1 /*------------------------------------------------------------------------/
//    2 /  Bitbanging MMCv3/SDv1/SDv2 (in SPI mode) control module
//    3 /-------------------------------------------------------------------------/
//    4 /
//    5 /  Copyright (C) 2010, ChaN, all right reserved.
//    6 /
//    7 / * This software is a free software and there is NO WARRANTY.
//    8 / * No restriction on use. You can use, modify and redistribute it for
//    9 /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
//   10 / * Redistributions of source code must retain the above copyright notice.
//   11 /
//   12 ---------------------------------------------------------------------------*/
//   13 
//   14 #include <intrinsics.h>         /* Include MSP430-specific intrincs */
//   15 #include "diskio.h"             /* Common include file for FatFs and disk I/O layer */
//   16 #include "HAL_SDCard.h"         /* MSP-EXP430F5529 specific SD Card driver */
//   17 
//   18 /*-------------------------------------------------------------------------*/
//   19 /* Platform dependent macros and functions needed to be modified           */
//   20 /*-------------------------------------------------------------------------*/
//   21 
//   22 // CPU Frequency.
//   23 #define MCLK_FREQ   25000000
//   24 #define	INIT_PORT()     SDCard_init()       /* Initialize MMC control port */
//   25 #define FAST_MODE()     SDCard_fastMode()   /* Maximize SD Card transfer speed */
//   26 #define DLY_US(n)       __delay_cycles(n * (MCLK_FREQ/1000000))  // Delay n microseconds           // KLQ
//   27 
//   28 #define	CS_H()          SDCard_setCSHigh()  /* Set MMC CS "high" */
//   29 #define CS_L()          SDCard_setCSLow()   /* Set MMC CS "low" */
//   30 

        RSEG DATA20_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy20
//   31 BYTE INS = 1;    // KLQ
INS:
        DS8 1
        REQUIRE `?<Initializer for INS>`
//   32 #define	WP              (0)                 /* Card is write protected (yes:true, no:false, default:false) */
//   33 
//   34 /*-------------------------------------------------------------------------*/
//   35 /* Platform dependent RTC Function for FatFs module                        */
//   36 /*-------------------------------------------------------------------------*/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   37 DWORD get_fattime(void)
get_fattime:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function get_fattime
//   38 {
//   39 	DWORD tmr;
//   40 
//   41     // TODO: Customize to use the MSP430 RTC
//   42 
//   43 	/* Pack date and time into a DWORD variable */
//   44 	tmr =	  (((DWORD)2001 - 80) << 25)    // rtcYear
//   45 			| ((DWORD)9 << 21)              // rtcMon
//   46 			| ((DWORD)11 << 16)             // rtcMday
//   47 			| (WORD)(4 << 11)               // rtcHour
//   48 			| (WORD)(30 << 5)               // rtcMin
//   49 			| (WORD)(0 >> 1);               // rtcSec
        MOV.W   #0x23c0, R12
        MOV.W   #0x32b, R13
//   50 
//   51 	return tmr;
        RETA
          CFI EndBlock cfiBlock0
//   52 }
//   53 
//   54 /*--------------------------------------------------------------------------
//   55    Module Private Functions
//   56 ---------------------------------------------------------------------------*/
//   57 
//   58 /* MMC/SD command (SPI mode) */
//   59 #define CMD0	(0)			/* GO_IDLE_STATE */
//   60 #define CMD1	(1)			/* SEND_OP_COND */
//   61 #define	ACMD41	(0x80+41)	/* SEND_OP_COND (SDC) */
//   62 #define CMD8	(8)			/* SEND_IF_COND */
//   63 #define CMD9	(9)			/* SEND_CSD */
//   64 #define CMD10	(10)		/* SEND_CID */
//   65 #define CMD12	(12)		/* STOP_TRANSMISSION */
//   66 #define ACMD13	(0x80+13)	/* SD_STATUS (SDC) */
//   67 #define CMD16	(16)		/* SET_BLOCKLEN */
//   68 #define CMD17	(17)		/* READ_SINGLE_BLOCK */
//   69 #define CMD18	(18)		/* READ_MULTIPLE_BLOCK */
//   70 #define CMD23	(23)		/* SET_BLOCK_COUNT */
//   71 #define	ACMD23	(0x80+23)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
//   72 #define CMD24	(24)		/* WRITE_BLOCK */
//   73 #define CMD25	(25)		/* WRITE_MULTIPLE_BLOCK */
//   74 #define CMD41	(41)		/* SEND_OP_COND (ACMD) */
//   75 #define CMD55	(55)		/* APP_CMD */
//   76 #define CMD58	(58)		/* READ_OCR */
//   77 
//   78 /* Card type flags (CardType) */
//   79 #define CT_MMC		0x01		/* MMC ver 3 */
//   80 #define CT_SD1		0x02		/* SD ver 1 */
//   81 #define CT_SD2		0x04		/* SD ver 2 */
//   82 #define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
//   83 #define CT_BLOCK	0x08		/* Block addressing */
//   84 
//   85 
//   86 static

        RSEG DATA20_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy20
//   87 DSTATUS Stat = STA_NOINIT;	/* Disk status */
Stat:
        DS8 1
        REQUIRE `?<Initializer for Stat>`
//   88 
//   89 static

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   90 BYTE CardType;			/* b0:MMC, b1:SDv1, b2:SDv2, b3:Block addressing */
CardType:
        DS8 1
//   91 
//   92 
//   93 
//   94 /*-----------------------------------------------------------------------*/
//   95 /* Transmit bytes to the MMC                                             */
//   96 /*-----------------------------------------------------------------------*/
//   97 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   98 static
//   99 void xmit_mmc (
xmit_mmc:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function xmit_mmc
//  100 	const BYTE* buff,               /* Data to be sent */
//  101 	UINT bc                         /* Number of bytes to send */
//  102 )
//  103 {
        FUNCALL xmit_mmc, SDCard_sendFrame
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOVA    R12, R10
        MOV.W   R13, R11
//  104     SDCard_sendFrame((uint8_t *)buff, bc);
        MOV.W   R11, R13
        MOVA    R10, R12
        CALLA   #SDCard_sendFrame
//  105 }
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  106 
//  107 /*-----------------------------------------------------------------------*/
//  108 /* Receive bytes from the MMC                                            */
//  109 /*-----------------------------------------------------------------------*/
//  110 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  111 static
//  112 void rcvr_mmc (
rcvr_mmc:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function rcvr_mmc
//  113 	BYTE *buff,	/* Pointer to read buffer */
//  114 	UINT bc		/* Number of bytes to receive */
//  115 )
//  116 {
        FUNCALL rcvr_mmc, SDCard_readFrame
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOVA    R12, R10
        MOV.W   R13, R11
//  117 
//  118     SDCard_readFrame(buff, bc);
        MOV.W   R11, R13
        MOVA    R10, R12
        CALLA   #SDCard_readFrame
//  119 }
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  120 
//  121 
//  122 /*-----------------------------------------------------------------------*/
//  123 /* Wait for card ready                                                   */
//  124 /*-----------------------------------------------------------------------*/
//  125 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  126 static
//  127 int wait_ready (void)    /* 1:OK, 0:Timeout */
wait_ready:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function wait_ready
//  128 {
        FUNCALL wait_ready, rcvr_mmc
        LOCFRAME CSTACK, 10, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x2, SP
          CFI CFA SP+10
//  129     BYTE d;
//  130     UINT tmr;
//  131 
//  132 
//  133     for (tmr = 5000; tmr; tmr--) {    /* Wait for ready in timeout of 500ms */
        MOV.W   #0x1388, R10
??wait_ready_0:
        CMP.W   #0x0, R10
        JEQ     ??wait_ready_1
//  134         rcvr_mmc(&d, 1);
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  135         if (d == 0xFF) return 1;
        CMP.B   #0xff, 0(SP)
        JNE     ??wait_ready_2
        MOV.W   #0x1, R12
        JMP     ??wait_ready_3
//  136         DLY_US(100);
??wait_ready_2:
        ////////////// Start of 2500 cycles delay.
        JMP     ??wait_ready_5
??wait_ready_5:
        MOV.W   #0x33f, R15
??wait_ready_4:
        ADD.W   #0xffff, R15
        JC      ??wait_ready_4
        ////////////// End of delay code.
//  137     }
        ADD.W   #0xffff, R10
        JMP     ??wait_ready_0
//  138 
//  139     return 0;
??wait_ready_1:
        MOV.W   #0x0, R12
??wait_ready_3:
        ADD.W   #0x2, SP
          CFI CFA SP+8
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  140 }
//  141 
//  142 
//  143 
//  144 /*-----------------------------------------------------------------------*/
//  145 /* Deselect the card and release SPI bus                                 */
//  146 /*-----------------------------------------------------------------------*/
//  147 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  148 static
//  149 void deselect (void)
deselect:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function deselect
//  150 {
        FUNCALL deselect, SDCard_setCSHigh
        LOCFRAME CSTACK, 6, STACK
        FUNCALL deselect, rcvr_mmc
        LOCFRAME CSTACK, 6, STACK
        SUB.W   #0x2, SP
          CFI CFA SP+6
//  151     BYTE d;
//  152 
//  153     CS_H();
        CALLA   #SDCard_setCSHigh
//  154     rcvr_mmc(&d, 1);
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  155 }
        ADD.W   #0x2, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  156 
//  157 
//  158 
//  159 /*-----------------------------------------------------------------------*/
//  160 /* Select the card and wait for ready                                    */
//  161 /*-----------------------------------------------------------------------*/
//  162 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  163 static
//  164 int select (void)    /* 1:OK, 0:Timeout */
select:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function select
//  165 {
//  166     CS_L();
        FUNCALL select, SDCard_setCSLow
        LOCFRAME CSTACK, 4, STACK
        FUNCALL select, wait_ready
        LOCFRAME CSTACK, 4, STACK
        FUNCALL select, deselect
        LOCFRAME CSTACK, 4, STACK
        CALLA   #SDCard_setCSLow
//  167     if (!wait_ready()) {
        CALLA   #wait_ready
        CMP.W   #0x0, R12
        JNE     ??select_0
//  168         deselect();
        CALLA   #deselect
//  169         return 0;
        MOV.W   #0x0, R12
        RETA
//  170     }
//  171     return 1;
??select_0:
        MOV.W   #0x1, R12
        RETA
          CFI EndBlock cfiBlock5
//  172 }
//  173 
//  174 
//  175 
//  176 /*-----------------------------------------------------------------------*/
//  177 /* Receive a data packet from MMC                                        */
//  178 /*-----------------------------------------------------------------------*/
//  179 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  180 static
//  181 int rcvr_datablock (    /* 1:OK, 0:Failed */
rcvr_datablock:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function rcvr_datablock
//  182     BYTE *buff,            /* Data buffer to store received data */
//  183     UINT btr            /* Byte count */
//  184 )
//  185 {
        FUNCALL rcvr_datablock, rcvr_mmc
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rcvr_datablock, rcvr_mmc
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rcvr_datablock, rcvr_mmc
        LOCFRAME CSTACK, 22, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x2, SP
          CFI CFA SP+22
        MOVA    R12, R10
        MOV.W   R13, R11
//  186     BYTE d[2];
//  187     UINT tmr;
//  188 
//  189 
//  190     for (tmr = 1000; tmr; tmr--) {    /* Wait for data packet in timeout of 100ms */
        MOV.W   #0x3e8, R8
??rcvr_datablock_0:
        CMP.W   #0x0, R8
        JEQ     ??rcvr_datablock_2
//  191         rcvr_mmc(d, 1);
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  192         if (d[0] != 0xFF) break;
        CMP.B   #0xff, 0(SP)
        JNE     ??rcvr_datablock_2
//  193         DLY_US(100);
        ////////////// Start of 2500 cycles delay.
        JMP     ??rcvr_datablock_6
??rcvr_datablock_6:
        MOV.W   #0x33f, R15
??rcvr_datablock_5:
        ADD.W   #0xffff, R15
        JC      ??rcvr_datablock_5
        ////////////// End of delay code.
//  194     }
        ADD.W   #0xffff, R8
        JMP     ??rcvr_datablock_0
//  195     if (d[0] != 0xFE) return 0;        /* If not valid data token, retutn with error */
??rcvr_datablock_2:
        CMP.B   #0xfe, 0(SP)
        JEQ     ??rcvr_datablock_3
        MOV.W   #0x0, R12
        JMP     ??rcvr_datablock_4
//  196 
//  197     rcvr_mmc(buff, btr);            /* Receive the data block into buffer */
??rcvr_datablock_3:
        MOV.W   R11, R13
        MOVA    R10, R12
        CALLA   #rcvr_mmc
//  198     rcvr_mmc(d, 2);                    /* Discard CRC */
        MOV.W   #0x2, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  199 
//  200     return 1;                        /* Return with success */
        MOV.W   #0x1, R12
??rcvr_datablock_4:
        ADD.W   #0x2, SP
          CFI CFA SP+20
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  201 }
//  202 
//  203 
//  204 
//  205 /*-----------------------------------------------------------------------*/
//  206 /* Send a data packet to MMC                                             */
//  207 /*-----------------------------------------------------------------------*/
//  208 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  209 static
//  210 int xmit_datablock (    /* 1:OK, 0:Failed */
xmit_datablock:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function xmit_datablock
//  211     const BYTE *buff,    /* 512 byte data block to be transmitted */
//  212     BYTE token            /* Data/Stop token */
//  213 )
//  214 {
        FUNCALL xmit_datablock, wait_ready
        LOCFRAME CSTACK, 14, STACK
        FUNCALL xmit_datablock, xmit_mmc
        LOCFRAME CSTACK, 14, STACK
        FUNCALL xmit_datablock, xmit_mmc
        LOCFRAME CSTACK, 14, STACK
        FUNCALL xmit_datablock, rcvr_mmc
        LOCFRAME CSTACK, 14, STACK
        FUNCALL xmit_datablock, rcvr_mmc
        LOCFRAME CSTACK, 14, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x2, SP
          CFI CFA SP+14
        MOVA    R12, R11
        MOV.B   R13, R10
//  215     BYTE d[2];
//  216 
//  217 
//  218     if (!wait_ready()) return 0;
        CALLA   #wait_ready
        CMP.W   #0x0, R12
        JNE     ??xmit_datablock_0
        MOV.W   #0x0, R12
        JMP     ??xmit_datablock_1
//  219 
//  220     d[0] = token;
??xmit_datablock_0:
        MOV.B   R10, 0(SP)
//  221     xmit_mmc(d, 1);                /* Xmit a token */
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #xmit_mmc
//  222     if (token != 0xFD) {        /* Is it data token? */
        CMP.B   #0xfd, R10
        JEQ     ??xmit_datablock_2
//  223         xmit_mmc(buff, 512);    /* Xmit the 512 byte data block to MMC */
        MOV.W   #0x200, R13
        MOVA    R11, R12
        CALLA   #xmit_mmc
//  224         rcvr_mmc(d, 2);            /* Dummy CRC (FF,FF) */
        MOV.W   #0x2, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  225         rcvr_mmc(d, 1);            /* Receive data response */
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  226         if ((d[0] & 0x1F) != 0x05)    /* If not accepted, return with error */
        MOV.B   @SP, R14
        AND.B   #0x1f, R14
        CMP.B   #0x5, R14
        JEQ     ??xmit_datablock_2
//  227             return 0;
        MOV.W   #0x0, R12
        JMP     ??xmit_datablock_1
//  228     }
//  229 
//  230     return 1;
??xmit_datablock_2:
        MOV.W   #0x1, R12
??xmit_datablock_1:
        ADD.W   #0x2, SP
          CFI CFA SP+12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  231 }
//  232 
//  233 
//  234 
//  235 /*-----------------------------------------------------------------------*/
//  236 /* Send a command packet to MMC                                          */
//  237 /*-----------------------------------------------------------------------*/
//  238 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  239 static
//  240 BYTE send_cmd (        /* Returns command response (bit7==1:Send failed)*/
send_cmd:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function send_cmd
//  241     BYTE cmd,        /* Command byte */
//  242     DWORD arg        /* Argument */
//  243 )
//  244 {
        FUNCALL send_cmd, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL send_cmd, deselect
        LOCFRAME CSTACK, 28, STACK
        FUNCALL send_cmd, select
        LOCFRAME CSTACK, 28, STACK
        FUNCALL send_cmd, xmit_mmc
        LOCFRAME CSTACK, 28, STACK
        FUNCALL send_cmd, rcvr_mmc
        LOCFRAME CSTACK, 28, STACK
        FUNCALL send_cmd, rcvr_mmc
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x8, SP
          CFI CFA SP+28
        MOV.B   R12, R9
        MOV.W   R14, R10
        MOV.W   R15, R11
//  245     BYTE n, d, buf[6];
//  246 
//  247 
//  248     if (cmd & 0x80) {    /* ACMD<n> is the command sequense of CMD55-CMD<n> */
        CMP.B   #0x0, R9
        JGE     ??send_cmd_1
//  249         cmd &= 0x7F;
        BIC.B   #0x80, R9
//  250         n = send_cmd(CMD55, 0);
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x37, R12
        CALLA   #send_cmd
        MOV.B   R12, R8
//  251         if (n > 1) return n;
        CMP.B   #0x2, R8
        JNC     ??send_cmd_1
        MOV.B   R8, R12
        JMP     ??send_cmd_2
//  252     }
//  253 
//  254     /* Select the card and wait for ready */
//  255     deselect();
??send_cmd_1:
        CALLA   #deselect
//  256     if (!select()) return 0xFF;
        CALLA   #select
        CMP.W   #0x0, R12
        JNE     ??send_cmd_3
        MOV.B   #0xff, R12
        JMP     ??send_cmd_2
//  257 
//  258     /* Send a command packet */
//  259     buf[0] = 0x40 | cmd;            /* Start + Command index */
??send_cmd_3:
        MOV.B   R9, R14
        BIS.B   #0x40, R14
        MOV.B   R14, 0x1(SP)
//  260     buf[1] = (BYTE)(arg >> 24);        /* Argument[31..24] */
        MOV.W   R10, R14
        MOV.W   R11, R15
        SWPB    R15
        MOV.B   R15, R14
        MOV.W   #0x0, R15
        MOV.B   R14, 0x2(SP)
//  261     buf[2] = (BYTE)(arg >> 16);        /* Argument[23..16] */
        MOV.B   R11, 0x3(SP)
//  262     buf[3] = (BYTE)(arg >> 8);        /* Argument[15..8] */
        MOV.W   R10, R15
        SWPB    R15
        AND.W   #0xff, R15
        MOV.B   R15, 0x4(SP)
//  263     buf[4] = (BYTE)arg;                /* Argument[7..0] */
        MOV.B   R10, 0x5(SP)
//  264     n = 0x01;                        /* Dummy CRC + Stop */
        MOV.B   #0x1, R8
//  265     if (cmd == CMD0) n = 0x95;        /* (valid CRC for CMD0(0)) */
        CMP.B   #0x0, R9
        JNE     ??send_cmd_4
        MOV.B   #0x95, R8
//  266     if (cmd == CMD8) n = 0x87;        /* (valid CRC for CMD8(0x1AA)) */
??send_cmd_4:
        CMP.B   #0x8, R9
        JNE     ??send_cmd_5
        MOV.B   #0x87, R8
//  267     buf[5] = n;
??send_cmd_5:
        MOV.B   R8, 0x6(SP)
//  268     xmit_mmc(buf, 6);
        MOV.W   #0x6, R13
        MOV.W   SP, R12
        ADD.W   #0x1, R12
        CALLA   #xmit_mmc
//  269 
//  270     /* Receive command response */
//  271     if (cmd == CMD12) rcvr_mmc(&d, 1);    /* Skip a stuff byte when stop reading */
        CMP.B   #0xc, R9
        JNE     ??send_cmd_6
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  272     n = 10;                                /* Wait for a valid response in timeout of 10 attempts */
??send_cmd_6:
        MOV.B   #0xa, R8
//  273     do
//  274         rcvr_mmc(&d, 1);
??send_cmd_0:
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  275     while ((d & 0x80) && --n);
        CMP.B   #0x0, 0(SP)
        JGE     ??send_cmd_7
        ADD.B   #0xff, R8
        CMP.B   #0x0, R8
        JNE     ??send_cmd_0
//  276 
//  277     return d;            /* Return with the response value */
??send_cmd_7:
        MOV.B   @SP, R12
??send_cmd_2:
        ADD.W   #0x8, SP
          CFI CFA SP+20
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  278 }
//  279 
//  280 
//  281 
//  282 /*--------------------------------------------------------------------------
//  283 
//  284    Public Functions
//  285 
//  286 ---------------------------------------------------------------------------*/
//  287 
//  288 
//  289 /*-----------------------------------------------------------------------*/
//  290 /* Get Disk Status                                                       */
//  291 /*-----------------------------------------------------------------------*/
//  292 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  293 DSTATUS disk_status (
disk_status:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function disk_status
//  294     BYTE drv            /* Drive number (0) */
//  295 )
//  296 {
        MOV.B   R12, R14
//  297     DSTATUS s = Stat;
        MOVX.B  &Stat, R12
//  298 
//  299 
//  300     if (drv || !INS) {
        CMP.B   #0x0, R14
        JNE     ??disk_status_0
        CMPX.B  #0x0, &INS
        JNE     ??disk_status_1
//  301         s = STA_NODISK | STA_NOINIT;
??disk_status_0:
        MOV.B   #0x3, R12
        JMP     ??disk_status_2
//  302     } else {
//  303         s &= ~STA_NODISK;
??disk_status_1:
        BIC.B   #0x2, R12
//  304         if (WP)
//  305             s |= STA_PROTECT;
//  306         else
//  307             s &= ~STA_PROTECT;
        BIC.B   #0x4, R12
//  308     }
//  309     Stat = s;
??disk_status_2:
        MOVX.B  R12, &Stat
//  310 
//  311     return s;
        RETA
          CFI EndBlock cfiBlock9
//  312 }
//  313 
//  314 
//  315 
//  316 /*-----------------------------------------------------------------------*/
//  317 /* Initialize Disk Drive                                                 */
//  318 /*-----------------------------------------------------------------------*/
//  319 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  320 DSTATUS disk_initialize (
disk_initialize:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function disk_initialize
//  321 	BYTE drv		/* Physical drive nmuber (0) */
//  322 )
//  323 {
        FUNCALL disk_initialize, SDCard_init
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, disk_status
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, SDCard_setCSHigh
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, rcvr_mmc
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, rcvr_mmc
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, rcvr_mmc
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, send_cmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, deselect
        LOCFRAME CSTACK, 32, STACK
        FUNCALL disk_initialize, SDCard_fastMode
        LOCFRAME CSTACK, 32, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        SUB.W   #0x4, SP
          CFI CFA SP+32
        MOV.B   R12, R7
//  324 /* TI: Inserted pragma to supress IAR compiler warning incicating 'cmd'
//  325  * is not used. If removed however the compile fails */
//  326 #ifdef __IAR_SYSTEMS_ICC__
//  327 #pragma diag_suppress=Pe550
//  328 #endif
//  329 #ifdef __TI_COMPILER_VERSION__
//  330 #pragma diag_suppress 552
//  331 #endif
//  332 	BYTE n, ty, cmd, buf[4];
//  333 #ifdef __IAR_SYSTEMS_ICC__
//  334 #pragma diag_default=Pe550
//  335 #endif
//  336 //#ifdef __TI_COMPILER_VERSION__
//  337 //#pragma diag_default 552
//  338 //#endif
//  339     UINT tmr;
//  340     DSTATUS s;
//  341 
//  342 
//  343     INIT_PORT();                /* Initialize control port */
        CALLA   #SDCard_init
//  344 
//  345     DLY_US(100);
        ////////////// Start of 2500 cycles delay.
        JMP     ??disk_initialize_22
??disk_initialize_22:
        MOV.W   #0x33f, R15
??disk_initialize_19:
        ADD.W   #0xffff, R15
        JC      ??disk_initialize_19
        ////////////// End of delay code.
//  346 
//  347     s = disk_status(drv);        /* Check if card is in the socket */
        MOV.B   R7, R12
        CALLA   #disk_status
        MOV.B   R12, R9
//  348     if (s & STA_NODISK) return s;
        BIT.B   #0x2, R9
        JNC     ??disk_initialize_9
        MOV.B   R9, R12
        JMP     ??disk_initialize_10
//  349 
//  350     CS_H();
??disk_initialize_9:
        CALLA   #SDCard_setCSHigh
//  351     for (n = 10; n; n--) rcvr_mmc(buf, 1);    /* 80 dummy clocks */
        MOV.B   #0xa, R10
??disk_initialize_0:
        CMP.B   #0x0, R10
        JEQ     ??disk_initialize_11
        MOV.W   #0x1, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
        ADD.B   #0xff, R10
        JMP     ??disk_initialize_0
//  352 
//  353     ty = 0;
??disk_initialize_11:
        MOV.B   #0x0, R11
//  354     if (send_cmd(CMD0, 0) == 1) {            /* Enter Idle state */
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x0, R12
        CALLA   #send_cmd
        CMP.B   #0x1, R12
        JNE     ??disk_initialize_6
//  355         if (send_cmd(CMD8, 0x1AA) == 1) {    /* SDv2? */
        MOV.W   #0x1aa, R14
        MOV.W   #0x0, R15
        MOV.B   #0x8, R12
        CALLA   #send_cmd
        CMP.B   #0x1, R12
        JNE     ??disk_initialize_12
//  356             rcvr_mmc(buf, 4);                            /* Get trailing return value of R7 resp */
        MOV.W   #0x4, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  357             if (buf[2] == 0x01 && buf[3] == 0xAA) {        /* The card can work at vdd range of 2.7-3.6V */
        CMP.B   #0x1, 0x2(SP)
        JNE     ??disk_initialize_6
        CMP.B   #0xaa, 0x3(SP)
        JNE     ??disk_initialize_6
//  358                 for (tmr = 1000; tmr; tmr--) {            /* Wait for leaving idle state (ACMD41 with HCS bit) */
        MOV.W   #0x3e8, R8
??disk_initialize_1:
        CMP.W   #0x0, R8
        JEQ     ??disk_initialize_4
//  359                     if (send_cmd(ACMD41, 1UL << 30) == 0) break;
        MOV.W   #0x0, R14
        MOV.W   #0x4000, R15
        MOV.B   #0xa9, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JEQ     ??disk_initialize_4
//  360                     DLY_US(1000);
        ////////////// Start of 25000 cycles delay.
        JMP     ??disk_initialize_23
??disk_initialize_23:
        MOV.W   #0x208b, R15
??disk_initialize_20:
        ADD.W   #0xffff, R15
        JC      ??disk_initialize_20
        ////////////// End of delay code.
//  361                 }
        ADD.W   #0xffff, R8
        JMP     ??disk_initialize_1
//  362                 if (tmr && send_cmd(CMD58, 0) == 0) {    /* Check CCS bit in the OCR */
??disk_initialize_4:
        CMP.W   #0x0, R8
        JEQ     ??disk_initialize_6
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x3a, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_initialize_6
//  363                     rcvr_mmc(buf, 4);
        MOV.W   #0x4, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_mmc
//  364                     ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;    /* SDv2 */
        BIT.B   #0x40, 0(SP)
        JNC     ??disk_initialize_13
        MOV.B   #0xc, R11
        JMP     ??disk_initialize_6
??disk_initialize_13:
        MOV.B   #0x4, R11
        JMP     ??disk_initialize_6
//  365                 }
//  366             }
//  367         } else {                            /* SDv1 or MMCv3 */
//  368             if (send_cmd(ACMD41, 0) <= 1)     {
??disk_initialize_12:
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0xa9, R12
        CALLA   #send_cmd
        CMP.B   #0x2, R12
        JC      ??disk_initialize_14
//  369                 ty = CT_SD1; cmd = ACMD41;    /* SDv1 */
        MOV.B   #0x2, R11
        MOV.B   #0xa9, R6
        JMP     ??disk_initialize_15
//  370             } else {
//  371                 ty = CT_MMC; cmd = CMD1;    /* MMCv3 */
??disk_initialize_14:
        MOV.B   #0x1, R11
        MOV.B   #0x1, R6
//  372             }
//  373             for (tmr = 1000; tmr; tmr--) {            /* Wait for leaving idle state */
??disk_initialize_15:
        MOV.W   #0x3e8, R8
??disk_initialize_2:
        CMP.W   #0x0, R8
        JEQ     ??disk_initialize_8
//  374                 if (send_cmd(ACMD41, 0) == 0) break;
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0xa9, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JEQ     ??disk_initialize_8
//  375                 DLY_US(1000);
        ////////////// Start of 25000 cycles delay.
        JMP     ??disk_initialize_24
??disk_initialize_24:
        MOV.W   #0x208b, R15
??disk_initialize_21:
        ADD.W   #0xffff, R15
        JC      ??disk_initialize_21
        ////////////// End of delay code.
//  376             }
        ADD.W   #0xffff, R8
        JMP     ??disk_initialize_2
//  377             if (!tmr || send_cmd(CMD16, 512) != 0)    /* Set R/W block length to 512 */
??disk_initialize_8:
        CMP.W   #0x0, R8
        JEQ     ??disk_initialize_16
        MOV.W   #0x200, R14
        MOV.W   #0x0, R15
        MOV.B   #0x10, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JEQ     ??disk_initialize_6
//  378                 ty = 0;
??disk_initialize_16:
        MOV.B   #0x0, R11
//  379         }
//  380     }
//  381     CardType = ty;
??disk_initialize_6:
        MOVX.B  R11, &CardType
//  382     deselect();
        CALLA   #deselect
//  383 
//  384     if (ty) {      /* Initialization succeded */
        CMP.B   #0x0, R11
        JEQ     ??disk_initialize_17
//  385         FAST_MODE();
        CALLA   #SDCard_fastMode
//  386         s &= ~STA_NOINIT;
        BIC.B   #0x1, R9
        JMP     ??disk_initialize_18
//  387     }
//  388     else {       /* Initialization failed */
//  389         s |= STA_NOINIT;
??disk_initialize_17:
        BIS.B   #0x1, R9
//  390     }
//  391     Stat = s;
??disk_initialize_18:
        MOVX.B  R9, &Stat
//  392 
//  393 
//  394     return s;
        MOV.B   R9, R12
??disk_initialize_10:
        ADD.W   #0x4, SP
          CFI CFA SP+28
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  395 }
//  396 
//  397 
//  398 
//  399 /*-----------------------------------------------------------------------*/
//  400 /* Read Sector(s)                                                        */
//  401 /*-----------------------------------------------------------------------*/
//  402 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  403 DRESULT disk_read (
disk_read:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function disk_read
//  404     BYTE drv,            /* Physical drive nmuber (0) */
//  405     BYTE *buff,            /* Pointer to the data buffer to store read data */
//  406     DWORD sector,        /* Start sector number (LBA) */
//  407     BYTE count            /* Sector count (1..128) */
//  408 )
//  409 {
        FUNCALL disk_read, disk_status
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, rcvr_datablock
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, rcvr_datablock
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_read, deselect
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R7
        MOVA    R13, R9
        MOV.W   R14, R10
        MOV.W   R15, R11
        MOV.B   0x1c(SP), R8
//  410     DSTATUS s;
//  411 
//  412 
//  413     s = disk_status(drv);
        MOV.B   R7, R12
        CALLA   #disk_status
        MOV.B   R12, R6
//  414     if (s & STA_NOINIT) return RES_NOTRDY;
        BIT.B   #0x1, R6
        JNC     ??disk_read_4
        MOV.B   #0x3, R12
        JMP     ??disk_read_1
//  415     if (!count) return RES_PARERR;
??disk_read_4:
        CMP.B   #0x0, R8
        JNE     ??disk_read_5
        MOV.B   #0x4, R12
        JMP     ??disk_read_1
//  416     if (!(CardType & CT_BLOCK)) sector *= 512;    /* Convert LBA to byte address if needed */
??disk_read_5:
        BITX.B  #0x8, &CardType
        JC      ??disk_read_6
        MOV.W   R10, R12
        MOV.W   R11, R13
        MOV.W   #0x200, R14
        MOV.W   #0x0, R15
        CALLA   #?Mul32
        MOV.W   R12, R10
        MOV.W   R13, R11
//  417 
//  418     if (count == 1) {    /* Single block read */
??disk_read_6:
        CMP.B   #0x1, R8
        JNE     ??disk_read_7
//  419         if ((send_cmd(CMD17, sector) == 0)    /* READ_SINGLE_BLOCK */
//  420             && rcvr_datablock(buff, 512))
        MOV.W   R10, R14
        MOV.W   R11, R15
        MOV.B   #0x11, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_read_8
        MOV.W   #0x200, R13
        MOVA    R9, R12
        CALLA   #rcvr_datablock
        CMP.W   #0x0, R12
        JEQ     ??disk_read_8
//  421             count = 0;
        MOV.B   #0x0, R8
        JMP     ??disk_read_8
//  422     }
//  423     else {                /* Multiple block read */
//  424         if (send_cmd(CMD18, sector) == 0) {    /* READ_MULTIPLE_BLOCK */
??disk_read_7:
        MOV.W   R10, R14
        MOV.W   R11, R15
        MOV.B   #0x12, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_read_8
//  425             do {
//  426                 if (!rcvr_datablock(buff, 512)) break;
??disk_read_0:
        MOV.W   #0x200, R13
        MOVA    R9, R12
        CALLA   #rcvr_datablock
        CMP.W   #0x0, R12
        JEQ     ??disk_read_3
//  427                 buff += 512;
        ADDA    #0x200, R9
//  428             } while (--count);
        ADD.B   #0xff, R8
        CMP.B   #0x0, R8
        JNE     ??disk_read_0
//  429             send_cmd(CMD12, 0);                /* STOP_TRANSMISSION */
??disk_read_3:
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0xc, R12
        CALLA   #send_cmd
//  430         }
//  431     }
//  432     deselect();
??disk_read_8:
        CALLA   #deselect
//  433 
//  434     return count ? RES_ERROR : RES_OK;
        CMP.B   #0x0, R8
        JEQ     ??disk_read_9
        MOV.B   #0x1, R12
        JMP     ??disk_read_1
??disk_read_9:
        MOV.B   #0x0, R12
??disk_read_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
//  435 }
//  436 
//  437 
//  438 
//  439 /*-----------------------------------------------------------------------*/
//  440 /* Write Sector(s)                                                       */
//  441 /*-----------------------------------------------------------------------*/
//  442 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  443 DRESULT disk_write (
disk_write:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function disk_write
//  444     BYTE drv,            /* Physical drive nmuber (0) */
//  445     const BYTE *buff,    /* Pointer to the data to be written */
//  446     DWORD sector,        /* Start sector number (LBA) */
//  447     BYTE count            /* Sector count (1..128) */
//  448 )
//  449 {
        FUNCALL disk_write, disk_status
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, xmit_datablock
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, send_cmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, xmit_datablock
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, xmit_datablock
        LOCFRAME CSTACK, 28, STACK
        FUNCALL disk_write, deselect
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.B   R12, R7
        MOVA    R13, R9
        MOV.W   R14, R10
        MOV.W   R15, R11
        MOV.B   0x1c(SP), R8
//  450     DSTATUS s;
//  451 
//  452 
//  453     s = disk_status(drv);
        MOV.B   R7, R12
        CALLA   #disk_status
        MOV.B   R12, R6
//  454     if (s & STA_NOINIT) return RES_NOTRDY;
        BIT.B   #0x1, R6
        JNC     ??disk_write_4
        MOV.B   #0x3, R12
        JMP     ??disk_write_1
//  455     if (s & STA_PROTECT) return RES_WRPRT;
??disk_write_4:
        BIT.B   #0x4, R6
        JNC     ??disk_write_5
        MOV.B   #0x2, R12
        JMP     ??disk_write_1
//  456     if (!count) return RES_PARERR;
??disk_write_5:
        CMP.B   #0x0, R8
        JNE     ??disk_write_6
        MOV.B   #0x4, R12
        JMP     ??disk_write_1
//  457     if (!(CardType & CT_BLOCK)) sector *= 512;    /* Convert LBA to byte address if needed */
??disk_write_6:
        BITX.B  #0x8, &CardType
        JC      ??disk_write_7
        MOV.W   R10, R12
        MOV.W   R11, R13
        MOV.W   #0x200, R14
        MOV.W   #0x0, R15
        CALLA   #?Mul32
        MOV.W   R12, R10
        MOV.W   R13, R11
//  458 
//  459     if (count == 1) {    /* Single block write */
??disk_write_7:
        CMP.B   #0x1, R8
        JNE     ??disk_write_8
//  460         if ((send_cmd(CMD24, sector) == 0)    /* WRITE_BLOCK */
//  461             && xmit_datablock(buff, 0xFE))
        MOV.W   R10, R14
        MOV.W   R11, R15
        MOV.B   #0x18, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_write_9
        MOV.B   #0xfe, R13
        MOVA    R9, R12
        CALLA   #xmit_datablock
        CMP.W   #0x0, R12
        JEQ     ??disk_write_9
//  462             count = 0;
        MOV.B   #0x0, R8
        JMP     ??disk_write_9
//  463     }
//  464     else {                /* Multiple block write */
//  465         if (CardType & CT_SDC) send_cmd(ACMD23, count);
??disk_write_8:
        MOVX.B  &CardType, R14
        BIT.B   #0x6, R14
        JEQ     ??disk_write_10
        MOV.B   R8, R14
        MOV.W   #0x0, R15
        MOV.B   #0x97, R12
        CALLA   #send_cmd
//  466         if (send_cmd(CMD25, sector) == 0) {    /* WRITE_MULTIPLE_BLOCK */
??disk_write_10:
        MOV.W   R10, R14
        MOV.W   R11, R15
        MOV.B   #0x19, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_write_9
//  467             do {
//  468                 if (!xmit_datablock(buff, 0xFC)) break;
??disk_write_0:
        MOV.B   #0xfc, R13
        MOVA    R9, R12
        CALLA   #xmit_datablock
        CMP.W   #0x0, R12
        JEQ     ??disk_write_3
//  469                 buff += 512;
        ADDA    #0x200, R9
//  470             } while (--count);
        ADD.B   #0xff, R8
        CMP.B   #0x0, R8
        JNE     ??disk_write_0
//  471             if (!xmit_datablock(0, 0xFD))    /* STOP_TRAN token */
??disk_write_3:
        MOV.B   #0xfd, R13
        MOVA    #0x0, R12
        CALLA   #xmit_datablock
        CMP.W   #0x0, R12
        JNE     ??disk_write_9
//  472                 count = 1;
        MOV.B   #0x1, R8
//  473         }
//  474     }
//  475     deselect();
??disk_write_9:
        CALLA   #deselect
//  476 
//  477     return count ? RES_ERROR : RES_OK;
        CMP.B   #0x0, R8
        JEQ     ??disk_write_11
        MOV.B   #0x1, R12
        JMP     ??disk_write_1
??disk_write_11:
        MOV.B   #0x0, R12
??disk_write_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock12
//  478 }
//  479 
//  480 
//  481 
//  482 /*-----------------------------------------------------------------------*/
//  483 /* Miscellaneous Functions                                               */
//  484 /*-----------------------------------------------------------------------*/
//  485 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  486 DRESULT disk_ioctl (
disk_ioctl:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function disk_ioctl
//  487     BYTE drv,        /* Physical drive nmuber (0) */
//  488     BYTE ctrl,        /* Control code */
//  489     void *buff        /* Buffer to send/receive control data */
//  490 )
//  491 {
        FUNCALL disk_ioctl, disk_status
        LOCFRAME CSTACK, 44, STACK
        FUNCALL disk_ioctl, select
        LOCFRAME CSTACK, 44, STACK
        FUNCALL disk_ioctl, deselect
        LOCFRAME CSTACK, 44, STACK
        FUNCALL disk_ioctl, send_cmd
        LOCFRAME CSTACK, 44, STACK
        FUNCALL disk_ioctl, rcvr_datablock
        LOCFRAME CSTACK, 44, STACK
        FUNCALL disk_ioctl, deselect
        LOCFRAME CSTACK, 44, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        SUB.W   #0x10, SP
          CFI CFA SP+44
        MOV.B   R12, R7
        MOV.B   R13, R6
        MOVA    R14, R11
//  492     DRESULT res;
//  493     BYTE n, csd[16];
//  494     WORD cs;
//  495 
//  496 
//  497     if (disk_status(drv) & STA_NOINIT)                    /* Check if card is in the socket */
        MOV.B   R7, R12
        CALLA   #disk_status
        BIT.B   #0x1, R12
        JNC     ??disk_ioctl_3
//  498         return RES_NOTRDY;
        MOV.B   #0x3, R12
        JMP     ??disk_ioctl_4
//  499 
//  500     res = RES_ERROR;
??disk_ioctl_3:
        MOV.B   #0x1, R10
//  501     switch (ctrl) {
        MOV.B   R6, R14
        SUB.B   #0x0, R14
        JEQ     ??disk_ioctl_5
        SUB.B   #0x1, R14
        JEQ     ??disk_ioctl_6
        SUB.B   #0x2, R14
        JEQ     ??disk_ioctl_7
        JMP     ??disk_ioctl_8
//  502         case CTRL_SYNC :        /* Make sure that no pending write process */
//  503             if (select()) {
??disk_ioctl_5:
        CALLA   #select
        CMP.W   #0x0, R12
        JEQ     ??disk_ioctl_1
//  504                 deselect();
        CALLA   #deselect
//  505                 res = RES_OK;
        MOV.B   #0x0, R10
//  506             }
//  507             break;
        JMP     ??disk_ioctl_1
//  508 
//  509         case GET_SECTOR_COUNT :    /* Get number of sectors on the disk (DWORD) */
//  510             if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
??disk_ioctl_6:
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x9, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??disk_ioctl_1
        MOV.W   #0x10, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_datablock
        CMP.W   #0x0, R12
        JEQ     ??disk_ioctl_1
//  511                 if ((csd[0] >> 6) == 1) {    /* SDC ver 2.00 */
        MOV.B   @SP, R14
        AND.B   #0xc0, R14
        CMP.B   #0x40, R14
        JNE     ??disk_ioctl_9
//  512                     cs= csd[9] + ((WORD)csd[8] << 8) + 1;
        MOV.B   0x9(SP), R14
        MOV.B   R14, R14
        MOV.B   0x8(SP), R15
        MOV.B   R15, R15
        AND.W   #0xff, R15
        SWPB    R15
        ADD.W   R15, R14
        ADD.W   #0x1, R14
        MOV.W   R14, R8
//  513                     *(DWORD*)buff = (DWORD)cs << 10;
        MOV.W   R8, R12
        MOV.W   #0x0, R13
        CALLA   #?ShiftLeft32_10
        MOV.W   R12, 0(R11)
        MOV.W   R13, 0x2(R11)
        JMP     ??disk_ioctl_10
//  514                 } else {                    /* SDC ver 1.XX or MMC */
//  515                     n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
??disk_ioctl_9:
        MOV.B   0x5(SP), R14
        AND.B   #0xf, R14
        BIT.B   #0x80, 0xa(SP)
        SUBC.B  R15, R15
        ADD.B   #0x1, R15
        ADD.B   R15, R14
        MOV.B   0x9(SP), R15
        AND.B   #0x3, R15
        RLA.B   R15
        ADD.B   R15, R14
        ADD.B   #0x2, R14
        MOV.B   R14, R9
//  516                     cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
        MOV.B   0x8(SP), R14
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        MOV.B   0x7(SP), R15
        MOV.B   R15, R15
        RLAM.W  #0x2, R15
        ADD.W   R15, R14
        MOV.B   0x6(SP), R15
        MOV.B   R15, R15
        AND.W   #0x3, R15
        RPT     #0x2
        RLAX.B  R15
        AND.W   #0xff, R15
        SWPB    R15
        ADD.W   R15, R14
        ADD.W   #0x1, R14
        MOV.W   R14, R8
//  517                     *(DWORD*)buff = (DWORD)cs << (n - 9);
        MOV.W   R8, R12
        MOV.W   #0x0, R13
        MOV.B   R9, R14
        ADD.B   #0xf7, R14
        CALLA   #?ShiftLeft32
        MOV.W   R12, 0(R11)
        MOV.W   R13, 0x2(R11)
//  518                 }
//  519                 res = RES_OK;
??disk_ioctl_10:
        MOV.B   #0x0, R10
//  520             }
//  521             break;
        JMP     ??disk_ioctl_1
//  522 
//  523         case GET_BLOCK_SIZE :    /* Get erase block size in unit of sector (DWORD) */
//  524             *(DWORD*)buff = 128;
??disk_ioctl_7:
        MOV.W   #0x80, 0(R11)
        MOV.W   #0x0, 0x2(R11)
//  525             res = RES_OK;
        MOV.B   #0x0, R10
//  526             break;
        JMP     ??disk_ioctl_1
//  527 
//  528         default:
//  529             res = RES_PARERR;
??disk_ioctl_8:
        MOV.B   #0x4, R10
//  530     }
//  531 
//  532     deselect();
??disk_ioctl_1:
        CALLA   #deselect
//  533 
//  534     return res;
        MOV.B   R10, R12
??disk_ioctl_4:
        ADD.W   #0x10, SP
          CFI CFA SP+28
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock13
//  535 }
//  536 
//  537 
//  538 
//  539 // KLQ
//  540 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  541 uint8_t validateCSD(void)
validateCSD:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function validateCSD
//  542 {
        FUNCALL validateCSD, send_cmd
        LOCFRAME CSTACK, 44, STACK
        FUNCALL validateCSD, rcvr_datablock
        LOCFRAME CSTACK, 44, STACK
        FUNCALL validateCSD, send_cmd
        LOCFRAME CSTACK, 44, STACK
        FUNCALL validateCSD, rcvr_datablock
        LOCFRAME CSTACK, 44, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x20, SP
          CFI CFA SP+44
//  543   BYTE csd0[16], csd1[16], i;
//  544   WORD sum=0;
        MOV.W   #0x0, R11
//  545 
//  546   // Pull the CSD -- twice.  If the response codes are invalid, then we know the card isn't there or initialized.
//  547   if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd0, 16))
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x9, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??validateCSD_4
        MOV.W   #0x10, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #rcvr_datablock
        CMP.W   #0x0, R12
        JEQ     ??validateCSD_4
//  548     if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd1, 16))
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.B   #0x9, R12
        CALLA   #send_cmd
        CMP.B   #0x0, R12
        JNE     ??validateCSD_4
        MOV.W   #0x10, R13
        MOV.W   SP, R12
        ADD.W   #0x10, R12
        CALLA   #rcvr_datablock
        CMP.W   #0x0, R12
        JEQ     ??validateCSD_4
//  549     {
//  550       // The response codes were good -- but maybe the SPI input was just floating low.  Let's evaluate the CSD data.
//  551       // First, look for all zero or all ones.  If the SPI input is floating, these are the most likely outcomes.
//  552       for(i=0;i<=15;i++)
        MOV.B   #0x0, R10
??validateCSD_0:
        CMP.B   #0x10, R10
        JC      ??validateCSD_5
//  553         sum += csd0[i];
        MOV.B   R10, R15
        ADD.W   SP, R15
        MOV.B   @R15, R15
        MOV.B   R15, R15
        ADD.W   R15, R11
        ADD.B   #0x1, R10
        JMP     ??validateCSD_0
//  554       if(!((sum == 0) || (sum == 4096)))
??validateCSD_5:
        CMP.W   #0x0, R11
        JEQ     ??validateCSD_4
        CMP.W   #0x1000, R11
        JEQ     ??validateCSD_4
//  555       {
//  556         // The response was a mix of 0's and 1's.  Floating inputs could still do that -- but it's unlikely they'd
//  557         // produce the same pattern twice.  Compare to ensure the two are identical.
//  558         i = 0;
        MOV.B   #0x0, R10
//  559         while(i<=15)
??validateCSD_1:
        CMP.B   #0x10, R10
        JC      ??validateCSD_3
//  560         {
//  561           if(csd0[i] != csd1[i])
        MOV.B   R10, R14
        ADD.W   SP, R14
        MOV.B   R10, R15
        ADD.W   SP, R15
        CMP.B   0x10(R15), 0(R14)
        JNE     ??validateCSD_3
//  562             break;
//  563           i++;
        ADD.B   #0x1, R10
        JMP     ??validateCSD_1
//  564         }
//  565         if(i>15)
??validateCSD_3:
        CMP.B   #0x10, R10
        JNC     ??validateCSD_4
//  566           return 1;
        MOV.B   #0x1, R12
        JMP     ??validateCSD_6
//  567       }
//  568     }
//  569   return 0;
??validateCSD_4:
        MOV.B   #0x0, R12
??validateCSD_6:
        ADD.W   #0x20, SP
          CFI CFA SP+12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock14
//  570 }
//  571 
//  572 
//  573 // Attempt to detect the card by commanding it to return its CSD register and evaluating it.  Returns the
//  574 // result, and also updates FatFs's internal INS variable.
//  575 // The proper way to detect a card is by sensing its presence on the DAT3 signal.  The EXP board doesn't
//  576 // contain the necessary h/w, so this s/w method works instead.

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  577 uint8_t detectCard(void)
detectCard:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function detectCard
//  578 {
//  579   // Check for a valid CSD response
//  580   if(validateCSD())
        FUNCALL detectCard, validateCSD
        LOCFRAME CSTACK, 4, STACK
        FUNCALL detectCard, disk_status
        LOCFRAME CSTACK, 4, STACK
        FUNCALL detectCard, disk_initialize
        LOCFRAME CSTACK, 4, STACK
        FUNCALL detectCard, validateCSD
        LOCFRAME CSTACK, 4, STACK
        FUNCALL detectCard, disk_status
        LOCFRAME CSTACK, 4, STACK
        CALLA   #validateCSD
        CMP.B   #0x0, R12
        JEQ     ??detectCard_0
//  581   {
//  582     disk_status(0); // Update the INS variable
        MOV.B   #0x0, R12
        CALLA   #disk_status
//  583     return 1;       // Card is present
        MOV.B   #0x1, R12
        RETA
//  584   }
//  585 
//  586   // We didn't get a valid response.  So we now know the status is one of two things:
//  587   // a) The card isn't there at all;
//  588   // b) or, it was just inserted recently, and needs to be initialized
//  589 
//  590   INS = 0x01;          // Trick disk_initialize into thinking it's inserted...
??detectCard_0:
        MOVX.B  #0x1, &INS
//  591   disk_initialize(0);  // Attempt to initialize it
        MOV.B   #0x0, R12
        CALLA   #disk_initialize
//  592 
//  593   INS = validateCSD(); // Try again
        CALLA   #validateCSD
        MOVX.B  R12, &INS
//  594   disk_status(0);      // Update the INS variable
        MOV.B   #0x0, R12
        CALLA   #disk_status
//  595 
//  596   return INS;          // 1 = card is present; 0 = not present
        MOVX.B  &INS, R12
        RETA
          CFI EndBlock cfiBlock15
//  597 }

        RSEG DATA20_ID:CONST:SORT:NOROOT(0)
`?<Initializer for INS>`:
        DC8 1

        RSEG DATA20_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Stat>`:
        DC8 1

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 
// 1 756 bytes in segment CODE
//     2 bytes in segment DATA20_I
//     2 bytes in segment DATA20_ID
//     1 byte  in segment DATA20_Z
// 
// 1 756 bytes of CODE  memory
//     2 bytes of CONST memory
//     3 bytes of DATA  memory
//
//Errors: none
//Warnings: none
