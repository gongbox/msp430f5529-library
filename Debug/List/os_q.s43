///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:53 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_q.c                                           /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_q.c -D DEBUG -D RAM_VECTOR -lA                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug /
//                     \Obj\ --no_cse --no_unroll --no_inline                 /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \os_q.s43                                              /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME os_q

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC OSQAccept
        FUNCTION OSQAccept,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQCreate
        FUNCTION OSQCreate,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQDel
        FUNCTION OSQDel,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC OSQFlush
        FUNCTION OSQFlush,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSQPend
        FUNCTION OSQPend,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC OSQPendAbort
        FUNCTION OSQPendAbort,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQPost
        FUNCTION OSQPost,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQPostFront
        FUNCTION OSQPostFront,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQPostOpt
        FUNCTION OSQPostOpt,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSQQuery
        FUNCTION OSQQuery,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC OS_QInit
        FUNCTION OS_QInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN OSQTbl
        EXTERN OS_MemClr
        FUNCTION OS_MemClr,0202H
        EXTERN OSQFreeList
        EXTERN OSCPUSaveSR
        FUNCTION OSCPUSaveSR,0202H
        EXTERN OSCPURestoreSR
        FUNCTION OSCPURestoreSR,0202H
        EXTERN OS_EventTaskRdy
        FUNCTION OS_EventTaskRdy,0202H
        EXTERN OS_Sched
        FUNCTION OS_Sched,0202H
        EXTERN OSIntNesting
        EXTERN OSLockNesting
        EXTERN OSTCBCur
        EXTERN OS_EventTaskWait
        FUNCTION OS_EventTaskWait,0202H
        EXTERN OS_EventTaskRemove
        FUNCTION OS_EventTaskRemove,0202H
        EXTERN OSEventFreeList
        EXTERN OS_EventWaitListInit
        FUNCTION OS_EventWaitListInit,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_q.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/OS-II
//    4 *                                          The Real-Time Kernel
//    5 *                                        MESSAGE QUEUE MANAGEMENT
//    6 *
//    7 *                              (c) Copyright 1992-2009, Micrium, Weston, FL
//    8 *                                           All Rights Reserved
//    9 *
//   10 * File    : OS_Q.C
//   11 * By      : Jean J. Labrosse
//   12 * Version : V2.91
//   13 *
//   14 * LICENSING TERMS:
//   15 * ---------------
//   16 *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
//   17 * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
//   18 * its use in your product. We provide ALL the source code for your convenience and to help you experience
//   19 * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
//   20 * licensing fee.
//   21 *********************************************************************************************************
//   22 */
//   23 
//   24 #ifndef  OS_MASTER_FILE
//   25 #include "ucos_ii.h"
//   26 #endif
//   27 
//   28 #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
//   29 /*
//   30 *********************************************************************************************************
//   31 *                                      ACCEPT MESSAGE FROM QUEUE
//   32 *
//   33 * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
//   34 *              OSQAccept() does not suspend the calling task if a message is not available.
//   35 *
//   36 * Arguments  : pevent        is a pointer to the event control block
//   37 *
//   38 *              perr          is a pointer to where an error message will be deposited.  Possible error
//   39 *                            messages are:
//   40 *
//   41 *                            OS_ERR_NONE         The call was successful and your task received a
//   42 *                                                message.
//   43 *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
//   44 *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
//   45 *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
//   46 *
//   47 * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
//   48 *                            from the so the next time OSQAccept() is called, the queue will contain
//   49 *                            one less entry.
//   50 *              == (void *)0  if you received a NULL pointer message
//   51 *                            if the queue is empty or,
//   52 *                            if 'pevent' is a NULL pointer or,
//   53 *                            if you passed an invalid event type
//   54 *
//   55 * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
//   56 *              'perr' has been added to the API to tell you about the outcome of the call.
//   57 *********************************************************************************************************
//   58 */
//   59 
//   60 #if OS_Q_ACCEPT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   61 void  *OSQAccept (OS_EVENT  *pevent,
OSQAccept:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function OSQAccept
//   62                   INT8U     *perr)
//   63 {
        FUNCALL OSQAccept, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOVA    R13, R11
//   64     void      *pmsg;
//   65     OS_Q      *pq;
//   66 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//   67     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//   68 #endif
//   69 
//   70 
//   71 
//   72 #ifdef OS_SAFETY_CRITICAL
//   73     if (perr == (INT8U *)0) {
//   74         OS_SAFETY_CRITICAL_EXCEPTION();
//   75     }
//   76 #endif
//   77 
//   78 #if OS_ARG_CHK_EN > 0u
//   79     if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
//   80         *perr = OS_ERR_PEVENT_NULL;
//   81         return ((void *)0);
//   82     }
//   83 #endif
//   84     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQAccept_0
//   85         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//   86         return ((void *)0);
        MOVA    #0x0, R12
        JMP     ??OSQAccept_1
//   87     }
//   88     OS_ENTER_CRITICAL();
??OSQAccept_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//   89     pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
        MOVA    0x2(R10), R9
//   90     if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        CMP.W   #0x0, 0x16(R9)
        JEQ     ??OSQAccept_2
//   91         pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
        MOVA    0x10(R9), R15
        MOVA    @R15, R8
        ADDX.A  #0x4, 0x10(R9)
//   92         pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        ADD.W   #0xffff, 0x16(R9)
//   93         if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
        MOVA    0x10(R9), R15
        MOVA    0x8(R9), R14
        CMPA    R14, R15
        JNE     ??OSQAccept_3
//   94             pq->OSQOut = pq->OSQStart;
        MOVX.A  0x4(R9), 0x10(R9)
//   95         }
//   96         *perr = OS_ERR_NONE;
??OSQAccept_3:
        MOV.B   #0x0, 0(R11)
        JMP     ??OSQAccept_4
//   97     } else {
//   98         *perr = OS_ERR_Q_EMPTY;
??OSQAccept_2:
        MOV.B   #0x1f, 0(R11)
//   99         pmsg  = (void *)0;                       /* Queue is empty                                     */
        MOVA    #0x0, R8
//  100     }
//  101     OS_EXIT_CRITICAL();
??OSQAccept_4:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  102     return (pmsg);                               /* Return message received (or NULL)                  */
        MOVA    R8, R12
??OSQAccept_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  103 }
//  104 #endif
//  105 /*$PAGE*/
//  106 /*
//  107 *********************************************************************************************************
//  108 *                                        CREATE A MESSAGE QUEUE
//  109 *
//  110 * Description: This function creates a message queue if free event control blocks are available.
//  111 *
//  112 * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
//  113 *                            storage area MUST be declared as an array of pointers to 'void' as follows
//  114 *
//  115 *                            void *MessageStorage[size]
//  116 *
//  117 *              size          is the number of elements in the storage area
//  118 *
//  119 * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
//  120 *                                created queue
//  121 *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
//  122 *********************************************************************************************************
//  123 */
//  124 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  125 OS_EVENT  *OSQCreate (void    **start,
OSQCreate:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function OSQCreate
//  126                       INT16U    size)
//  127 {
        FUNCALL OSQCreate, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQCreate, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQCreate, OS_EventWaitListInit
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R11
        MOV.W   R13, R10
//  128     OS_EVENT  *pevent;
//  129     OS_Q      *pq;
//  130 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//  131     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//  132 #endif
//  133 
//  134 
//  135 
//  136 #ifdef OS_SAFETY_CRITICAL_IEC61508
//  137     if (OSSafetyCriticalStartFlag == OS_TRUE) {
//  138         OS_SAFETY_CRITICAL_EXCEPTION();
//  139     }
//  140 #endif
//  141 
//  142     if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSQCreate_0
//  143         return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
        MOVA    #0x0, R12
        JMP     ??OSQCreate_1
//  144     }
//  145     OS_ENTER_CRITICAL();
??OSQCreate_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  146     pevent = OSEventFreeList;                    /* Get next free event control block                  */
        MOVA    &OSEventFreeList, R8
//  147     if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
        MOVA    &OSEventFreeList, R15
        CMPA    #0x0, R15
        JEQ     ??OSQCreate_2
//  148         OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
        MOVA    &OSEventFreeList, R15
        MOVX.A  0x2(R15), &OSEventFreeList
//  149     }
//  150     OS_EXIT_CRITICAL();
??OSQCreate_2:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  151     if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
        CMPA    #0x0, R8
        JEQ     ??OSQCreate_3
//  152         OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  153         pq = OSQFreeList;                        /* Get a free queue control block                     */
        MOVA    &OSQFreeList, R9
//  154         if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
        CMPA    #0x0, R9
        JEQ     ??OSQCreate_4
//  155             OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
        MOVA    &OSQFreeList, R15
        MOVX.A  @R15, &OSQFreeList
//  156             OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  157             pq->OSQStart           = start;               /*      Initialize the queue                 */
        MOVA    R11, 0x4(R9)
//  158             pq->OSQEnd             = &start[size];
        MOV.W   R10, R15
        RLAM.A  #0x2, R15
        MOVA    R15, R14
        MOVA    R11, R15
        ADDA    R14, R15
        MOVA    R15, 0x8(R9)
//  159             pq->OSQIn              = start;
        MOVA    R11, 0xc(R9)
//  160             pq->OSQOut             = start;
        MOVA    R11, 0x10(R9)
//  161             pq->OSQSize            = size;
        MOV.W   R10, 0x14(R9)
//  162             pq->OSQEntries         = 0u;
        MOV.W   #0x0, 0x16(R9)
//  163             pevent->OSEventType    = OS_EVENT_TYPE_Q;
        MOV.B   #0x2, 0(R8)
//  164             pevent->OSEventCnt     = 0u;
        MOV.W   #0x0, 0x6(R8)
//  165             pevent->OSEventPtr     = pq;
        MOVA    R9, 0x2(R8)
//  166 #if OS_EVENT_NAME_EN > 0u
//  167             pevent->OSEventName    = (INT8U *)(void *)"?";
//  168 #endif
//  169             OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        MOVA    R8, R12
        CALLA   #OS_EventWaitListInit
        JMP     ??OSQCreate_3
//  170         } else {
//  171             pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
??OSQCreate_4:
        MOVX.A  &OSEventFreeList, 0x2(R8)
//  172             OSEventFreeList    = pevent;
        MOVA    R8, &OSEventFreeList
//  173             OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  174             pevent = (OS_EVENT *)0;
        MOVA    #0x0, R8
//  175         }
//  176     }
//  177     return (pevent);
??OSQCreate_3:
        MOVA    R8, R12
??OSQCreate_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  178 }
//  179 /*$PAGE*/
//  180 /*
//  181 *********************************************************************************************************
//  182 *                                        DELETE A MESSAGE QUEUE
//  183 *
//  184 * Description: This function deletes a message queue and readies all tasks pending on the queue.
//  185 *
//  186 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  187 *                            queue.
//  188 *
//  189 *              opt           determines delete options as follows:
//  190 *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
//  191 *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
//  192 *                                                    In this case, all the tasks pending will be readied.
//  193 *
//  194 *              perr          is a pointer to an error code that can contain one of the following values:
//  195 *                            OS_ERR_NONE             The call was successful and the queue was deleted
//  196 *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
//  197 *                            OS_ERR_INVALID_OPT      An invalid option was specified
//  198 *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
//  199 *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
//  200 *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
//  201 *
//  202 * Returns    : pevent        upon error
//  203 *              (OS_EVENT *)0 if the queue was successfully deleted.
//  204 *
//  205 * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
//  206 *                 the queue MUST check the return code of OSQPend().
//  207 *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
//  208 *                 they check 'pevent' to see that it's a NULL pointer.
//  209 *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
//  210 *                 time is directly proportional to the number of tasks waiting on the queue.
//  211 *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
//  212 *                 applications where the queue is used for mutual exclusion because the resource(s)
//  213 *                 will no longer be guarded by the queue.
//  214 *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
//  215 *                 type call) then your application MUST release the memory storage by call the counterpart
//  216 *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
//  217 *                 then, the storage can be reused.
//  218 *********************************************************************************************************
//  219 */
//  220 
//  221 #if OS_Q_DEL_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  222 OS_EVENT  *OSQDel (OS_EVENT  *pevent,
OSQDel:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function OSQDel
//  223                    INT8U      opt,
//  224                    INT8U     *perr)
//  225 {
        FUNCALL OSQDel, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OS_EventTaskRdy
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OS_Sched
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        MOVA    R12, R10
        MOV.B   R13, R4
        MOVA    R14, R11
//  226     BOOLEAN    tasks_waiting;
//  227     OS_EVENT  *pevent_return;
//  228     OS_Q      *pq;
//  229 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  230     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//  231 #endif
//  232 
//  233 
//  234 
//  235 #ifdef OS_SAFETY_CRITICAL
//  236     if (perr == (INT8U *)0) {
//  237         OS_SAFETY_CRITICAL_EXCEPTION();
//  238     }
//  239 #endif
//  240 
//  241 #if OS_ARG_CHK_EN > 0u
//  242     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  243         *perr = OS_ERR_PEVENT_NULL;
//  244         return (pevent);
//  245     }
//  246 #endif
//  247     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQDel_3
//  248         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  249         return (pevent);
        MOVA    R10, R12
        JMP     ??OSQDel_4
//  250     }
//  251     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
??OSQDel_3:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSQDel_5
//  252         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        MOV.B   #0xf, 0(R11)
//  253         return (pevent);
        MOVA    R10, R12
        JMP     ??OSQDel_4
//  254     }
//  255     OS_ENTER_CRITICAL();
??OSQDel_5:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  256     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQDel_6
//  257         tasks_waiting = OS_TRUE;                           /* Yes                                      */
        MOV.B   #0x1, R7
        JMP     ??OSQDel_7
//  258     } else {
//  259         tasks_waiting = OS_FALSE;                          /* No                                       */
??OSQDel_6:
        MOV.B   #0x0, R7
//  260     }
//  261     switch (opt) {
??OSQDel_7:
        MOV.B   R4, R14
        SUB.B   #0x0, R14
        JEQ     ??OSQDel_8
        SUB.B   #0x1, R14
        JEQ     ??OSQDel_0
        JMP     ??OSQDel_9
//  262         case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
//  263              if (tasks_waiting == OS_FALSE) {
??OSQDel_8:
        CMP.B   #0x0, R7
        JNE     ??OSQDel_10
//  264 #if OS_EVENT_NAME_EN > 0u
//  265                  pevent->OSEventName    = (INT8U *)(void *)"?";
//  266 #endif
//  267                  pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
        MOVA    0x2(R10), R9
//  268                  pq->OSQPtr             = OSQFreeList;
        MOVX.A  &OSQFreeList, 0(R9)
//  269                  OSQFreeList            = pq;
        MOVA    R9, &OSQFreeList
//  270                  pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R10)
//  271                  pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R10)
//  272                  pevent->OSEventCnt     = 0u;
        MOV.W   #0x0, 0x6(R10)
//  273                  OSEventFreeList        = pevent;          /* Get next free event control block        */
        MOVA    R10, &OSEventFreeList
//  274                  OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  275                  *perr                  = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  276                  pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
        MOVA    #0x0, R8
        JMP     ??OSQDel_2
//  277              } else {
//  278                  OS_EXIT_CRITICAL();
??OSQDel_10:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  279                  *perr                  = OS_ERR_TASK_WAITING;
        MOV.B   #0x49, 0(R11)
//  280                  pevent_return          = pevent;
        MOVA    R10, R8
//  281              }
//  282              break;
        JMP     ??OSQDel_2
//  283 
//  284         case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
//  285              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
??OSQDel_0:
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQDel_11
//  286                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x4, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        JMP     ??OSQDel_0
//  287              }
//  288 #if OS_EVENT_NAME_EN > 0u
//  289              pevent->OSEventName    = (INT8U *)(void *)"?";
//  290 #endif
//  291              pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
??OSQDel_11:
        MOVA    0x2(R10), R9
//  292              pq->OSQPtr             = OSQFreeList;
        MOVX.A  &OSQFreeList, 0(R9)
//  293              OSQFreeList            = pq;
        MOVA    R9, &OSQFreeList
//  294              pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R10)
//  295              pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R10)
//  296              pevent->OSEventCnt     = 0u;
        MOV.W   #0x0, 0x6(R10)
//  297              OSEventFreeList        = pevent;              /* Get next free event control block        */
        MOVA    R10, &OSEventFreeList
//  298              OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  299              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
        CMP.B   #0x1, R7
        JNE     ??OSQDel_12
//  300                  OS_Sched();                               /* Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  301              }
//  302              *perr                  = OS_ERR_NONE;
??OSQDel_12:
        MOV.B   #0x0, 0(R11)
//  303              pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
        MOVA    #0x0, R8
//  304              break;
        JMP     ??OSQDel_2
//  305 
//  306         default:
//  307              OS_EXIT_CRITICAL();
??OSQDel_9:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  308              *perr                  = OS_ERR_INVALID_OPT;
        MOV.B   #0x7, 0(R11)
//  309              pevent_return          = pevent;
        MOVA    R10, R8
//  310              break;
//  311     }
//  312     return (pevent_return);
??OSQDel_2:
        MOVA    R8, R12
??OSQDel_4:
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  313 }
//  314 #endif
//  315 
//  316 /*$PAGE*/
//  317 /*
//  318 *********************************************************************************************************
//  319 *                                             FLUSH QUEUE
//  320 *
//  321 * Description : This function is used to flush the contents of the message queue.
//  322 *
//  323 * Arguments   : none
//  324 *
//  325 * Returns     : OS_ERR_NONE         upon success
//  326 *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
//  327 *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
//  328 *
//  329 * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
//  330 *               the references to what the queue entries are pointing to and thus, you could cause
//  331 *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
//  332 *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
//  333 *********************************************************************************************************
//  334 */
//  335 
//  336 #if OS_Q_FLUSH_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  337 INT8U  OSQFlush (OS_EVENT *pevent)
OSQFlush:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function OSQFlush
//  338 {
        FUNCALL OSQFlush, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSQFlush, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
//  339     OS_Q      *pq;
//  340 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  341     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R8
//  342 #endif
//  343 
//  344 
//  345 
//  346 #if OS_ARG_CHK_EN > 0u
//  347     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  348         return (OS_ERR_PEVENT_NULL);
//  349     }
//  350     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
//  351         return (OS_ERR_EVENT_TYPE);
//  352     }
//  353 #endif
//  354     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R8
//  355     pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
        MOVA    0x2(R10), R11
//  356     pq->OSQIn      = pq->OSQStart;
        MOVX.A  0x4(R11), 0xc(R11)
//  357     pq->OSQOut     = pq->OSQStart;
        MOVX.A  0x4(R11), 0x10(R11)
//  358     pq->OSQEntries = 0u;
        MOV.W   #0x0, 0x16(R11)
//  359     OS_EXIT_CRITICAL();
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  360     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  361 }
//  362 #endif
//  363 
//  364 /*$PAGE*/
//  365 /*
//  366 *********************************************************************************************************
//  367 *                                     PEND ON A QUEUE FOR A MESSAGE
//  368 *
//  369 * Description: This function waits for a message to be sent to a queue
//  370 *
//  371 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
//  372 *
//  373 *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
//  374 *                            wait for a message to arrive at the queue up to the amount of time
//  375 *                            specified by this argument.  If you specify 0, however, your task will wait
//  376 *                            forever at the specified queue or, until a message arrives.
//  377 *
//  378 *              perr          is a pointer to where an error message will be deposited.  Possible error
//  379 *                            messages are:
//  380 *
//  381 *                            OS_ERR_NONE         The call was successful and your task received a
//  382 *                                                message.
//  383 *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
//  384 *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
//  385 *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
//  386 *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
//  387 *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
//  388 *                                                would lead to a suspension.
//  389 *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
//  390 *
//  391 * Returns    : != (void *)0  is a pointer to the message received
//  392 *              == (void *)0  if you received a NULL pointer message or,
//  393 *                            if no message was received or,
//  394 *                            if 'pevent' is a NULL pointer or,
//  395 *                            if you didn't pass a pointer to a queue.
//  396 *
//  397 * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
//  398 *********************************************************************************************************
//  399 */
//  400 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  401 void  *OSQPend (OS_EVENT  *pevent,
OSQPend:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function OSQPend
//  402                 INT32U     timeout,
//  403                 INT8U     *perr)
//  404 {
        FUNCALL OSQPend, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OS_EventTaskWait
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OS_Sched
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OS_EventTaskRemove
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQPend, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        MOVA    R12, R8
        MOV.W   R14, R10
        MOV.W   R15, R11
        MOVA    R13, R9
//  405     void      *pmsg;
//  406     OS_Q      *pq;
//  407 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//  408     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R4
//  409 #endif
//  410 
//  411 
//  412 
//  413 #ifdef OS_SAFETY_CRITICAL
//  414     if (perr == (INT8U *)0) {
//  415         OS_SAFETY_CRITICAL_EXCEPTION();
//  416     }
//  417 #endif
//  418 
//  419 #if OS_ARG_CHK_EN > 0u
//  420     if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
//  421         *perr = OS_ERR_PEVENT_NULL;
//  422         return ((void *)0);
//  423     }
//  424 #endif
//  425     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        CMP.B   #0x2, 0(R8)
        JEQ     ??OSQPend_0
//  426         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R9)
//  427         return ((void *)0);
        MOVA    #0x0, R12
        JMP     ??OSQPend_1
//  428     }
//  429     if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
??OSQPend_0:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSQPend_2
//  430         *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
        MOV.B   #0x2, 0(R9)
//  431         return ((void *)0);
        MOVA    #0x0, R12
        JMP     ??OSQPend_1
//  432     }
//  433     if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
??OSQPend_2:
        CMPX.B  #0x0, &OSLockNesting
        JEQ     ??OSQPend_3
//  434         *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
        MOV.B   #0xd, 0(R9)
//  435         return ((void *)0);
        MOVA    #0x0, R12
        JMP     ??OSQPend_1
//  436     }
//  437     OS_ENTER_CRITICAL();
??OSQPend_3:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R4
//  438     pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
        MOVA    0x2(R8), R7
//  439     if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
        CMP.W   #0x0, 0x16(R7)
        JEQ     ??OSQPend_4
//  440         pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
        MOVA    0x10(R7), R15
        MOVA    @R15, R6
        ADDX.A  #0x4, 0x10(R7)
//  441         pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        ADD.W   #0xffff, 0x16(R7)
//  442         if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
        MOVA    0x10(R7), R15
        MOVA    0x8(R7), R14
        CMPA    R14, R15
        JNE     ??OSQPend_5
//  443             pq->OSQOut = pq->OSQStart;
        MOVX.A  0x4(R7), 0x10(R7)
//  444         }
//  445         OS_EXIT_CRITICAL();
??OSQPend_5:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  446         *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R9)
//  447         return (pmsg);                           /* Return message received                            */
        MOVA    R6, R12
        JMP     ??OSQPend_1
//  448     }
//  449     OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
??OSQPend_4:
        MOVA    &OSTCBCur, R15
        BIS.B   #0x4, 0x2e(R15)
//  450     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  451     OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
        MOVA    &OSTCBCur, R15
        MOV.W   R10, 0x2a(R15)
        MOV.W   R11, 0x2c(R15)
//  452     OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
        MOVA    R8, R12
        CALLA   #OS_EventTaskWait
//  453     OS_EXIT_CRITICAL();
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  454     OS_Sched();                                  /* Find next highest priority task ready to run       */
        CALLA   #OS_Sched
//  455     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R4
//  456     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        MOVA    &OSTCBCur, R15
        MOV.B   0x2f(R15), R14
        SUB.B   #0x0, R14
        JEQ     ??OSQPend_6
        SUB.B   #0x2, R14
        JEQ     ??OSQPend_7
        JMP     ??OSQPend_8
//  457         case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
//  458              pmsg =  OSTCBCur->OSTCBMsg;
??OSQPend_6:
        MOVA    &OSTCBCur, R15
        MOVA    0x20(R15), R6
//  459             *perr =  OS_ERR_NONE;
        MOV.B   #0x0, 0(R9)
//  460              break;
        JMP     ??OSQPend_9
//  461 
//  462         case OS_STAT_PEND_ABORT:
//  463              pmsg = (void *)0;
??OSQPend_7:
        MOVA    #0x0, R6
//  464             *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
        MOV.B   #0xe, 0(R9)
//  465              break;
        JMP     ??OSQPend_9
//  466 
//  467         case OS_STAT_PEND_TO:
//  468         default:
//  469              OS_EventTaskRemove(OSTCBCur, pevent);
??OSQPend_8:
        MOVA    R8, R13
        MOVA    &OSTCBCur, R12
        CALLA   #OS_EventTaskRemove
//  470              pmsg = (void *)0;
        MOVA    #0x0, R6
//  471             *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
        MOV.B   #0xa, 0(R9)
//  472              break;
//  473     }
//  474     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
??OSQPend_9:
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2e(R15)
//  475     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  476     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
        MOVA    &OSTCBCur, R15
        MOVX.A  #0x0, 0x1c(R15)
//  477 #if (OS_EVENT_MULTI_EN > 0u)
//  478     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
//  479 #endif
//  480     OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
        MOVA    &OSTCBCur, R15
        MOVX.A  #0x0, 0x20(R15)
//  481     OS_EXIT_CRITICAL();
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  482     return (pmsg);                                    /* Return received message                       */
        MOVA    R6, R12
??OSQPend_1:
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  483 }
//  484 /*$PAGE*/
//  485 /*
//  486 *********************************************************************************************************
//  487 *                                      ABORT WAITING ON A MESSAGE QUEUE
//  488 *
//  489 * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
//  490 *              should be used to fault-abort the wait on the queue, rather than to normally signal
//  491 *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
//  492 *
//  493 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
//  494 *
//  495 *              opt           determines the type of ABORT performed:
//  496 *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
//  497 *                                                     queue
//  498 *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
//  499 *                                                     queue
//  500 *
//  501 *              perr          is a pointer to where an error message will be deposited.  Possible error
//  502 *                            messages are:
//  503 *
//  504 *                            OS_ERR_NONE         No tasks were     waiting on the queue.
//  505 *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
//  506 *                                                and informed of the aborted wait; check return value
//  507 *                                                for the number of tasks whose wait on the queue
//  508 *                                                was aborted.
//  509 *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
//  510 *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
//  511 *
//  512 * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
//  513 *              >  0          if one or more tasks waiting on the queue are now readied and informed.
//  514 *********************************************************************************************************
//  515 */
//  516 
//  517 #if OS_Q_PEND_ABORT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  518 INT8U  OSQPendAbort (OS_EVENT  *pevent,
OSQPendAbort:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function OSQPendAbort
//  519                      INT8U      opt,
//  520                      INT8U     *perr)
//  521 {
        FUNCALL OSQPendAbort, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPendAbort, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPendAbort, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPendAbort, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPendAbort, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPendAbort, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOV.B   R13, R6
        MOVA    R14, R11
//  522     INT8U      nbr_tasks;
//  523 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  524     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  525 #endif
//  526 
//  527 
//  528 
//  529 #ifdef OS_SAFETY_CRITICAL
//  530     if (perr == (INT8U *)0) {
//  531         OS_SAFETY_CRITICAL_EXCEPTION();
//  532     }
//  533 #endif
//  534 
//  535 #if OS_ARG_CHK_EN > 0u
//  536     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  537         *perr = OS_ERR_PEVENT_NULL;
//  538         return (0u);
//  539     }
//  540 #endif
//  541     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQPendAbort_3
//  542         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  543         return (0u);
        MOV.B   #0x0, R12
        JMP     ??OSQPendAbort_4
//  544     }
//  545     OS_ENTER_CRITICAL();
??OSQPendAbort_3:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  546     if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPendAbort_5
//  547         nbr_tasks = 0u;
        MOV.B   #0x0, R8
//  548         switch (opt) {
        CMP.B   #0x1, R6
        JNE     ??OSQPendAbort_6
//  549             case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
//  550                  while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
??OSQPendAbort_0:
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPendAbort_2
//  551                      (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
        MOV.B   #0x2, R15
        MOV.B   #0x4, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
//  552                      nbr_tasks++;
        ADD.B   #0x1, R8
        JMP     ??OSQPendAbort_0
//  553                  }
//  554                  break;
//  555 
//  556             case OS_PEND_OPT_NONE:
//  557             default:                                       /* No,  ready HPT       waiting on queue    */
//  558                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
??OSQPendAbort_6:
        MOV.B   #0x2, R15
        MOV.B   #0x4, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
//  559                  nbr_tasks++;
        ADD.B   #0x1, R8
//  560                  break;
//  561         }
//  562         OS_EXIT_CRITICAL();
??OSQPendAbort_2:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  563         OS_Sched();                                        /* Find HPT ready to run                    */
        CALLA   #OS_Sched
//  564         *perr = OS_ERR_PEND_ABORT;
        MOV.B   #0xe, 0(R11)
//  565         return (nbr_tasks);
        MOV.B   R8, R12
        JMP     ??OSQPendAbort_4
//  566     }
//  567     OS_EXIT_CRITICAL();
??OSQPendAbort_5:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  568     *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  569     return (0u);                                           /* No tasks waiting on queue                */
        MOV.B   #0x0, R12
??OSQPendAbort_4:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  570 }
//  571 #endif
//  572 
//  573 /*$PAGE*/
//  574 /*
//  575 *********************************************************************************************************
//  576 *                                        POST MESSAGE TO A QUEUE
//  577 *
//  578 * Description: This function sends a message to a queue
//  579 *
//  580 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
//  581 *
//  582 *              pmsg          is a pointer to the message to send.
//  583 *
//  584 * Returns    : OS_ERR_NONE           The call was successful and the message was sent
//  585 *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
//  586 *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
//  587 *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
//  588 *
//  589 * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
//  590 *********************************************************************************************************
//  591 */
//  592 
//  593 #if OS_Q_POST_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  594 INT8U  OSQPost (OS_EVENT  *pevent,
OSQPost:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function OSQPost
//  595                 void      *pmsg)
//  596 {
        FUNCALL OSQPost, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPost, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPost, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPost, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPost, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPost, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOVA    R13, R11
//  597     OS_Q      *pq;
//  598 #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
//  599     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  600 #endif
//  601 
//  602 
//  603 
//  604 #if OS_ARG_CHK_EN > 0u
//  605     if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
//  606         return (OS_ERR_PEVENT_NULL);
//  607     }
//  608 #endif
//  609     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQPost_0
//  610         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSQPost_1
//  611     }
//  612     OS_ENTER_CRITICAL();
??OSQPost_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  613     if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPost_2
//  614                                                        /* Ready highest priority task waiting on event */
//  615         (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x4, R14
        MOVA    R11, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        MOV.B   R12, R6
//  616         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  617         OS_Sched();                                    /* Find highest priority task ready to run      */
        CALLA   #OS_Sched
//  618         return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        JMP     ??OSQPost_1
//  619     }
//  620     pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
??OSQPost_2:
        MOVA    0x2(R10), R8
//  621     if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        CMP.W   0x14(R8), 0x16(R8)
        JNC     ??OSQPost_3
//  622         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  623         return (OS_ERR_Q_FULL);
        MOV.B   #0x1e, R12
        JMP     ??OSQPost_1
//  624     }
//  625     *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
??OSQPost_3:
        MOVA    0xc(R8), R15
        MOVA    R11, 0(R15)
        ADDX.A  #0x4, 0xc(R8)
//  626     pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
        ADD.W   #0x1, 0x16(R8)
//  627     if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
        MOVA    0xc(R8), R15
        MOVA    0x8(R8), R14
        CMPA    R14, R15
        JNE     ??OSQPost_4
//  628         pq->OSQIn = pq->OSQStart;
        MOVX.A  0x4(R8), 0xc(R8)
//  629     }
//  630     OS_EXIT_CRITICAL();
??OSQPost_4:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  631     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSQPost_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  632 }
//  633 #endif
//  634 /*$PAGE*/
//  635 /*
//  636 *********************************************************************************************************
//  637 *                                   POST MESSAGE TO THE FRONT OF A QUEUE
//  638 *
//  639 * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
//  640 *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
//  641 *              'priority' messages.
//  642 *
//  643 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
//  644 *
//  645 *              pmsg          is a pointer to the message to send.
//  646 *
//  647 * Returns    : OS_ERR_NONE           The call was successful and the message was sent
//  648 *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
//  649 *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
//  650 *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
//  651 *
//  652 * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
//  653 *********************************************************************************************************
//  654 */
//  655 
//  656 #if OS_Q_POST_FRONT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  657 INT8U  OSQPostFront (OS_EVENT  *pevent,
OSQPostFront:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function OSQPostFront
//  658                      void      *pmsg)
//  659 {
        FUNCALL OSQPostFront, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostFront, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostFront, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostFront, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostFront, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostFront, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOVA    R13, R11
//  660     OS_Q      *pq;
//  661 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  662     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  663 #endif
//  664 
//  665 
//  666 
//  667 #if OS_ARG_CHK_EN > 0u
//  668     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  669         return (OS_ERR_PEVENT_NULL);
//  670     }
//  671 #endif
//  672     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQPostFront_0
//  673         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSQPostFront_1
//  674     }
//  675     OS_ENTER_CRITICAL();
??OSQPostFront_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  676     if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPostFront_2
//  677                                                       /* Ready highest priority task waiting on event  */
//  678         (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x4, R14
        MOVA    R11, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        MOV.B   R12, R6
//  679         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  680         OS_Sched();                                   /* Find highest priority task ready to run       */
        CALLA   #OS_Sched
//  681         return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        JMP     ??OSQPostFront_1
//  682     }
//  683     pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
??OSQPostFront_2:
        MOVA    0x2(R10), R8
//  684     if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        CMP.W   0x14(R8), 0x16(R8)
        JNC     ??OSQPostFront_3
//  685         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  686         return (OS_ERR_Q_FULL);
        MOV.B   #0x1e, R12
        JMP     ??OSQPostFront_1
//  687     }
//  688     if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
??OSQPostFront_3:
        MOVA    0x10(R8), R15
        MOVA    0x4(R8), R14
        CMPA    R14, R15
        JNE     ??OSQPostFront_4
//  689         pq->OSQOut = pq->OSQEnd;
        MOVX.A  0x8(R8), 0x10(R8)
//  690     }
//  691     pq->OSQOut--;
??OSQPostFront_4:
        ADDX.A  #0xffffc, 0x10(R8)
//  692     *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
        MOVA    0x10(R8), R15
        MOVA    R11, 0(R15)
//  693     pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
        ADD.W   #0x1, 0x16(R8)
//  694     OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  695     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSQPostFront_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  696 }
//  697 #endif
//  698 /*$PAGE*/
//  699 /*
//  700 *********************************************************************************************************
//  701 *                                        POST MESSAGE TO A QUEUE
//  702 *
//  703 * Description: This function sends a message to a queue.  This call has been added to reduce code size
//  704 *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
//  705 *              capability to broadcast a message to ALL tasks waiting on the message queue.
//  706 *
//  707 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
//  708 *
//  709 *              pmsg          is a pointer to the message to send.
//  710 *
//  711 *              opt           determines the type of POST performed:
//  712 *                            OS_POST_OPT_NONE         POST to a single waiting task
//  713 *                                                     (Identical to OSQPost())
//  714 *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
//  715 *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
//  716 *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
//  717 *
//  718 * Returns    : OS_ERR_NONE           The call was successful and the message was sent
//  719 *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
//  720 *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
//  721 *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
//  722 *
//  723 * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
//  724 *              interrupt disable time is proportional to the number of tasks waiting on the queue.
//  725 *********************************************************************************************************
//  726 */
//  727 
//  728 #if OS_Q_POST_OPT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  729 INT8U  OSQPostOpt (OS_EVENT  *pevent,
OSQPostOpt:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function OSQPostOpt
//  730                    void      *pmsg,
//  731                    INT8U      opt)
//  732 {
        FUNCALL OSQPostOpt, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSQPostOpt, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOVA    R13, R11
        MOV.B   R14, R6
//  733     OS_Q      *pq;
//  734 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  735     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  736 #endif
//  737 
//  738 
//  739 
//  740 #if OS_ARG_CHK_EN > 0u
//  741     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  742         return (OS_ERR_PEVENT_NULL);
//  743     }
//  744 #endif
//  745     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQPostOpt_1
//  746         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSQPostOpt_2
//  747     }
//  748     OS_ENTER_CRITICAL();
??OSQPostOpt_1:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  749     if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPostOpt_3
//  750         if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
        BIT.B   #0x1, R6
        JNC     ??OSQPostOpt_4
//  751             while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
??OSQPostOpt_0:
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSQPostOpt_5
//  752                 (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x4, R14
        MOVA    R11, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        JMP     ??OSQPostOpt_0
//  753             }
//  754         } else {                                      /* No,  Post to HPT waiting on queue             */
//  755             (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
??OSQPostOpt_4:
        MOV.B   #0x0, R15
        MOV.B   #0x4, R14
        MOVA    R11, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
//  756         }
//  757         OS_EXIT_CRITICAL();
??OSQPostOpt_5:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  758         if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
        BIT.B   #0x4, R6
        JC      ??OSQPostOpt_6
//  759             OS_Sched();                               /* Find highest priority task ready to run       */
        CALLA   #OS_Sched
//  760         }
//  761         return (OS_ERR_NONE);
??OSQPostOpt_6:
        MOV.B   #0x0, R12
        JMP     ??OSQPostOpt_2
//  762     }
//  763     pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
??OSQPostOpt_3:
        MOVA    0x2(R10), R8
//  764     if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
        CMP.W   0x14(R8), 0x16(R8)
        JNC     ??OSQPostOpt_7
//  765         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  766         return (OS_ERR_Q_FULL);
        MOV.B   #0x1e, R12
        JMP     ??OSQPostOpt_2
//  767     }
//  768     if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
??OSQPostOpt_7:
        BIT.B   #0x2, R6
        JNC     ??OSQPostOpt_8
//  769         if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
        MOVA    0x10(R8), R15
        MOVA    0x4(R8), R14
        CMPA    R14, R15
        JNE     ??OSQPostOpt_9
//  770             pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
        MOVX.A  0x8(R8), 0x10(R8)
//  771         }
//  772         pq->OSQOut--;
??OSQPostOpt_9:
        ADDX.A  #0xffffc, 0x10(R8)
//  773         *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
        MOVA    0x10(R8), R15
        MOVA    R11, 0(R15)
        JMP     ??OSQPostOpt_10
//  774     } else {                                          /* No,  Post as FIFO                             */
//  775         *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
??OSQPostOpt_8:
        MOVA    0xc(R8), R15
        MOVA    R11, 0(R15)
        ADDX.A  #0x4, 0xc(R8)
//  776         if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
        MOVA    0xc(R8), R15
        MOVA    0x8(R8), R14
        CMPA    R14, R15
        JNE     ??OSQPostOpt_10
//  777             pq->OSQIn = pq->OSQStart;
        MOVX.A  0x4(R8), 0xc(R8)
//  778         }
//  779     }
//  780     pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
??OSQPostOpt_10:
        ADD.W   #0x1, 0x16(R8)
//  781     OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  782     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSQPostOpt_2:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  783 }
//  784 #endif
//  785 /*$PAGE*/
//  786 /*
//  787 *********************************************************************************************************
//  788 *                                        QUERY A MESSAGE QUEUE
//  789 *
//  790 * Description: This function obtains information about a message queue.
//  791 *
//  792 * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
//  793 *
//  794 *              p_q_data      is a pointer to a structure that will contain information about the message
//  795 *                            queue.
//  796 *
//  797 * Returns    : OS_ERR_NONE         The call was successful and the message was sent
//  798 *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
//  799 *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
//  800 *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
//  801 *********************************************************************************************************
//  802 */
//  803 
//  804 #if OS_Q_QUERY_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  805 INT8U  OSQQuery (OS_EVENT  *pevent,
OSQQuery:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function OSQQuery
//  806                  OS_Q_DATA *p_q_data)
//  807 {
        FUNCALL OSQQuery, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSQQuery, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        MOVA    R12, R10
        MOVA    R13, R11
//  808     OS_Q       *pq;
//  809     INT8U       i;
//  810     OS_PRIO    *psrc;
//  811     OS_PRIO    *pdest;
//  812 #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
//  813     OS_CPU_SR   cpu_sr = 0u;
        MOV.W   #0x0, R4
//  814 #endif
//  815 
//  816 
//  817 
//  818 #if OS_ARG_CHK_EN > 0u
//  819     if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
//  820         return (OS_ERR_PEVENT_NULL);
//  821     }
//  822     if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
//  823         return (OS_ERR_PDATA_NULL);
//  824     }
//  825 #endif
//  826     if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        CMP.B   #0x2, 0(R10)
        JEQ     ??OSQQuery_1
//  827         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSQQuery_2
//  828     }
//  829     OS_ENTER_CRITICAL();
??OSQQuery_1:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R4
//  830     p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
        MOV.B   0x8(R10), 0x10(R11)
//  831     psrc                 = &pevent->OSEventTbl[0];
        MOVA    R10, R15
        ADDA    #0x9, R15
        MOVA    R15, R6
//  832     pdest                = &p_q_data->OSEventTbl[0];
        MOVA    R11, R15
        ADDA    #0x8, R15
        MOVA    R15, R7
//  833     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        MOV.B   #0x0, R9
??OSQQuery_0:
        CMP.B   #0x8, R9
        JC      ??OSQQuery_3
//  834         *pdest++ = *psrc++;
        MOV.B   @R6, 0(R7)
        ADDA    #0x1, R6
        ADDA    #0x1, R7
//  835     }
        ADD.B   #0x1, R9
        JMP     ??OSQQuery_0
//  836     pq = (OS_Q *)pevent->OSEventPtr;
??OSQQuery_3:
        MOVA    0x2(R10), R8
//  837     if (pq->OSQEntries > 0u) {
        CMP.W   #0x0, 0x16(R8)
        JEQ     ??OSQQuery_4
//  838         p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
        MOVA    0x10(R8), R15
        MOVX.A  @R15, 0(R11)
        JMP     ??OSQQuery_5
//  839     } else {
//  840         p_q_data->OSMsg = (void *)0;
??OSQQuery_4:
        MOVX.A  #0x0, 0(R11)
//  841     }
//  842     p_q_data->OSNMsgs = pq->OSQEntries;
??OSQQuery_5:
        MOV.W   0x16(R8), 0x4(R11)
//  843     p_q_data->OSQSize = pq->OSQSize;
        MOV.W   0x14(R8), 0x6(R11)
//  844     OS_EXIT_CRITICAL();
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  845     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSQQuery_2:
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  846 }
//  847 #endif                                                 /* OS_Q_QUERY_EN                                */
//  848 
//  849 /*$PAGE*/
//  850 /*
//  851 *********************************************************************************************************
//  852 *                                      QUEUE MODULE INITIALIZATION
//  853 *
//  854 * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
//  855 *               application MUST NOT call this function.
//  856 *
//  857 * Arguments   :  none
//  858 *
//  859 * Returns     : none
//  860 *
//  861 * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
//  862 *********************************************************************************************************
//  863 */
//  864 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  865 void  OS_QInit (void)
OS_QInit:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function OS_QInit
//  866 {
        FUNCALL OS_QInit, OS_MemClr
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
//  867 #if OS_MAX_QS == 1u
//  868     OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
//  869     OSQFreeList->OSQPtr = (OS_Q *)0;
//  870 #endif
//  871 
//  872 #if OS_MAX_QS >= 2u
//  873     INT16U   ix;
//  874     INT16U   ix_next;
//  875     OS_Q    *pq1;
//  876     OS_Q    *pq2;
//  877 
//  878 
//  879 
//  880     OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
        MOV.W   #0x78, R13
        MOVA    #OSQTbl, R12
        CALLA   #OS_MemClr
//  881     for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
        MOV.W   #0x0, R10
??OS_QInit_0:
        CMP.W   #0x4, R10
        JC      ??OS_QInit_1
//  882         ix_next = ix + 1u;
        MOV.W   R10, R15
        ADD.W   #0x1, R15
        MOV.W   R15, R11
//  883         pq1 = &OSQTbl[ix];
        MOV.W   R10, R15
        RLAM.A  #0x3, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSQTbl, R15
        MOVA    R15, R8
//  884         pq2 = &OSQTbl[ix_next];
        MOV.W   R11, R15
        RLAM.A  #0x3, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSQTbl, R15
        MOVA    R15, R9
//  885         pq1->OSQPtr = pq2;
        MOVA    R9, 0(R8)
//  886     }
        ADD.W   #0x1, R10
        JMP     ??OS_QInit_0
//  887     pq1         = &OSQTbl[ix];
??OS_QInit_1:
        MOV.W   R10, R15
        RLAM.A  #0x3, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSQTbl, R15
        MOVA    R15, R8
//  888     pq1->OSQPtr = (OS_Q *)0;
        MOVX.A  #0x0, 0(R8)
//  889     OSQFreeList = &OSQTbl[0];
        MOVX.A  #OSQTbl, &OSQFreeList
//  890 #endif
//  891 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  892 #endif                                               /* OS_Q_EN                                        */
//  893 	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
// 
// 1 644 bytes in segment CODE
// 
// 1 644 bytes of CODE memory
//
//Errors: none
//Warnings: 11
