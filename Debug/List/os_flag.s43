///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:48 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_flag.c                                        /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_flag.c -D DEBUG -D RAM_VECTOR -lA             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug /
//                     \Obj\ --no_cse --no_unroll --no_inline                 /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \os_flag.s43                                           /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME os_flag

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC OSFlagAccept
        FUNCTION OSFlagAccept,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC OSFlagCreate
        FUNCTION OSFlagCreate,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSFlagDel
        FUNCTION OSFlagDel,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC OSFlagNameGet
        FUNCTION OSFlagNameGet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSFlagNameSet
        FUNCTION OSFlagNameSet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSFlagPend
        FUNCTION OSFlagPend,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 62, STACK
        PUBLIC OSFlagPendGetFlagsRdy
        FUNCTION OSFlagPendGetFlagsRdy,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC OSFlagPost
        FUNCTION OSFlagPost,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 40, STACK
        PUBLIC OSFlagQuery
        FUNCTION OSFlagQuery,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION OS_FlagBlock,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OS_FlagInit
        FUNCTION OS_FlagInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION OS_FlagTaskRdy,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OS_FlagUnlink
        FUNCTION OS_FlagUnlink,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN OSRdyGrp
        EXTERN OSRdyTbl
        EXTERN OSFlagTbl
        EXTERN OS_MemClr
        FUNCTION OS_MemClr,0202H
        EXTERN OSFlagFreeList
        EXTERN OSTCBCur
        EXTERN OSCPUSaveSR
        FUNCTION OSCPUSaveSR,0202H
        EXTERN OSCPURestoreSR
        FUNCTION OSCPURestoreSR,0202H
        EXTERN OS_Sched
        FUNCTION OS_Sched,0202H
        EXTERN OSIntNesting
        EXTERN OSLockNesting
        EXTERN OS_StrLen
        FUNCTION OS_StrLen,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_flag.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/OS-II
//    4 *                                          The Real-Time Kernel
//    5 *                                         EVENT FLAG  MANAGEMENT
//    6 *
//    7 *                              (c) Copyright 1992-2009, Micrium, Weston, FL
//    8 *                                           All Rights Reserved
//    9 *
//   10 * File    : OS_FLAG.C
//   11 * By      : Jean J. Labrosse
//   12 * Version : V2.91
//   13 *
//   14 * LICENSING TERMS:
//   15 * ---------------
//   16 *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
//   17 * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
//   18 * its use in your product. We provide ALL the source code for your convenience and to help you experience
//   19 * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
//   20 * licensing fee.
//   21 *********************************************************************************************************
//   22 */
//   23 
//   24 #ifndef  OS_MASTER_FILE
//   25 #include "ucos_ii.h"
//   26 #endif
//   27 
//   28 #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
//   29 /*
//   30 *********************************************************************************************************
//   31 *                                            LOCAL PROTOTYPES
//   32 *********************************************************************************************************
//   33 */
//   34 
//   35 static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
//   36 static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
//   37 
//   38 /*$PAGE*/
//   39 /*
//   40 *********************************************************************************************************
//   41 *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
//   42 *
//   43 * Description: This function is called to check the status of a combination of bits to be set or cleared
//   44 *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
//   45 *              bits to be set/cleared.
//   46 *
//   47 *              This call does not block if the desired flags are not present.
//   48 *
//   49 * Arguments  : pgrp          is a pointer to the desired event flag group.
//   50 *
//   51 *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
//   52 *                            The bits you want are specified by setting the corresponding bits in
//   53 *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
//   54 *                            'flags' would contain 0x03.
//   55 *
//   56 *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
//   57 *                            to be set/cleared.
//   58 *                            You can specify the following argument:
//   59 *
//   60 *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
//   61 *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
//   62 *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
//   63 *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
//   64 *
//   65 *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
//   66 *                                  the call.  Example, to wait for any flag in a group AND then clear
//   67 *                                  the flags that are present, set 'wait_type' to:
//   68 *
//   69 *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
//   70 *
//   71 *              perr          is a pointer to an error code and can be:
//   72 *                            OS_ERR_NONE               No error
//   73 *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
//   74 *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
//   75 *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
//   76 *                                                      group handle.
//   77 *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
//   78 *                                                      available.
//   79 *
//   80 * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
//   81 *              occurred.
//   82 *
//   83 * Called from: Task or ISR
//   84 *
//   85 * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
//   86 *                 function NOW returns the flags that were ready INSTEAD of the current state of the
//   87 *                 event flags.
//   88 *********************************************************************************************************
//   89 */
//   90 
//   91 #if OS_FLAG_ACCEPT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   92 OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
OSFlagAccept:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function OSFlagAccept
//   93                         OS_FLAGS      flags,
//   94                         INT8U         wait_type,
//   95                         INT8U        *perr)
//   96 {
        FUNCALL OSFlagAccept, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        MOVA    R12, R8
        MOV.W   R13, R10
        MOV.B   R14, R11
        MOVA    R15, R9
//   97     OS_FLAGS      flags_rdy;
//   98     INT8U         result;
//   99     BOOLEAN       consume;
//  100 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  101     OS_CPU_SR     cpu_sr = 0u;
        MOV.W   #0x0, R4
//  102 #endif
//  103 
//  104 
//  105 
//  106 #ifdef OS_SAFETY_CRITICAL
//  107     if (perr == (INT8U *)0) {
//  108         OS_SAFETY_CRITICAL_EXCEPTION();
//  109     }
//  110 #endif
//  111 
//  112 #if OS_ARG_CHK_EN > 0u
//  113     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
//  114         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  115         return ((OS_FLAGS)0);
//  116     }
//  117 #endif
//  118     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
        CMP.B   #0x5, 0(R8)
        JEQ     ??OSFlagAccept_0
//  119         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R9)
//  120         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagAccept_1
//  121     }
//  122     result = (INT8U)(wait_type & OS_FLAG_CONSUME);
??OSFlagAccept_0:
        MOV.B   R11, R14
        AND.B   #0x80, R14
        MOV.B   R14, R5
//  123     if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
        CMP.B   #0x0, R5
        JEQ     ??OSFlagAccept_2
//  124         wait_type &= ~OS_FLAG_CONSUME;
        BIC.B   #0x80, R11
//  125         consume    = OS_TRUE;
        MOV.B   #0x1, R7
        JMP     ??OSFlagAccept_3
//  126     } else {
//  127         consume    = OS_FALSE;
??OSFlagAccept_2:
        MOV.B   #0x0, R7
//  128     }
//  129 /*$PAGE*/
//  130     *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
??OSFlagAccept_3:
        MOV.B   #0x0, 0(R9)
//  131     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R4
//  132     switch (wait_type) {
        MOV.B   R11, R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagAccept_4
        SUB.B   #0x1, R14
        JEQ     ??OSFlagAccept_5
        SUB.B   #0x1, R14
        JEQ     ??OSFlagAccept_6
        SUB.B   #0x1, R14
        JEQ     ??OSFlagAccept_7
        JMP     ??OSFlagAccept_8
//  133         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
//  134              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
??OSFlagAccept_6:
        MOV.W   R10, R15
        AND.W   0x6(R8), R15
        MOV.W   R15, R6
//  135              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
        CMP.W   R10, R6
        JNE     ??OSFlagAccept_9
//  136                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R7
        JNE     ??OSFlagAccept_10
//  137                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
        BIC.W   R6, 0x6(R8)
        JMP     ??OSFlagAccept_10
//  138                  }
//  139              } else {
//  140                  *perr = OS_ERR_FLAG_NOT_RDY;
??OSFlagAccept_9:
        MOV.B   #0x70, 0(R9)
//  141              }
//  142              OS_EXIT_CRITICAL();
??OSFlagAccept_10:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  143              break;
        JMP     ??OSFlagAccept_11
//  144 
//  145         case OS_FLAG_WAIT_SET_ANY:
//  146              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
??OSFlagAccept_7:
        MOV.W   R10, R15
        AND.W   0x6(R8), R15
        MOV.W   R15, R6
//  147              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
        CMP.W   #0x0, R6
        JEQ     ??OSFlagAccept_12
//  148                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R7
        JNE     ??OSFlagAccept_13
//  149                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
        BIC.W   R6, 0x6(R8)
        JMP     ??OSFlagAccept_13
//  150                  }
//  151              } else {
//  152                  *perr = OS_ERR_FLAG_NOT_RDY;
??OSFlagAccept_12:
        MOV.B   #0x70, 0(R9)
//  153              }
//  154              OS_EXIT_CRITICAL();
??OSFlagAccept_13:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  155              break;
        JMP     ??OSFlagAccept_11
//  156 
//  157 #if OS_FLAG_WAIT_CLR_EN > 0u
//  158         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
//  159              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
??OSFlagAccept_4:
        MOV.W   R10, R15
        BIC.W   0x6(R8), R15
        MOV.W   R15, R6
//  160              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
        CMP.W   R10, R6
        JNE     ??OSFlagAccept_14
//  161                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R7
        JNE     ??OSFlagAccept_15
//  162                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
        BIS.W   R6, 0x6(R8)
        JMP     ??OSFlagAccept_15
//  163                  }
//  164              } else {
//  165                  *perr = OS_ERR_FLAG_NOT_RDY;
??OSFlagAccept_14:
        MOV.B   #0x70, 0(R9)
//  166              }
//  167              OS_EXIT_CRITICAL();
??OSFlagAccept_15:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  168              break;
        JMP     ??OSFlagAccept_11
//  169 
//  170         case OS_FLAG_WAIT_CLR_ANY:
//  171              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
??OSFlagAccept_5:
        MOV.W   R10, R15
        BIC.W   0x6(R8), R15
        MOV.W   R15, R6
//  172              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
        CMP.W   #0x0, R6
        JEQ     ??OSFlagAccept_16
//  173                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R7
        JNE     ??OSFlagAccept_17
//  174                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
        BIS.W   R6, 0x6(R8)
        JMP     ??OSFlagAccept_17
//  175                  }
//  176              } else {
//  177                  *perr = OS_ERR_FLAG_NOT_RDY;
??OSFlagAccept_16:
        MOV.B   #0x70, 0(R9)
//  178              }
//  179              OS_EXIT_CRITICAL();
??OSFlagAccept_17:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  180              break;
        JMP     ??OSFlagAccept_11
//  181 #endif
//  182 
//  183         default:
//  184              OS_EXIT_CRITICAL();
??OSFlagAccept_8:
        MOV.W   R4, R12
        CALLA   #OSCPURestoreSR
//  185              flags_rdy = (OS_FLAGS)0;
        MOV.W   #0x0, R6
//  186              *perr     = OS_ERR_FLAG_WAIT_TYPE;
        MOV.B   #0x6f, 0(R9)
//  187              break;
//  188     }
//  189     return (flags_rdy);
??OSFlagAccept_11:
        MOV.W   R6, R12
??OSFlagAccept_1:
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  190 }
//  191 #endif
//  192 
//  193 /*$PAGE*/
//  194 /*
//  195 *********************************************************************************************************
//  196 *                                           CREATE AN EVENT FLAG
//  197 *
//  198 * Description: This function is called to create an event flag group.
//  199 *
//  200 * Arguments  : flags         Contains the initial value to store in the event flag group.
//  201 *
//  202 *              perr          is a pointer to an error code which will be returned to your application:
//  203 *                               OS_ERR_NONE               if the call was successful.
//  204 *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
//  205 *                                                         ISR.
//  206 *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
//  207 *
//  208 * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
//  209 *
//  210 * Called from: Task ONLY
//  211 *********************************************************************************************************
//  212 */
//  213 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  214 OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
OSFlagCreate:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function OSFlagCreate
//  215                             INT8U    *perr)
//  216 {
        FUNCALL OSFlagCreate, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSFlagCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSFlagCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R10
        MOVA    R13, R11
//  217     OS_FLAG_GRP *pgrp;
//  218 #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
//  219     OS_CPU_SR    cpu_sr = 0u;
        MOV.W   #0x0, R9
//  220 #endif
//  221 
//  222 
//  223 
//  224 #ifdef OS_SAFETY_CRITICAL
//  225     if (perr == (INT8U *)0) {
//  226         OS_SAFETY_CRITICAL_EXCEPTION();
//  227     }
//  228 #endif
//  229 
//  230 #ifdef OS_SAFETY_CRITICAL_IEC61508
//  231     if (OSSafetyCriticalStartFlag == OS_TRUE) {
//  232         OS_SAFETY_CRITICAL_EXCEPTION();
//  233     }
//  234 #endif
//  235 
//  236     if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSFlagCreate_0
//  237         *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
        MOV.B   #0x10, 0(R11)
//  238         return ((OS_FLAG_GRP *)0);
        MOVA    #0x0, R12
        JMP     ??OSFlagCreate_1
//  239     }
//  240     OS_ENTER_CRITICAL();
??OSFlagCreate_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  241     pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
        MOVA    &OSFlagFreeList, R8
//  242     if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
        CMPA    #0x0, R8
        JEQ     ??OSFlagCreate_2
//  243                                                     /* Adjust free list                                */
//  244         OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
        MOVA    &OSFlagFreeList, R15
        MOVX.A  0x2(R15), &OSFlagFreeList
//  245         pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        MOV.B   #0x5, 0(R8)
//  246         pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        MOV.W   R10, 0x6(R8)
//  247         pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
        MOVX.A  #0x0, 0x2(R8)
//  248 #if OS_FLAG_NAME_EN > 0u
//  249         pgrp->OSFlagName     = (INT8U *)(void *)"?";
        MOVX.A  #`?<Constant "?">`, 0x8(R8)
//  250 #endif
//  251         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  252         *perr                = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
        JMP     ??OSFlagCreate_3
//  253     } else {
//  254         OS_EXIT_CRITICAL();
??OSFlagCreate_2:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  255         *perr                = OS_ERR_FLAG_GRP_DEPLETED;
        MOV.B   #0x72, 0(R11)
//  256     }
//  257     return (pgrp);                                  /* Return pointer to event flag group              */
??OSFlagCreate_3:
        MOVA    R8, R12
??OSFlagCreate_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  258 }
//  259 
//  260 /*$PAGE*/
//  261 /*
//  262 *********************************************************************************************************
//  263 *                                     DELETE AN EVENT FLAG GROUP
//  264 *
//  265 * Description: This function deletes an event flag group and readies all tasks pending on the event flag
//  266 *              group.
//  267 *
//  268 * Arguments  : pgrp          is a pointer to the desired event flag group.
//  269 *
//  270 *              opt           determines delete options as follows:
//  271 *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
//  272 *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
//  273 *                                                    waiting.  In this case, all the tasks pending will be
//  274 *                                                    readied.
//  275 *
//  276 *              perr          is a pointer to an error code that can contain one of the following values:
//  277 *                            OS_ERR_NONE               The call was successful and the event flag group was
//  278 *                                                      deleted
//  279 *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
//  280 *                                                      an ISR
//  281 *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
//  282 *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
//  283 *                            OS_ERR_INVALID_OPT        An invalid option was specified
//  284 *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
//  285 *                                                      group.
//  286 *
//  287 * Returns    : pgrp          upon error
//  288 *              (OS_EVENT *)0 if the event flag group was successfully deleted.
//  289 *
//  290 * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
//  291 *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
//  292 *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
//  293 *                 time is directly proportional to the number of tasks waiting on the event flag group.
//  294 *********************************************************************************************************
//  295 */
//  296 
//  297 #if OS_FLAG_DEL_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  298 OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
OSFlagDel:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function OSFlagDel
//  299                          INT8U         opt,
//  300                          INT8U        *perr)
//  301 {
        FUNCALL OSFlagDel, OSCPUSaveSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OS_FlagTaskRdy
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OS_Sched
        LOCFRAME CSTACK, 36, STACK
        FUNCALL OSFlagDel, OSCPURestoreSR
        LOCFRAME CSTACK, 36, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        MOVA    R12, R10
        MOV.B   R13, R4
        MOVA    R14, R11
//  302     BOOLEAN       tasks_waiting;
//  303     OS_FLAG_NODE *pnode;
//  304     OS_FLAG_GRP  *pgrp_return;
//  305 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  306     OS_CPU_SR     cpu_sr = 0u;
        MOV.W   #0x0, R7
//  307 #endif
//  308 
//  309 
//  310 
//  311 #ifdef OS_SAFETY_CRITICAL
//  312     if (perr == (INT8U *)0) {
//  313         OS_SAFETY_CRITICAL_EXCEPTION();
//  314     }
//  315 #endif
//  316 
//  317 #if OS_ARG_CHK_EN > 0u
//  318     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
//  319         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  320         return (pgrp);
//  321     }
//  322 #endif
//  323     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSFlagDel_3
//  324         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        MOV.B   #0xf, 0(R11)
//  325         return (pgrp);
        MOVA    R10, R12
        JMP     ??OSFlagDel_4
//  326     }
//  327     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
??OSFlagDel_3:
        CMP.B   #0x5, 0(R10)
        JEQ     ??OSFlagDel_5
//  328         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  329         return (pgrp);
        MOVA    R10, R12
        JMP     ??OSFlagDel_4
//  330     }
//  331     OS_ENTER_CRITICAL();
??OSFlagDel_5:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R7
//  332     if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        MOVA    0x2(R10), R15
        CMPA    #0x0, R15
        JEQ     ??OSFlagDel_6
//  333         tasks_waiting = OS_TRUE;                           /* Yes                                      */
        MOV.B   #0x1, R8
        JMP     ??OSFlagDel_7
//  334     } else {
//  335         tasks_waiting = OS_FALSE;                          /* No                                       */
??OSFlagDel_6:
        MOV.B   #0x0, R8
//  336     }
//  337     switch (opt) {
??OSFlagDel_7:
        MOV.B   R4, R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagDel_8
        SUB.B   #0x1, R14
        JEQ     ??OSFlagDel_9
        JMP     ??OSFlagDel_10
//  338         case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
//  339              if (tasks_waiting == OS_FALSE) {
??OSFlagDel_8:
        CMP.B   #0x0, R8
        JNE     ??OSFlagDel_11
//  340 #if OS_FLAG_NAME_EN > 0u
//  341                  pgrp->OSFlagName     = (INT8U *)(void *)"?";
        MOVX.A  #`?<Constant "?">`, 0x8(R10)
//  342 #endif
//  343                  pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R10)
//  344                  pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
        MOVX.A  &OSFlagFreeList, 0x2(R10)
//  345                  pgrp->OSFlagFlags    = (OS_FLAGS)0;
        MOV.W   #0x0, 0x6(R10)
//  346                  OSFlagFreeList       = pgrp;
        MOVA    R10, &OSFlagFreeList
//  347                  OS_EXIT_CRITICAL();
        MOV.W   R7, R12
        CALLA   #OSCPURestoreSR
//  348                  *perr                = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  349                  pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
        MOVA    #0x0, R6
        JMP     ??OSFlagDel_2
//  350              } else {
//  351                  OS_EXIT_CRITICAL();
??OSFlagDel_11:
        MOV.W   R7, R12
        CALLA   #OSCPURestoreSR
//  352                  *perr                = OS_ERR_TASK_WAITING;
        MOV.B   #0x49, 0(R11)
//  353                  pgrp_return          = pgrp;
        MOVA    R10, R6
//  354              }
//  355              break;
        JMP     ??OSFlagDel_2
//  356 
//  357         case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
//  358              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
??OSFlagDel_9:
        MOVA    0x2(R10), R9
//  359              while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
??OSFlagDel_0:
        CMPA    #0x0, R9
        JEQ     ??OSFlagDel_12
//  360                  (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
        MOV.W   #0x0, R13
        MOVA    R9, R12
        CALLA   #OS_FlagTaskRdy
//  361                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
        MOVA    @R9, R9
        JMP     ??OSFlagDel_0
//  362              }
//  363 #if OS_FLAG_NAME_EN > 0u
//  364              pgrp->OSFlagName     = (INT8U *)(void *)"?";
??OSFlagDel_12:
        MOVX.A  #`?<Constant "?">`, 0x8(R10)
//  365 #endif
//  366              pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R10)
//  367              pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
        MOVX.A  &OSFlagFreeList, 0x2(R10)
//  368              pgrp->OSFlagFlags    = (OS_FLAGS)0;
        MOV.W   #0x0, 0x6(R10)
//  369              OSFlagFreeList       = pgrp;
        MOVA    R10, &OSFlagFreeList
//  370              OS_EXIT_CRITICAL();
        MOV.W   R7, R12
        CALLA   #OSCPURestoreSR
//  371              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
        CMP.B   #0x1, R8
        JNE     ??OSFlagDel_13
//  372                  OS_Sched();                               /* Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  373              }
//  374              *perr = OS_ERR_NONE;
??OSFlagDel_13:
        MOV.B   #0x0, 0(R11)
//  375              pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
        MOVA    #0x0, R6
//  376              break;
        JMP     ??OSFlagDel_2
//  377 
//  378         default:
//  379              OS_EXIT_CRITICAL();
??OSFlagDel_10:
        MOV.W   R7, R12
        CALLA   #OSCPURestoreSR
//  380              *perr                = OS_ERR_INVALID_OPT;
        MOV.B   #0x7, 0(R11)
//  381              pgrp_return          = pgrp;
        MOVA    R10, R6
//  382              break;
//  383     }
//  384     return (pgrp_return);
??OSFlagDel_2:
        MOVA    R6, R12
??OSFlagDel_4:
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  385 }
//  386 #endif
//  387 /*$PAGE*/
//  388 /*
//  389 *********************************************************************************************************
//  390 *                                 GET THE NAME OF AN EVENT FLAG GROUP
//  391 *
//  392 * Description: This function is used to obtain the name assigned to an event flag group
//  393 *
//  394 * Arguments  : pgrp      is a pointer to the event flag group.
//  395 *
//  396 *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
//  397 *                        group.
//  398 *
//  399 *              perr      is a pointer to an error code that can contain one of the following values:
//  400 *
//  401 *                        OS_ERR_NONE                if the requested task is resumed
//  402 *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
//  403 *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
//  404 *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
//  405 *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
//  406 *
//  407 * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
//  408 *********************************************************************************************************
//  409 */
//  410 
//  411 #if OS_FLAG_NAME_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  412 INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
OSFlagNameGet:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function OSFlagNameGet
//  413                       INT8U        **pname,
//  414                       INT8U         *perr)
//  415 {
        FUNCALL OSFlagNameGet, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSFlagNameGet, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSFlagNameGet, OS_StrLen
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSFlagNameGet, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOVA    R13, R11
        MOVA    R14, R8
//  416     INT8U      len;
//  417 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//  418     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//  419 #endif
//  420 
//  421 
//  422 
//  423 #ifdef OS_SAFETY_CRITICAL
//  424     if (perr == (INT8U *)0) {
//  425         OS_SAFETY_CRITICAL_EXCEPTION();
//  426     }
//  427 #endif
//  428 
//  429 #if OS_ARG_CHK_EN > 0u
//  430     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
//  431         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  432         return (0u);
//  433     }
//  434     if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
//  435         *perr = OS_ERR_PNAME_NULL;
//  436         return (0u);
//  437     }
//  438 #endif
//  439     if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSFlagNameGet_0
//  440         *perr = OS_ERR_NAME_GET_ISR;
        MOV.B   #0x11, 0(R8)
//  441         return (0u);
        MOV.B   #0x0, R12
        JMP     ??OSFlagNameGet_1
//  442     }
//  443     OS_ENTER_CRITICAL();
??OSFlagNameGet_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  444     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
        CMP.B   #0x5, 0(R10)
        JEQ     ??OSFlagNameGet_2
//  445         OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  446         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R8)
//  447         return (0u);
        MOV.B   #0x0, R12
        JMP     ??OSFlagNameGet_1
//  448     }
//  449     *pname = pgrp->OSFlagName;
??OSFlagNameGet_2:
        MOVX.A  0x8(R10), 0(R11)
//  450     len    = OS_StrLen(*pname);
        MOVA    @R11, R12
        CALLA   #OS_StrLen
        MOV.B   R12, R9
//  451     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  452     *perr  = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  453     return (len);
        MOV.B   R9, R12
??OSFlagNameGet_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  454 }
//  455 #endif
//  456 
//  457 /*$PAGE*/
//  458 /*
//  459 *********************************************************************************************************
//  460 *                                 ASSIGN A NAME TO AN EVENT FLAG GROUP
//  461 *
//  462 * Description: This function assigns a name to an event flag group.
//  463 *
//  464 * Arguments  : pgrp      is a pointer to the event flag group.
//  465 *
//  466 *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
//  467 *                        group.
//  468 *
//  469 *              perr      is a pointer to an error code that can contain one of the following values:
//  470 *
//  471 *                        OS_ERR_NONE                if the requested task is resumed
//  472 *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
//  473 *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
//  474 *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
//  475 *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
//  476 *
//  477 * Returns    : None
//  478 *********************************************************************************************************
//  479 */
//  480 
//  481 #if OS_FLAG_NAME_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  482 void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
OSFlagNameSet:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function OSFlagNameSet
//  483                      INT8U        *pname,
//  484                      INT8U        *perr)
//  485 {
        FUNCALL OSFlagNameSet, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSFlagNameSet, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSFlagNameSet, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
        MOVA    R13, R11
        MOVA    R14, R8
//  486 #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
//  487     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  488 #endif
//  489 
//  490 
//  491 
//  492 #ifdef OS_SAFETY_CRITICAL
//  493     if (perr == (INT8U *)0) {
//  494         OS_SAFETY_CRITICAL_EXCEPTION();
//  495     }
//  496 #endif
//  497 
//  498 #if OS_ARG_CHK_EN > 0u
//  499     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
//  500         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  501         return;
//  502     }
//  503     if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
//  504         *perr = OS_ERR_PNAME_NULL;
//  505         return;
//  506     }
//  507 #endif
//  508     if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSFlagNameSet_0
//  509         *perr = OS_ERR_NAME_SET_ISR;
        MOV.B   #0x12, 0(R8)
//  510         return;
        JMP     ??OSFlagNameSet_1
//  511     }
//  512     OS_ENTER_CRITICAL();
??OSFlagNameSet_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  513     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
        CMP.B   #0x5, 0(R10)
        JEQ     ??OSFlagNameSet_2
//  514         OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  515         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R8)
//  516         return;
        JMP     ??OSFlagNameSet_1
//  517     }
//  518     pgrp->OSFlagName = pname;
??OSFlagNameSet_2:
        MOVA    R11, 0x8(R10)
//  519     OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  520     *perr            = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  521     return;
??OSFlagNameSet_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  522 }
//  523 #endif
//  524 
//  525 /*$PAGE*/
//  526 /*
//  527 *********************************************************************************************************
//  528 *                                        WAIT ON AN EVENT FLAG GROUP
//  529 *
//  530 * Description: This function is called to wait for a combination of bits to be set in an event flag
//  531 *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
//  532 *
//  533 * Arguments  : pgrp          is a pointer to the desired event flag group.
//  534 *
//  535 *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
//  536 *                            The bits you want are specified by setting the corresponding bits in
//  537 *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
//  538 *                            'flags' would contain 0x03.
//  539 *
//  540 *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
//  541 *                            You can specify the following argument:
//  542 *
//  543 *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
//  544 *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
//  545 *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
//  546 *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
//  547 *
//  548 *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
//  549 *                                  the call.  Example, to wait for any flag in a group AND then clear
//  550 *                                  the flags that are present, set 'wait_type' to:
//  551 *
//  552 *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
//  553 *
//  554 *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
//  555 *                            desired bit combination.  If you specify 0, however, your task will wait
//  556 *                            forever at the specified event flag group or, until a message arrives.
//  557 *
//  558 *              perr          is a pointer to an error code and can be:
//  559 *                            OS_ERR_NONE               The desired bits have been set within the specified
//  560 *                                                      'timeout'.
//  561 *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
//  562 *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
//  563 *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
//  564 *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
//  565 *                                                      'timeout'.
//  566 *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
//  567 *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
//  568 *
//  569 * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
//  570 *              occurred.
//  571 *
//  572 * Called from: Task ONLY
//  573 *
//  574 * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
//  575 *                 function NOW returns the flags that were ready INSTEAD of the current state of the
//  576 *                 event flags.
//  577 *********************************************************************************************************
//  578 */
//  579 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  580 OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
OSFlagPend:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function OSFlagPend
//  581                       OS_FLAGS      flags,
//  582                       INT8U         wait_type,
//  583                       INT32U        timeout,
//  584                       INT8U        *perr)
//  585 {
        FUNCALL OSFlagPend, OSCPUSaveSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_FlagBlock
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_FlagBlock
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_FlagBlock
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_FlagBlock
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 62, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_Sched
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OSCPUSaveSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OS_FlagUnlink
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        FUNCALL OSFlagPend, OSCPURestoreSR
        LOCFRAME CSTACK, 58, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUB.W   #0x16, SP
          CFI CFA SP+58
        MOVA    R12, R11
        MOV.W   R13, R10
        MOV.B   R14, R7
        MOVA    R15, R8
//  586     OS_FLAG_NODE  node;
//  587     OS_FLAGS      flags_rdy;
//  588     INT8U         result;
//  589     INT8U         pend_stat;
//  590     BOOLEAN       consume;
//  591 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  592     OS_CPU_SR     cpu_sr = 0u;
        MOV.W   #0x0, R6
//  593 #endif
//  594 
//  595 
//  596 
//  597 #ifdef OS_SAFETY_CRITICAL
//  598     if (perr == (INT8U *)0) {
//  599         OS_SAFETY_CRITICAL_EXCEPTION();
//  600     }
//  601 #endif
//  602 
//  603 #if OS_ARG_CHK_EN > 0u
//  604     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
//  605         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  606         return ((OS_FLAGS)0);
//  607     }
//  608 #endif
//  609     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSFlagPend_2
//  610         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
        MOV.B   #0x2, 0(R8)
//  611         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPend_3
//  612     }
//  613     if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
??OSFlagPend_2:
        CMPX.B  #0x0, &OSLockNesting
        JEQ     ??OSFlagPend_4
//  614         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
        MOV.B   #0xd, 0(R8)
//  615         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPend_3
//  616     }
//  617     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
??OSFlagPend_4:
        CMP.B   #0x5, 0(R11)
        JEQ     ??OSFlagPend_5
//  618         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R8)
//  619         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPend_3
//  620     }
//  621     result = (INT8U)(wait_type & OS_FLAG_CONSUME);
??OSFlagPend_5:
        MOV.B   R7, R14
        AND.B   #0x80, R14
        MOV.B   R14, 0(SP)
//  622     if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
        CMP.B   #0x0, 0(SP)
        JEQ     ??OSFlagPend_6
//  623         wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
        BIC.B   #0x80, R7
//  624         consume    = OS_TRUE;
        MOV.B   #0x1, R4
        JMP     ??OSFlagPend_7
//  625     } else {
//  626         consume    = OS_FALSE;
??OSFlagPend_6:
        MOV.B   #0x0, R4
//  627     }
//  628 /*$PAGE*/
//  629     OS_ENTER_CRITICAL();
??OSFlagPend_7:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  630     switch (wait_type) {
        MOV.B   R7, R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagPend_8
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPend_9
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPend_10
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPend_11
        JMP     ??OSFlagPend_12
//  631         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
//  632              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
??OSFlagPend_10:
        MOV.W   R10, R15
        AND.W   0x6(R11), R15
        MOV.W   R15, R9
//  633              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
        CMP.W   R10, R9
        JNE     ??OSFlagPend_13
//  634                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R4
        JNE     ??OSFlagPend_14
//  635                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
        BIC.W   R9, 0x6(R11)
//  636                  }
//  637                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
??OSFlagPend_14:
        MOVA    &OSTCBCur, R15
        MOV.W   R9, 0x28(R15)
//  638                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  639                  *perr                   = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  640                  return (flags_rdy);
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  641              } else {                                      /* Block task until events occur or timeout */
//  642                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
??OSFlagPend_13:
        PUSH.W  0x3e(SP)
          CFI CFA SP+60
        PUSH.W  0x3e(SP)
          CFI CFA SP+62
        MOV.B   R7, R15
        MOV.W   R10, R14
        MOV.W   SP, R13
        ADD.W   #0x6, R13
        MOVA    R11, R12
        CALLA   #OS_FlagBlock
//  643                  OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  644              }
//  645              break;
        ADD.W   #0x4, SP
          CFI CFA SP+58
        JMP     ??OSFlagPend_15
//  646 
//  647         case OS_FLAG_WAIT_SET_ANY:
//  648              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
??OSFlagPend_11:
        MOV.W   R10, R15
        AND.W   0x6(R11), R15
        MOV.W   R15, R9
//  649              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
        CMP.W   #0x0, R9
        JEQ     ??OSFlagPend_16
//  650                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R4
        JNE     ??OSFlagPend_17
//  651                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
        BIC.W   R9, 0x6(R11)
//  652                  }
//  653                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
??OSFlagPend_17:
        MOVA    &OSTCBCur, R15
        MOV.W   R9, 0x28(R15)
//  654                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  655                  *perr                   = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  656                  return (flags_rdy);
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  657              } else {                                      /* Block task until events occur or timeout */
//  658                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
??OSFlagPend_16:
        PUSH.W  0x3e(SP)
          CFI CFA SP+60
        PUSH.W  0x3e(SP)
          CFI CFA SP+62
        MOV.B   R7, R15
        MOV.W   R10, R14
        MOV.W   SP, R13
        ADD.W   #0x6, R13
        MOVA    R11, R12
        CALLA   #OS_FlagBlock
//  659                  OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  660              }
//  661              break;
        ADD.W   #0x4, SP
          CFI CFA SP+58
        JMP     ??OSFlagPend_15
//  662 
//  663 #if OS_FLAG_WAIT_CLR_EN > 0u
//  664         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
//  665              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
??OSFlagPend_8:
        MOV.W   R10, R15
        BIC.W   0x6(R11), R15
        MOV.W   R15, R9
//  666              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
        CMP.W   R10, R9
        JNE     ??OSFlagPend_18
//  667                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R4
        JNE     ??OSFlagPend_19
//  668                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
        BIS.W   R9, 0x6(R11)
//  669                  }
//  670                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
??OSFlagPend_19:
        MOVA    &OSTCBCur, R15
        MOV.W   R9, 0x28(R15)
//  671                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  672                  *perr                   = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  673                  return (flags_rdy);
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  674              } else {                                      /* Block task until events occur or timeout */
//  675                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
??OSFlagPend_18:
        PUSH.W  0x3e(SP)
          CFI CFA SP+60
        PUSH.W  0x3e(SP)
          CFI CFA SP+62
        MOV.B   R7, R15
        MOV.W   R10, R14
        MOV.W   SP, R13
        ADD.W   #0x6, R13
        MOVA    R11, R12
        CALLA   #OS_FlagBlock
//  676                  OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  677              }
//  678              break;
        ADD.W   #0x4, SP
          CFI CFA SP+58
        JMP     ??OSFlagPend_15
//  679 
//  680         case OS_FLAG_WAIT_CLR_ANY:
//  681              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
??OSFlagPend_9:
        MOV.W   R10, R15
        BIC.W   0x6(R11), R15
        MOV.W   R15, R9
//  682              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
        CMP.W   #0x0, R9
        JEQ     ??OSFlagPend_20
//  683                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
        CMP.B   #0x1, R4
        JNE     ??OSFlagPend_21
//  684                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
        BIS.W   R9, 0x6(R11)
//  685                  }
//  686                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
??OSFlagPend_21:
        MOVA    &OSTCBCur, R15
        MOV.W   R9, 0x28(R15)
//  687                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  688                  *perr                   = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  689                  return (flags_rdy);
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  690              } else {                                      /* Block task until events occur or timeout */
//  691                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
??OSFlagPend_20:
        PUSH.W  0x3e(SP)
          CFI CFA SP+60
        PUSH.W  0x3e(SP)
          CFI CFA SP+62
        MOV.B   R7, R15
        MOV.W   R10, R14
        MOV.W   SP, R13
        ADD.W   #0x6, R13
        MOVA    R11, R12
        CALLA   #OS_FlagBlock
//  692                  OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  693              }
//  694              break;
        ADD.W   #0x4, SP
          CFI CFA SP+58
        JMP     ??OSFlagPend_15
//  695 #endif
//  696 
//  697         default:
//  698              OS_EXIT_CRITICAL();
??OSFlagPend_12:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  699              flags_rdy = (OS_FLAGS)0;
        MOV.W   #0x0, R9
//  700              *perr      = OS_ERR_FLAG_WAIT_TYPE;
        MOV.B   #0x6f, 0(R8)
//  701              return (flags_rdy);
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  702     }
//  703 /*$PAGE*/
//  704     OS_Sched();                                            /* Find next HPT ready to run               */
??OSFlagPend_15:
        CALLA   #OS_Sched
//  705     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  706     if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
        MOVA    &OSTCBCur, R15
        CMP.B   #0x0, 0x2f(R15)
        JEQ     ??OSFlagPend_22
//  707         pend_stat                = OSTCBCur->OSTCBStatPend;
        MOVA    &OSTCBCur, R15
        MOV.B   0x2f(R15), R5
//  708         OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  709         OS_FlagUnlink(&node);
        MOV.W   SP, R12
        ADD.W   #0x2, R12
        CALLA   #OS_FlagUnlink
//  710         OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2e(R15)
//  711         OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  712         flags_rdy                = (OS_FLAGS)0;
        MOV.W   #0x0, R9
//  713         switch (pend_stat) {
        CMP.B   #0x2, R5
        JNE     ??OSFlagPend_23
//  714             case OS_STAT_PEND_ABORT:
//  715                  *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
        MOV.B   #0xe, 0(R8)
//  716                  break;
        JMP     ??OSFlagPend_24
//  717 
//  718             case OS_STAT_PEND_TO:
//  719             default:
//  720                  *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
??OSFlagPend_23:
        MOV.B   #0xa, 0(R8)
//  721                  break;
//  722         }
//  723         return (flags_rdy);
??OSFlagPend_24:
        MOV.W   R9, R12
        JMP     ??OSFlagPend_3
//  724     }
//  725     flags_rdy = OSTCBCur->OSTCBFlagsRdy;
??OSFlagPend_22:
        MOVA    &OSTCBCur, R15
        MOV.W   0x28(R15), R9
//  726     if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
        CMP.B   #0x1, R4
        JNE     ??OSFlagPend_25
//  727         switch (wait_type) {
        MOV.B   R7, R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagPend_26
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPend_26
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPend_0
        SUB.B   #0x1, R14
        JNE     ??OSFlagPend_1
//  728             case OS_FLAG_WAIT_SET_ALL:
//  729             case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
//  730                  pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
??OSFlagPend_0:
        BIC.W   R9, 0x6(R11)
//  731                  break;
        JMP     ??OSFlagPend_25
//  732 
//  733 #if OS_FLAG_WAIT_CLR_EN > 0u
//  734             case OS_FLAG_WAIT_CLR_ALL:
//  735             case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
//  736                  pgrp->OSFlagFlags |=  flags_rdy;
??OSFlagPend_26:
        BIS.W   R9, 0x6(R11)
//  737                  break;
        JMP     ??OSFlagPend_25
//  738 #endif
//  739             default:
//  740                  OS_EXIT_CRITICAL();
??OSFlagPend_1:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  741                  *perr = OS_ERR_FLAG_WAIT_TYPE;
        MOV.B   #0x6f, 0(R8)
//  742                  return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPend_3
//  743         }
//  744     }
//  745     OS_EXIT_CRITICAL();
??OSFlagPend_25:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  746     *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
        MOV.B   #0x0, 0(R8)
//  747     return (flags_rdy);
        MOV.W   R9, R12
??OSFlagPend_3:
        ADD.W   #0x16, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  748 }
//  749 /*$PAGE*/
//  750 /*
//  751 *********************************************************************************************************
//  752 *                               GET FLAGS WHO CAUSED TASK TO BECOME READY
//  753 *
//  754 * Description: This function is called to obtain the flags that caused the task to become ready to run.
//  755 *              In other words, this function allows you to tell "Who done it!".
//  756 *
//  757 * Arguments  : None
//  758 *
//  759 * Returns    : The flags that caused the task to be ready.
//  760 *
//  761 * Called from: Task ONLY
//  762 *********************************************************************************************************
//  763 */
//  764 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  765 OS_FLAGS  OSFlagPendGetFlagsRdy (void)
OSFlagPendGetFlagsRdy:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function OSFlagPendGetFlagsRdy
//  766 {
        FUNCALL OSFlagPendGetFlagsRdy, OSCPUSaveSR
        LOCFRAME CSTACK, 12, STACK
        FUNCALL OSFlagPendGetFlagsRdy, OSCPURestoreSR
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  767     OS_FLAGS      flags;
//  768 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  769     OS_CPU_SR     cpu_sr = 0u;
        MOV.W   #0x0, R11
//  770 #endif
//  771 
//  772 
//  773 
//  774     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R11
//  775     flags = OSTCBCur->OSTCBFlagsRdy;
        MOVA    &OSTCBCur, R15
        MOV.W   0x28(R15), R10
//  776     OS_EXIT_CRITICAL();
        MOV.W   R11, R12
        CALLA   #OSCPURestoreSR
//  777     return (flags);
        MOV.W   R10, R12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  778 }
//  779 
//  780 /*$PAGE*/
//  781 /*
//  782 *********************************************************************************************************
//  783 *                                         POST EVENT FLAG BIT(S)
//  784 *
//  785 * Description: This function is called to set or clear some bits in an event flag group.  The bits to
//  786 *              set or clear are specified by a 'bit mask'.
//  787 *
//  788 * Arguments  : pgrp          is a pointer to the desired event flag group.
//  789 *
//  790 *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
//  791 *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
//  792 *                            and 5 you would set 'flags' to:
//  793 *
//  794 *                                0x31     (note, bit 0 is least significant bit)
//  795 *
//  796 *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
//  797 *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
//  798 *                            4 and 5 you would specify 'flags' as:
//  799 *
//  800 *                                0x31     (note, bit 0 is least significant bit)
//  801 *
//  802 *              opt           indicates whether the flags will be:
//  803 *                                set     (OS_FLAG_SET) or
//  804 *                                cleared (OS_FLAG_CLR)
//  805 *
//  806 *              perr          is a pointer to an error code and can be:
//  807 *                            OS_ERR_NONE                The call was successfull
//  808 *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
//  809 *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
//  810 *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
//  811 *
//  812 * Returns    : the new value of the event flags bits that are still set.
//  813 *
//  814 * Called From: Task or ISR
//  815 *
//  816 * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
//  817 *                 flag group.
//  818 *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
//  819 *                 the event flag group.
//  820 *********************************************************************************************************
//  821 */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  822 OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
OSFlagPost:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function OSFlagPost
//  823                       OS_FLAGS      flags,
//  824                       INT8U         opt,
//  825                       INT8U        *perr)
//  826 {
        FUNCALL OSFlagPost, OSCPUSaveSR
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OSCPURestoreSR
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OS_FlagTaskRdy
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OS_FlagTaskRdy
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OS_FlagTaskRdy
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OS_FlagTaskRdy
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OSCPURestoreSR
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OSCPURestoreSR
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OS_Sched
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OSCPUSaveSR
        LOCFRAME CSTACK, 40, STACK
        FUNCALL OSFlagPost, OSCPURestoreSR
        LOCFRAME CSTACK, 40, STACK
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        PUSH.B  R14
          CFI CFA SP+38
        SUB.W   #0x2, SP
          CFI CFA SP+40
        MOVA    R12, R10
        MOV.W   R13, R5
        MOVA    R15, R4
//  827     OS_FLAG_NODE *pnode;
//  828     BOOLEAN       sched;
//  829     OS_FLAGS      flags_cur;
//  830     OS_FLAGS      flags_rdy;
//  831     BOOLEAN       rdy;
//  832 #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
//  833     OS_CPU_SR     cpu_sr = 0u;
        MOV.W   #0x0, R6
//  834 #endif
//  835 
//  836 
//  837 
//  838 #ifdef OS_SAFETY_CRITICAL
//  839     if (perr == (INT8U *)0) {
//  840         OS_SAFETY_CRITICAL_EXCEPTION();
//  841     }
//  842 #endif
//  843 
//  844 #if OS_ARG_CHK_EN > 0u
//  845     if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
//  846         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  847         return ((OS_FLAGS)0);
//  848     }
//  849 #endif
//  850     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
        CMP.B   #0x5, 0(R10)
        JEQ     ??OSFlagPost_6
//  851         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R4)
//  852         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPost_7
//  853     }
//  854 /*$PAGE*/
//  855     OS_ENTER_CRITICAL();
??OSFlagPost_6:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  856     switch (opt) {
        MOV.B   0x2(SP), R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagPost_8
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPost_9
        JMP     ??OSFlagPost_10
//  857         case OS_FLAG_CLR:
//  858              pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
??OSFlagPost_8:
        BIC.W   R5, 0x6(R10)
//  859              break;
        JMP     ??OSFlagPost_11
//  860 
//  861         case OS_FLAG_SET:
//  862              pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
??OSFlagPost_9:
        BIS.W   R5, 0x6(R10)
//  863              break;
        JMP     ??OSFlagPost_11
//  864 
//  865         default:
//  866              OS_EXIT_CRITICAL();                     /* INVALID option                                 */
??OSFlagPost_10:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  867              *perr = OS_ERR_FLAG_INVALID_OPT;
        MOV.B   #0x71, 0(R4)
//  868              return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPost_7
//  869     }
//  870     sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
??OSFlagPost_11:
        MOV.B   #0x0, R7
//  871     pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
        MOVA    0x2(R10), R11
//  872     while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
??OSFlagPost_0:
        CMPA    #0x0, R11
        JEQ     ??OSFlagPost_12
//  873         switch (pnode->OSFlagNodeWaitType) {
        MOV.B   0x12(R11), R14
        SUB.B   #0x0, R14
        JEQ     ??OSFlagPost_13
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPost_14
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPost_15
        SUB.B   #0x1, R14
        JEQ     ??OSFlagPost_16
        JMP     ??OSFlagPost_17
//  874             case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
//  875                  flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
??OSFlagPost_15:
        MOV.W   0x6(R10), R15
        AND.W   0x10(R11), R15
        MOV.W   R15, R8
//  876                  if (flags_rdy == pnode->OSFlagNodeFlags) {
        CMP.W   0x10(R11), R8
        JNE     ??OSFlagPost_2
//  877                      rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
        MOV.W   R8, R13
        MOVA    R11, R12
        CALLA   #OS_FlagTaskRdy
        MOV.B   R12, R9
//  878                      if (rdy == OS_TRUE) {
        CMP.B   #0x1, R9
        JNE     ??OSFlagPost_2
//  879                          sched = OS_TRUE;                     /* When done we will reschedule          */
        MOV.B   #0x1, R7
//  880                      }
//  881                  }
//  882                  break;
        JMP     ??OSFlagPost_2
//  883 
//  884             case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
//  885                  flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
??OSFlagPost_16:
        MOV.W   0x6(R10), R15
        AND.W   0x10(R11), R15
        MOV.W   R15, R8
//  886                  if (flags_rdy != (OS_FLAGS)0) {
        CMP.W   #0x0, R8
        JEQ     ??OSFlagPost_2
//  887                      rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
        MOV.W   R8, R13
        MOVA    R11, R12
        CALLA   #OS_FlagTaskRdy
        MOV.B   R12, R9
//  888                      if (rdy == OS_TRUE) {
        CMP.B   #0x1, R9
        JNE     ??OSFlagPost_2
//  889                          sched = OS_TRUE;                     /* When done we will reschedule          */
        MOV.B   #0x1, R7
//  890                      }
//  891                  }
//  892                  break;
        JMP     ??OSFlagPost_2
//  893 
//  894 #if OS_FLAG_WAIT_CLR_EN > 0u
//  895             case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
//  896                  flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
??OSFlagPost_13:
        MOV.W   0x10(R11), R15
        BIC.W   0x6(R10), R15
        MOV.W   R15, R8
//  897                  if (flags_rdy == pnode->OSFlagNodeFlags) {
        CMP.W   0x10(R11), R8
        JNE     ??OSFlagPost_2
//  898                      rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
        MOV.W   R8, R13
        MOVA    R11, R12
        CALLA   #OS_FlagTaskRdy
        MOV.B   R12, R9
//  899                      if (rdy == OS_TRUE) {
        CMP.B   #0x1, R9
        JNE     ??OSFlagPost_2
//  900                          sched = OS_TRUE;                     /* When done we will reschedule          */
        MOV.B   #0x1, R7
//  901                      }
//  902                  }
//  903                  break;
        JMP     ??OSFlagPost_2
//  904 
//  905             case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
//  906                  flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
??OSFlagPost_14:
        MOV.W   0x10(R11), R15
        BIC.W   0x6(R10), R15
        MOV.W   R15, R8
//  907                  if (flags_rdy != (OS_FLAGS)0) {
        CMP.W   #0x0, R8
        JEQ     ??OSFlagPost_2
//  908                      rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
        MOV.W   R8, R13
        MOVA    R11, R12
        CALLA   #OS_FlagTaskRdy
        MOV.B   R12, R9
//  909                      if (rdy == OS_TRUE) {
        CMP.B   #0x1, R9
        JNE     ??OSFlagPost_2
//  910                          sched = OS_TRUE;                     /* When done we will reschedule          */
        MOV.B   #0x1, R7
//  911                      }
//  912                  }
//  913                  break;
        JMP     ??OSFlagPost_2
//  914 #endif
//  915             default:
//  916                  OS_EXIT_CRITICAL();
??OSFlagPost_17:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  917                  *perr = OS_ERR_FLAG_WAIT_TYPE;
        MOV.B   #0x6f, 0(R4)
//  918                  return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagPost_7
//  919         }
//  920         pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
??OSFlagPost_2:
        MOVA    @R11, R11
        JMP     ??OSFlagPost_0
//  921     }
//  922     OS_EXIT_CRITICAL();
??OSFlagPost_12:
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  923     if (sched == OS_TRUE) {
        CMP.B   #0x1, R7
        JNE     ??OSFlagPost_18
//  924         OS_Sched();
        CALLA   #OS_Sched
//  925     }
//  926     OS_ENTER_CRITICAL();
??OSFlagPost_18:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  927     flags_cur = pgrp->OSFlagFlags;
        MOV.W   0x6(R10), 0(SP)
//  928     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  929     *perr     = OS_ERR_NONE;
        MOV.B   #0x0, 0(R4)
//  930     return (flags_cur);
        MOV.W   @SP, R12
??OSFlagPost_7:
        ADD.W   #0x4, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  931 }
//  932 /*$PAGE*/
//  933 /*
//  934 *********************************************************************************************************
//  935 *                                           QUERY EVENT FLAG
//  936 *
//  937 * Description: This function is used to check the value of the event flag group.
//  938 *
//  939 * Arguments  : pgrp         is a pointer to the desired event flag group.
//  940 *
//  941 *              perr          is a pointer to an error code returned to the called:
//  942 *                            OS_ERR_NONE                The call was successfull
//  943 *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
//  944 *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
//  945 *
//  946 * Returns    : The current value of the event flag group.
//  947 *
//  948 * Called From: Task or ISR
//  949 *********************************************************************************************************
//  950 */
//  951 
//  952 #if OS_FLAG_QUERY_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  953 OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
OSFlagQuery:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function OSFlagQuery
//  954                        INT8U        *perr)
//  955 {
        FUNCALL OSFlagQuery, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSFlagQuery, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
        MOVA    R13, R11
//  956     OS_FLAGS   flags;
//  957 #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
//  958     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  959 #endif
//  960 
//  961 
//  962 
//  963 #ifdef OS_SAFETY_CRITICAL
//  964     if (perr == (INT8U *)0) {
//  965         OS_SAFETY_CRITICAL_EXCEPTION();
//  966     }
//  967 #endif
//  968 
//  969 #if OS_ARG_CHK_EN > 0u
//  970     if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
//  971         *perr = OS_ERR_FLAG_INVALID_PGRP;
//  972         return ((OS_FLAGS)0);
//  973     }
//  974 #endif
//  975     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
        CMP.B   #0x5, 0(R10)
        JEQ     ??OSFlagQuery_0
//  976         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  977         return ((OS_FLAGS)0);
        MOV.W   #0x0, R12
        JMP     ??OSFlagQuery_1
//  978     }
//  979     OS_ENTER_CRITICAL();
??OSFlagQuery_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  980     flags = pgrp->OSFlagFlags;
        MOV.W   0x6(R10), R8
//  981     OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  982     *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  983     return (flags);                               /* Return the current value of the event flags       */
        MOV.W   R8, R12
??OSFlagQuery_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  984 }
//  985 #endif
//  986 
//  987 /*$PAGE*/
//  988 /*
//  989 *********************************************************************************************************
//  990 *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
//  991 *
//  992 * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
//  993 *              event flag bit(s) are set.
//  994 *
//  995 * Arguments  : pgrp          is a pointer to the desired event flag group.
//  996 *
//  997 *              pnode         is a pointer to a structure which contains data about the task waiting for
//  998 *                            event flag bit(s) to be set.
//  999 *
// 1000 *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
// 1001 *                            The bits you want are specified by setting the corresponding bits in
// 1002 *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
// 1003 *                            'flags' would contain 0x03.
// 1004 *
// 1005 *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
// 1006 *                            to be set/cleared.
// 1007 *                            You can specify the following argument:
// 1008 *
// 1009 *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
// 1010 *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
// 1011 *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
// 1012 *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
// 1013 *
// 1014 *              timeout       is the desired amount of time that the task will wait for the event flag
// 1015 *                            bit(s) to be set.
// 1016 *
// 1017 * Returns    : none
// 1018 *
// 1019 * Called by  : OSFlagPend()  OS_FLAG.C
// 1020 *
// 1021 * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
// 1022 *********************************************************************************************************
// 1023 */
// 1024 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1025 static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
OS_FlagBlock:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function OS_FlagBlock
// 1026                             OS_FLAG_NODE *pnode,
// 1027                             OS_FLAGS      flags,
// 1028                             INT8U         wait_type,
// 1029                             INT32U        timeout)
// 1030 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOV.W   0x1c(SP), R10
        MOV.W   0x1e(SP), R11
// 1031     OS_FLAG_NODE  *pnode_next;
// 1032     INT8U          y;
// 1033 
// 1034 
// 1035     OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
        MOVA    &OSTCBCur, R6
        BIS.B   #0x20, 0x2e(R6)
// 1036     OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
        MOVA    &OSTCBCur, R6
        MOV.B   #0x0, 0x2f(R6)
// 1037     OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
        MOVA    &OSTCBCur, R6
        MOV.W   R10, 0x2a(R6)
        MOV.W   R11, 0x2c(R6)
// 1038 #if OS_TASK_DEL_EN > 0u
// 1039     OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
        MOVA    &OSTCBCur, R6
        MOVA    R13, 0x24(R6)
// 1040 #endif
// 1041     pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
        MOV.W   R14, 0x10(R13)
// 1042     pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
        MOV.B   R15, 0x12(R13)
// 1043     pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
        MOVX.A  &OSTCBCur, 0x8(R13)
// 1044     pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
        MOVX.A  0x2(R12), 0(R13)
// 1045     pnode->OSFlagNodePrev     = (void *)0;
        MOVX.A  #0x0, 0x4(R13)
// 1046     pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
        MOVA    R12, 0xc(R13)
// 1047     pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
        MOVA    0x2(R12), R9
// 1048     if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
        CMPA    #0x0, R9
        JEQ     ??OS_FlagBlock_0
// 1049         pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
        MOVA    R13, 0x4(R9)
// 1050     }
// 1051     pgrp->OSFlagWaitList = (void *)pnode;
??OS_FlagBlock_0:
        MOVA    R13, 0x2(R12)
// 1052 
// 1053     y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
        MOVA    &OSTCBCur, R6
        MOV.B   0x32(R6), R8
// 1054     OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
        MOV.B   R8, R6
        MOVA    &OSTCBCur, R7
        BICX.B  0x33(R7), OSRdyTbl(R6)
// 1055     if (OSRdyTbl[y] == 0x00u) {
        MOV.B   R8, R7
        CMPX.B  #0x0, OSRdyTbl(R7)
        JNE     ??OS_FlagBlock_1
// 1056         OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
        MOVA    &OSTCBCur, R7
        BICX.B  0x34(R7), &OSRdyGrp
// 1057     }
// 1058 }
??OS_FlagBlock_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
// 1059 
// 1060 /*$PAGE*/
// 1061 /*
// 1062 *********************************************************************************************************
// 1063 *                                    INITIALIZE THE EVENT FLAG MODULE
// 1064 *
// 1065 * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
// 1066 *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
// 1067 *
// 1068 * Arguments  : none
// 1069 *
// 1070 * Returns    : none
// 1071 *
// 1072 * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
// 1073 *********************************************************************************************************
// 1074 */
// 1075 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1076 void  OS_FlagInit (void)
OS_FlagInit:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function OS_FlagInit
// 1077 {
        FUNCALL OS_FlagInit, OS_MemClr
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
// 1078 #if OS_MAX_FLAGS == 1u
// 1079     OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
// 1080     OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
// 1081     OSFlagFreeList->OSFlagWaitList = (void *)0;
// 1082     OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
// 1083 #if OS_FLAG_NAME_EN > 0u
// 1084     OSFlagFreeList->OSFlagName     = (INT8U *)"?";
// 1085 #endif
// 1086 #endif
// 1087 
// 1088 #if OS_MAX_FLAGS >= 2u
// 1089     INT16U        ix;
// 1090     INT16U        ix_next;
// 1091     OS_FLAG_GRP  *pgrp1;
// 1092     OS_FLAG_GRP  *pgrp2;
// 1093 
// 1094 
// 1095     OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
        MOV.W   #0x3c, R13
        MOVA    #OSFlagTbl, R12
        CALLA   #OS_MemClr
// 1096     for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
        MOV.W   #0x0, R10
??OS_FlagInit_0:
        CMP.W   #0x4, R10
        JC      ??OS_FlagInit_1
// 1097         ix_next = ix + 1u;
        MOV.W   R10, R15
        ADD.W   #0x1, R15
        MOV.W   R15, R11
// 1098         pgrp1 = &OSFlagTbl[ix];
        MOV.W   R10, R15
        RLAM.A  #0x2, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSFlagTbl, R15
        MOVA    R15, R8
// 1099         pgrp2 = &OSFlagTbl[ix_next];
        MOV.W   R11, R15
        RLAM.A  #0x2, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSFlagTbl, R15
        MOVA    R15, R9
// 1100         pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R8)
// 1101         pgrp1->OSFlagWaitList = (void *)pgrp2;
        MOVA    R9, 0x2(R8)
// 1102 #if OS_FLAG_NAME_EN > 0u
// 1103         pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
        MOVX.A  #`?<Constant "?">`, 0x8(R8)
// 1104 #endif
// 1105     }
        ADD.W   #0x1, R10
        JMP     ??OS_FlagInit_0
// 1106     pgrp1                 = &OSFlagTbl[ix];
??OS_FlagInit_1:
        MOV.W   R10, R15
        RLAM.A  #0x2, R15
        MOVA    R15, R14
        ADDA    R15, R15
        ADDA    R14, R15
        ADDA    #OSFlagTbl, R15
        MOVA    R15, R8
// 1107     pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R8)
// 1108     pgrp1->OSFlagWaitList = (void *)0;
        MOVX.A  #0x0, 0x2(R8)
// 1109 #if OS_FLAG_NAME_EN > 0u
// 1110     pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
        MOVX.A  #`?<Constant "?">`, 0x8(R8)
// 1111 #endif
// 1112     OSFlagFreeList        = &OSFlagTbl[0];
        MOVX.A  #OSFlagTbl, &OSFlagFreeList
// 1113 #endif
// 1114 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
// 1115 
// 1116 /*$PAGE*/
// 1117 /*
// 1118 *********************************************************************************************************
// 1119 *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
// 1120 *
// 1121 * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
// 1122 *              desired event flag bits have been set.
// 1123 *
// 1124 * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
// 1125 *                            event flag bit(s) to be set.
// 1126 *
// 1127 *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
// 1128 *                            ready-to-run.
// 1129 *
// 1130 * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
// 1131 *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
// 1132 *
// 1133 * Called by  : OSFlagsPost() OS_FLAG.C
// 1134 *
// 1135 * Note(s)    : 1) This function assumes that interrupts are disabled.
// 1136 *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
// 1137 *********************************************************************************************************
// 1138 */
// 1139 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1140 static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
OS_FlagTaskRdy:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function OS_FlagTaskRdy
// 1141                                  OS_FLAGS      flags_rdy)
// 1142 {
        FUNCALL OS_FlagTaskRdy, OS_FlagUnlink
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R8
        MOV.W   R13, R10
// 1143     OS_TCB   *ptcb;
// 1144     BOOLEAN   sched;
// 1145 
// 1146 
// 1147     ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
        MOVA    0x8(R8), R9
// 1148     ptcb->OSTCBDly       = 0u;
        MOV.W   #0x0, 0x2a(R9)
        MOV.W   #0x0, 0x2c(R9)
// 1149     ptcb->OSTCBFlagsRdy  = flags_rdy;
        MOV.W   R10, 0x28(R9)
// 1150     ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
        MOVA    R9, R15
        BIC.B   #0x20, 0x2e(R15)
// 1151     ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
        MOV.B   #0x0, 0x2f(R9)
// 1152     if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
        CMP.B   #0x0, 0x2e(R9)
        JNE     ??OS_FlagTaskRdy_0
// 1153         OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
        BISX.B  0x34(R9), &OSRdyGrp
// 1154         OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        MOV.B   0x32(R9), R15
        MOV.B   R15, R15
        BISX.B  0x33(R9), OSRdyTbl(R15)
// 1155         sched                   = OS_TRUE;
        MOV.B   #0x1, R11
        JMP     ??OS_FlagTaskRdy_1
// 1156     } else {
// 1157         sched                   = OS_FALSE;
??OS_FlagTaskRdy_0:
        MOV.B   #0x0, R11
// 1158     }
// 1159     OS_FlagUnlink(pnode);
??OS_FlagTaskRdy_1:
        MOVA    R8, R12
        CALLA   #OS_FlagUnlink
// 1160     return (sched);
        MOV.B   R11, R12
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
// 1161 }
// 1162 
// 1163 /*$PAGE*/
// 1164 /*
// 1165 *********************************************************************************************************
// 1166 *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
// 1167 *
// 1168 * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
// 1169 *              list of tasks waiting for the event flag.
// 1170 *
// 1171 * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
// 1172 *                            event flag bit(s) to be set.
// 1173 *
// 1174 * Returns    : none
// 1175 *
// 1176 * Called by  : OS_FlagTaskRdy() OS_FLAG.C
// 1177 *              OSFlagPend()     OS_FLAG.C
// 1178 *              OSTaskDel()      OS_TASK.C
// 1179 *
// 1180 * Note(s)    : 1) This function assumes that interrupts are disabled.
// 1181 *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
// 1182 *********************************************************************************************************
// 1183 */
// 1184 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1185 void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
OS_FlagUnlink:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function OS_FlagUnlink
// 1186 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
// 1187 #if OS_TASK_DEL_EN > 0u
// 1188     OS_TCB       *ptcb;
// 1189 #endif
// 1190     OS_FLAG_GRP  *pgrp;
// 1191     OS_FLAG_NODE *pnode_prev;
// 1192     OS_FLAG_NODE *pnode_next;
// 1193 
// 1194 
// 1195     pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
        MOVA    0x4(R12), R13
// 1196     pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
        MOVA    @R12, R10
// 1197     if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        CMPA    #0x0, R13
        JNE     ??OS_FlagUnlink_0
// 1198         pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        MOVA    0xc(R12), R14
// 1199         pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        MOVA    R10, 0x2(R14)
// 1200         if (pnode_next != (OS_FLAG_NODE *)0) {
        CMPA    #0x0, R10
        JEQ     ??OS_FlagUnlink_1
// 1201             pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
        MOVX.A  #0x0, 0x4(R10)
        JMP     ??OS_FlagUnlink_1
// 1202         }
// 1203     } else {                                                    /* No,  A node somewhere in the list   */
// 1204         pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
??OS_FlagUnlink_0:
        MOVA    R10, 0(R13)
// 1205         if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
        CMPA    #0x0, R10
        JEQ     ??OS_FlagUnlink_1
// 1206             pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
        MOVA    R13, 0x4(R10)
// 1207         }
// 1208     }
// 1209 #if OS_TASK_DEL_EN > 0u
// 1210     ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
??OS_FlagUnlink_1:
        MOVA    0x8(R12), R15
// 1211     ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
        MOVX.A  #0x0, 0x24(R15)
// 1212 #endif
// 1213 }
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock12

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
`?<Constant "?">`:
        DC8 "?"

        END
// 1214 #endif
// 1215 	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
// 
// 2 130 bytes in segment CODE
//     2 bytes in segment DATA20_C
// 
// 2 130 bytes of CODE  memory
//     2 bytes of CONST memory
//
//Errors: none
//Warnings: 11
