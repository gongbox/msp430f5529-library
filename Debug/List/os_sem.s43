///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      18/Nov/2016  17:24:55 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_sem.c                                         /
//    Command line  =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\os_sem.c -D DEBUG -D RAM_VECTOR -lA              /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \ -o E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug /
//                     \Obj\ --no_cse --no_unroll --no_inline                 /
//                     --no_code_motion --no_tbaa --debug -D__MSP430F5529__   /
//                     -e --double=32 --dlib_config "D:\Program Files\IAR     /
//                     Systems\Embedded Workbench 6.4                         /
//                     Evaluation\430\LIB\DLIB\dl430xlff.h" -I                /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\in /
//                     c\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Driv /
//                     ers\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\Drivers\src\USB\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I             /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\ /
//                     ¹¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_HID_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Drivers\sr /
//                     c\USB\USB_API\USB_MSC_API\ -I                          /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\  /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWar /
//                     e\delay\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\HardWare\18b20\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\KEY\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     ED\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Har /
//                     dWare\12864\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\HardWare\oled\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6 /
//                     \C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc\ -I                 /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\m /
//                     pu6050\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³Ì /
//                     Ä£°å\HardWare\nokia5110\inc\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\n /
//                     okia5110\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤ /
//                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                         /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\HardWare\L /
//                     CD_API\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å /
//                     \HardWare\2.2TFT\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C° /
//                     æ\¹¤³ÌÄ£°å\HardWare\nrf24l01\ -I                       /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\    /
//                     -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\System\ /
//                     inc\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Sy /
//                     stem\src\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£ /
//                     °å\User\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£° /
//                     å\User\USER\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ /
//                     ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII /
//                     \App\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\L /
//                     ib\uCOSII\CONFIHG\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C /
//                     °æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                        /
//                     E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII /
//                     \CORE\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\ /
//                     Lib\FatFs\ -I E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ /
//                     £°å\Lib\FatFs\option\ --core=430X --data_model=large   /
//                     -On --multiplier=32 --multiplier_location=4C0          /
//                     --hw_workaround=CPU40                                  /
//    List file     =  E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Debug\List /
//                     \os_sem.s43                                            /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME os_sem

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC OSSemAccept
        FUNCTION OSSemAccept,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSSemCreate
        FUNCTION OSSemCreate,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSSemDel
        FUNCTION OSSemDel,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSSemPend
        FUNCTION OSSemPend,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSSemPendAbort
        FUNCTION OSSemPendAbort,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSSemPost
        FUNCTION OSSemPost,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC OSSemQuery
        FUNCTION OSSemQuery,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC OSSemSet
        FUNCTION OSSemSet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN OSCPUSaveSR
        FUNCTION OSCPUSaveSR,0202H
        EXTERN OSCPURestoreSR
        FUNCTION OSCPURestoreSR,0202H
        EXTERN OS_EventTaskRdy
        FUNCTION OS_EventTaskRdy,0202H
        EXTERN OS_Sched
        FUNCTION OS_Sched,0202H
        EXTERN OSIntNesting
        EXTERN OSLockNesting
        EXTERN OSTCBCur
        EXTERN OS_EventTaskWait
        FUNCTION OS_EventTaskWait,0202H
        EXTERN OS_EventTaskRemove
        FUNCTION OS_EventTaskRemove,0202H
        EXTERN OSEventFreeList
        EXTERN OS_EventWaitListInit
        FUNCTION OS_EventWaitListInit,0202H

// E:\MSP430\MSP430F5529¿âº¯Êý2.6\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_sem.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/OS-II
//    4 *                                          The Real-Time Kernel
//    5 *                                          SEMAPHORE MANAGEMENT
//    6 *
//    7 *                              (c) Copyright 1992-2009, Micrium, Weston, FL
//    8 *                                           All Rights Reserved
//    9 *
//   10 * File    : OS_SEM.C
//   11 * By      : Jean J. Labrosse
//   12 * Version : V2.91
//   13 *
//   14 * LICENSING TERMS:
//   15 * ---------------
//   16 *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
//   17 * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
//   18 * its use in your product. We provide ALL the source code for your convenience and to help you experience
//   19 * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
//   20 * licensing fee.
//   21 *********************************************************************************************************
//   22 */
//   23 
//   24 #ifndef  OS_MASTER_FILE
//   25 #include "ucos_ii.h"
//   26 #endif
//   27 
//   28 #if OS_SEM_EN > 0u
//   29 /*$PAGE*/
//   30 /*
//   31 *********************************************************************************************************
//   32 *                                           ACCEPT SEMAPHORE
//   33 *
//   34 * Description: This function checks the semaphore to see if a resource is available or, if an event
//   35 *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
//   36 *              resource is not available or the event did not occur.
//   37 *
//   38 * Arguments  : pevent     is a pointer to the event control block
//   39 *
//   40 * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
//   41 *                         decremented to obtain the resource.
//   42 *              == 0       if the resource is not available or the event did not occur or,
//   43 *                         if 'pevent' is a NULL pointer or,
//   44 *                         if you didn't pass a pointer to a semaphore
//   45 *********************************************************************************************************
//   46 */
//   47 
//   48 #if OS_SEM_ACCEPT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   49 INT16U  OSSemAccept (OS_EVENT *pevent)
OSSemAccept:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function OSSemAccept
//   50 {
        FUNCALL OSSemAccept, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemAccept, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
//   51     INT16U     cnt;
//   52 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//   53     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R8
//   54 #endif
//   55 
//   56 
//   57 
//   58 #if OS_ARG_CHK_EN > 0u
//   59     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//   60         return (0u);
//   61     }
//   62 #endif
//   63     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        CMP.B   #0x3, 0(R10)
        JEQ     ??OSSemAccept_0
//   64         return (0u);
        MOV.W   #0x0, R12
        JMP     ??OSSemAccept_1
//   65     }
//   66     OS_ENTER_CRITICAL();
??OSSemAccept_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R8
//   67     cnt = pevent->OSEventCnt;
        MOV.W   0x6(R10), R11
//   68     if (cnt > 0u) {                                   /* See if resource is available                  */
        CMP.W   #0x0, R11
        JEQ     ??OSSemAccept_2
//   69         pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
        ADD.W   #0xffff, 0x6(R10)
//   70     }
//   71     OS_EXIT_CRITICAL();
??OSSemAccept_2:
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//   72     return (cnt);                                     /* Return semaphore count                        */
        MOV.W   R11, R12
??OSSemAccept_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//   73 }
//   74 #endif
//   75 
//   76 /*$PAGE*/
//   77 /*
//   78 *********************************************************************************************************
//   79 *                                           CREATE A SEMAPHORE
//   80 *
//   81 * Description: This function creates a semaphore.
//   82 *
//   83 * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
//   84 *                            available (or no event has occurred).  You initialize the semaphore to a
//   85 *                            non-zero value to specify how many resources are available (e.g. if you have
//   86 *                            10 resources, you would initialize the semaphore to 10).
//   87 *
//   88 * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
//   89 *                            created semaphore
//   90 *              == (void *)0  if no event control blocks were available
//   91 *********************************************************************************************************
//   92 */
//   93 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//   94 OS_EVENT  *OSSemCreate (INT16U cnt)
OSSemCreate:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function OSSemCreate
//   95 {
        FUNCALL OSSemCreate, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemCreate, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemCreate, OS_EventWaitListInit
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R10
//   96     OS_EVENT  *pevent;
//   97 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//   98     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R8
//   99 #endif
//  100 
//  101 
//  102 
//  103 #ifdef OS_SAFETY_CRITICAL_IEC61508
//  104     if (OSSafetyCriticalStartFlag == OS_TRUE) {
//  105         OS_SAFETY_CRITICAL_EXCEPTION();
//  106     }
//  107 #endif
//  108 
//  109     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSSemCreate_0
//  110         return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
        MOVA    #0x0, R12
        JMP     ??OSSemCreate_1
//  111     }
//  112     OS_ENTER_CRITICAL();
??OSSemCreate_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R8
//  113     pevent = OSEventFreeList;                              /* Get next free event control block        */
        MOVA    &OSEventFreeList, R11
//  114     if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
        MOVA    &OSEventFreeList, R15
        CMPA    #0x0, R15
        JEQ     ??OSSemCreate_2
//  115         OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
        MOVA    &OSEventFreeList, R15
        MOVX.A  0x2(R15), &OSEventFreeList
//  116     }
//  117     OS_EXIT_CRITICAL();
??OSSemCreate_2:
        MOV.W   R8, R12
        CALLA   #OSCPURestoreSR
//  118     if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        CMPA    #0x0, R11
        JEQ     ??OSSemCreate_3
//  119         pevent->OSEventType    = OS_EVENT_TYPE_SEM;
        MOV.B   #0x3, 0(R11)
//  120         pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
        MOV.W   R10, 0x6(R11)
//  121         pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
        MOVX.A  #0x0, 0x2(R11)
//  122 #if OS_EVENT_NAME_EN > 0u
//  123         pevent->OSEventName    = (INT8U *)(void *)"?";
//  124 #endif
//  125         OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
        MOVA    R11, R12
        CALLA   #OS_EventWaitListInit
//  126     }
//  127     return (pevent);
??OSSemCreate_3:
        MOVA    R11, R12
??OSSemCreate_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  128 }
//  129 
//  130 /*$PAGE*/
//  131 /*
//  132 *********************************************************************************************************
//  133 *                                         DELETE A SEMAPHORE
//  134 *
//  135 * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
//  136 *
//  137 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  138 *                            semaphore.
//  139 *
//  140 *              opt           determines delete options as follows:
//  141 *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
//  142 *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
//  143 *                                                    In this case, all the tasks pending will be readied.
//  144 *
//  145 *              perr          is a pointer to an error code that can contain one of the following values:
//  146 *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
//  147 *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
//  148 *                            OS_ERR_INVALID_OPT      An invalid option was specified
//  149 *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
//  150 *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
//  151 *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
//  152 *
//  153 * Returns    : pevent        upon error
//  154 *              (OS_EVENT *)0 if the semaphore was successfully deleted.
//  155 *
//  156 * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
//  157 *                 the semaphore MUST check the return code of OSSemPend().
//  158 *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
//  159 *                 they check 'pevent' to see that it's a NULL pointer.
//  160 *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
//  161 *                 time is directly proportional to the number of tasks waiting on the semaphore.
//  162 *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
//  163 *                 applications where the semaphore is used for mutual exclusion because the resource(s)
//  164 *                 will no longer be guarded by the semaphore.
//  165 *********************************************************************************************************
//  166 */
//  167 
//  168 #if OS_SEM_DEL_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  169 OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
OSSemDel:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function OSSemDel
//  170                      INT8U      opt,
//  171                      INT8U     *perr)
//  172 {
        FUNCALL OSSemDel, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemDel, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOV.B   R13, R7
        MOVA    R14, R11
//  173     BOOLEAN    tasks_waiting;
//  174     OS_EVENT  *pevent_return;
//  175 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  176     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  177 #endif
//  178 
//  179 
//  180 
//  181 #ifdef OS_SAFETY_CRITICAL
//  182     if (perr == (INT8U *)0) {
//  183         OS_SAFETY_CRITICAL_EXCEPTION();
//  184     }
//  185 #endif
//  186 
//  187 #if OS_ARG_CHK_EN > 0u
//  188     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  189         *perr = OS_ERR_PEVENT_NULL;
//  190         return (pevent);
//  191     }
//  192 #endif
//  193     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        CMP.B   #0x3, 0(R10)
        JEQ     ??OSSemDel_3
//  194         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  195         return (pevent);
        MOVA    R10, R12
        JMP     ??OSSemDel_4
//  196     }
//  197     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
??OSSemDel_3:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSSemDel_5
//  198         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        MOV.B   #0xf, 0(R11)
//  199         return (pevent);
        MOVA    R10, R12
        JMP     ??OSSemDel_4
//  200     }
//  201     OS_ENTER_CRITICAL();
??OSSemDel_5:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  202     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSSemDel_6
//  203         tasks_waiting = OS_TRUE;                           /* Yes                                      */
        MOV.B   #0x1, R6
        JMP     ??OSSemDel_7
//  204     } else {
//  205         tasks_waiting = OS_FALSE;                          /* No                                       */
??OSSemDel_6:
        MOV.B   #0x0, R6
//  206     }
//  207     switch (opt) {
??OSSemDel_7:
        MOV.B   R7, R14
        SUB.B   #0x0, R14
        JEQ     ??OSSemDel_8
        SUB.B   #0x1, R14
        JEQ     ??OSSemDel_0
        JMP     ??OSSemDel_9
//  208         case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
//  209              if (tasks_waiting == OS_FALSE) {
??OSSemDel_8:
        CMP.B   #0x0, R6
        JNE     ??OSSemDel_10
//  210 #if OS_EVENT_NAME_EN > 0u
//  211                  pevent->OSEventName    = (INT8U *)(void *)"?";
//  212 #endif
//  213                  pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
        MOV.B   #0x0, 0(R10)
//  214                  pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R10)
//  215                  pevent->OSEventCnt     = 0u;
        MOV.W   #0x0, 0x6(R10)
//  216                  OSEventFreeList        = pevent;          /* Get next free event control block        */
        MOVA    R10, &OSEventFreeList
//  217                  OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  218                  *perr                  = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  219                  pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
        MOVA    #0x0, R8
        JMP     ??OSSemDel_2
//  220              } else {
//  221                  OS_EXIT_CRITICAL();
??OSSemDel_10:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  222                  *perr                  = OS_ERR_TASK_WAITING;
        MOV.B   #0x49, 0(R11)
//  223                  pevent_return          = pevent;
        MOVA    R10, R8
//  224              }
//  225              break;
        JMP     ??OSSemDel_2
//  226 
//  227         case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
//  228              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
??OSSemDel_0:
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSSemDel_11
//  229                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x1, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        JMP     ??OSSemDel_0
//  230              }
//  231 #if OS_EVENT_NAME_EN > 0u
//  232              pevent->OSEventName    = (INT8U *)(void *)"?";
//  233 #endif
//  234              pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
??OSSemDel_11:
        MOV.B   #0x0, 0(R10)
//  235              pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
        MOVX.A  &OSEventFreeList, 0x2(R10)
//  236              pevent->OSEventCnt     = 0u;
        MOV.W   #0x0, 0x6(R10)
//  237              OSEventFreeList        = pevent;              /* Get next free event control block        */
        MOVA    R10, &OSEventFreeList
//  238              OS_EXIT_CRITICAL();
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  239              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
        CMP.B   #0x1, R6
        JNE     ??OSSemDel_12
//  240                  OS_Sched();                               /* Find highest priority task ready to run  */
        CALLA   #OS_Sched
//  241              }
//  242              *perr                  = OS_ERR_NONE;
??OSSemDel_12:
        MOV.B   #0x0, 0(R11)
//  243              pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
        MOVA    #0x0, R8
//  244              break;
        JMP     ??OSSemDel_2
//  245 
//  246         default:
//  247              OS_EXIT_CRITICAL();
??OSSemDel_9:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  248              *perr                  = OS_ERR_INVALID_OPT;
        MOV.B   #0x7, 0(R11)
//  249              pevent_return          = pevent;
        MOVA    R10, R8
//  250              break;
//  251     }
//  252     return (pevent_return);
??OSSemDel_2:
        MOVA    R8, R12
??OSSemDel_4:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  253 }
//  254 #endif
//  255 
//  256 /*$PAGE*/
//  257 /*
//  258 *********************************************************************************************************
//  259 *                                           PEND ON SEMAPHORE
//  260 *
//  261 * Description: This function waits for a semaphore.
//  262 *
//  263 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  264 *                            semaphore.
//  265 *
//  266 *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
//  267 *                            wait for the resource up to the amount of time specified by this argument.
//  268 *                            If you specify 0, however, your task will wait forever at the specified
//  269 *                            semaphore or, until the resource becomes available (or the event occurs).
//  270 *
//  271 *              perr          is a pointer to where an error message will be deposited.  Possible error
//  272 *                            messages are:
//  273 *
//  274 *                            OS_ERR_NONE         The call was successful and your task owns the resource
//  275 *                                                or, the event you are waiting for occurred.
//  276 *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
//  277 *                                                'timeout'.
//  278 *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
//  279 *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
//  280 *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
//  281 *                                                would lead to a suspension.
//  282 *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
//  283 *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
//  284 *
//  285 * Returns    : none
//  286 *********************************************************************************************************
//  287 */
//  288 /*$PAGE*/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  289 void  OSSemPend (OS_EVENT  *pevent,
OSSemPend:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function OSSemPend
//  290                  INT32U     timeout,
//  291                  INT8U     *perr)
//  292 {
        FUNCALL OSSemPend, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OS_EventTaskWait
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OS_EventTaskRemove
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPend, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R8
        MOV.W   R14, R10
        MOV.W   R15, R11
        MOVA    R13, R9
//  293 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  294     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R6
//  295 #endif
//  296 
//  297 
//  298 
//  299 #ifdef OS_SAFETY_CRITICAL
//  300     if (perr == (INT8U *)0) {
//  301         OS_SAFETY_CRITICAL_EXCEPTION();
//  302     }
//  303 #endif
//  304 
//  305 #if OS_ARG_CHK_EN > 0u
//  306     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  307         *perr = OS_ERR_PEVENT_NULL;
//  308         return;
//  309     }
//  310 #endif
//  311     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        CMP.B   #0x3, 0(R8)
        JEQ     ??OSSemPend_0
//  312         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R9)
//  313         return;
        JMP     ??OSSemPend_1
//  314     }
//  315     if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
??OSSemPend_0:
        CMPX.B  #0x0, &OSIntNesting
        JEQ     ??OSSemPend_2
//  316         *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
        MOV.B   #0x2, 0(R9)
//  317         return;
        JMP     ??OSSemPend_1
//  318     }
//  319     if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
??OSSemPend_2:
        CMPX.B  #0x0, &OSLockNesting
        JEQ     ??OSSemPend_3
//  320         *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
        MOV.B   #0xd, 0(R9)
//  321         return;
        JMP     ??OSSemPend_1
//  322     }
//  323     OS_ENTER_CRITICAL();
??OSSemPend_3:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  324     if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
        CMP.W   #0x0, 0x6(R8)
        JEQ     ??OSSemPend_4
//  325         pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
        ADD.W   #0xffff, 0x6(R8)
//  326         OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  327         *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R9)
//  328         return;
        JMP     ??OSSemPend_1
//  329     }
//  330                                                       /* Otherwise, must wait until event occurs       */
//  331     OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
??OSSemPend_4:
        MOVA    &OSTCBCur, R15
        BIS.B   #0x1, 0x2e(R15)
//  332     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  333     OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
        MOVA    &OSTCBCur, R15
        MOV.W   R10, 0x2a(R15)
        MOV.W   R11, 0x2c(R15)
//  334     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
        MOVA    R8, R12
        CALLA   #OS_EventTaskWait
//  335     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  336     OS_Sched();                                       /* Find next highest priority task ready         */
        CALLA   #OS_Sched
//  337     OS_ENTER_CRITICAL();
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  338     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        MOVA    &OSTCBCur, R15
        MOV.B   0x2f(R15), R14
        SUB.B   #0x0, R14
        JEQ     ??OSSemPend_5
        SUB.B   #0x2, R14
        JEQ     ??OSSemPend_6
        JMP     ??OSSemPend_7
//  339         case OS_STAT_PEND_OK:
//  340              *perr = OS_ERR_NONE;
??OSSemPend_5:
        MOV.B   #0x0, 0(R9)
//  341              break;
        JMP     ??OSSemPend_8
//  342 
//  343         case OS_STAT_PEND_ABORT:
//  344              *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
??OSSemPend_6:
        MOV.B   #0xe, 0(R9)
//  345              break;
        JMP     ??OSSemPend_8
//  346 
//  347         case OS_STAT_PEND_TO:
//  348         default:
//  349              OS_EventTaskRemove(OSTCBCur, pevent);
??OSSemPend_7:
        MOVA    R8, R13
        MOVA    &OSTCBCur, R12
        CALLA   #OS_EventTaskRemove
//  350              *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
        MOV.B   #0xa, 0(R9)
//  351              break;
//  352     }
//  353     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
??OSSemPend_8:
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2e(R15)
//  354     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
        MOVA    &OSTCBCur, R15
        MOV.B   #0x0, 0x2f(R15)
//  355     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
        MOVA    &OSTCBCur, R15
        MOVX.A  #0x0, 0x1c(R15)
//  356 #if (OS_EVENT_MULTI_EN > 0u)
//  357     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
//  358 #endif
//  359     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  360 }
??OSSemPend_1:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  361 
//  362 /*$PAGE*/
//  363 /*
//  364 *********************************************************************************************************
//  365 *                                      ABORT WAITING ON A SEMAPHORE
//  366 *
//  367 * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
//  368 *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
//  369 *              the semaphore via OSSemPost().
//  370 *
//  371 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  372 *                            semaphore.
//  373 *
//  374 *              opt           determines the type of ABORT performed:
//  375 *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
//  376 *                                                     semaphore
//  377 *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
//  378 *                                                     semaphore
//  379 *
//  380 *              perr          is a pointer to where an error message will be deposited.  Possible error
//  381 *                            messages are:
//  382 *
//  383 *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
//  384 *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
//  385 *                                                and informed of the aborted wait; check return value
//  386 *                                                for the number of tasks whose wait on the semaphore
//  387 *                                                was aborted.
//  388 *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
//  389 *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
//  390 *
//  391 * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
//  392 *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
//  393 *********************************************************************************************************
//  394 */
//  395 
//  396 #if OS_SEM_PEND_ABORT_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  397 INT8U  OSSemPendAbort (OS_EVENT  *pevent,
OSSemPendAbort:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function OSSemPendAbort
//  398                        INT8U      opt,
//  399                        INT8U     *perr)
//  400 {
        FUNCALL OSSemPendAbort, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPendAbort, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPendAbort, OS_EventTaskRdy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPendAbort, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPendAbort, OS_Sched
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemPendAbort, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R10
        MOV.B   R13, R6
        MOVA    R14, R11
//  401     INT8U      nbr_tasks;
//  402 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  403     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  404 #endif
//  405 
//  406 
//  407 
//  408 #ifdef OS_SAFETY_CRITICAL
//  409     if (perr == (INT8U *)0) {
//  410         OS_SAFETY_CRITICAL_EXCEPTION();
//  411     }
//  412 #endif
//  413 
//  414 #if OS_ARG_CHK_EN > 0u
//  415     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  416         *perr = OS_ERR_PEVENT_NULL;
//  417         return (0u);
//  418     }
//  419 #endif
//  420     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        CMP.B   #0x3, 0(R10)
        JEQ     ??OSSemPendAbort_3
//  421         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R11)
//  422         return (0u);
        MOV.B   #0x0, R12
        JMP     ??OSSemPendAbort_4
//  423     }
//  424     OS_ENTER_CRITICAL();
??OSSemPendAbort_3:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  425     if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSSemPendAbort_5
//  426         nbr_tasks = 0u;
        MOV.B   #0x0, R8
//  427         switch (opt) {
        CMP.B   #0x1, R6
        JNE     ??OSSemPendAbort_6
//  428             case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
//  429                  while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
??OSSemPendAbort_0:
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSSemPendAbort_2
//  430                      (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
        MOV.B   #0x2, R15
        MOV.B   #0x1, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
//  431                      nbr_tasks++;
        ADD.B   #0x1, R8
        JMP     ??OSSemPendAbort_0
//  432                  }
//  433                  break;
//  434 
//  435             case OS_PEND_OPT_NONE:
//  436             default:                                  /* No,  ready HPT       waiting on semaphore     */
//  437                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
??OSSemPendAbort_6:
        MOV.B   #0x2, R15
        MOV.B   #0x1, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
//  438                  nbr_tasks++;
        ADD.B   #0x1, R8
//  439                  break;
//  440         }
//  441         OS_EXIT_CRITICAL();
??OSSemPendAbort_2:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  442         OS_Sched();                                   /* Find HPT ready to run                         */
        CALLA   #OS_Sched
//  443         *perr = OS_ERR_PEND_ABORT;
        MOV.B   #0xe, 0(R11)
//  444         return (nbr_tasks);
        MOV.B   R8, R12
        JMP     ??OSSemPendAbort_4
//  445     }
//  446     OS_EXIT_CRITICAL();
??OSSemPendAbort_5:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  447     *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R11)
//  448     return (0u);                                      /* No tasks waiting on semaphore                 */
        MOV.B   #0x0, R12
??OSSemPendAbort_4:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  449 }
//  450 #endif
//  451 
//  452 /*$PAGE*/
//  453 /*
//  454 *********************************************************************************************************
//  455 *                                         POST TO A SEMAPHORE
//  456 *
//  457 * Description: This function signals a semaphore
//  458 *
//  459 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  460 *                            semaphore.
//  461 *
//  462 * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
//  463 *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit.  In other words, you have
//  464 *                                  signalled the semaphore more often than you waited on it with either
//  465 *                                  OSSemAccept() or OSSemPend().
//  466 *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
//  467 *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
//  468 *********************************************************************************************************
//  469 */
//  470 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  471 INT8U  OSSemPost (OS_EVENT *pevent)
OSSemPost:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function OSSemPost
//  472 {
        FUNCALL OSSemPost, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemPost, OS_EventTaskRdy
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemPost, OS_Sched
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemPost, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R10
//  473 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  474     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R11
//  475 #endif
//  476 
//  477 
//  478 
//  479 #if OS_ARG_CHK_EN > 0u
//  480     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  481         return (OS_ERR_PEVENT_NULL);
//  482     }
//  483 #endif
//  484     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        CMP.B   #0x3, 0(R10)
        JEQ     ??OSSemPost_0
//  485         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSSemPost_1
//  486     }
//  487     OS_ENTER_CRITICAL();
??OSSemPost_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R11
//  488     if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
        CMP.B   #0x0, 0x8(R10)
        JEQ     ??OSSemPost_2
//  489                                                       /* Ready HPT waiting on event                    */
//  490         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
        MOV.B   #0x0, R15
        MOV.B   #0x1, R14
        MOVA    #0x0, R13
        MOVA    R10, R12
        CALLA   #OS_EventTaskRdy
        MOV.B   R12, R8
//  491         OS_EXIT_CRITICAL();
        MOV.W   R11, R12
        CALLA   #OSCPURestoreSR
//  492         OS_Sched();                                   /* Find HPT ready to run                         */
        CALLA   #OS_Sched
//  493         return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        JMP     ??OSSemPost_1
//  494     }
//  495     if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
??OSSemPost_2:
        CMP.W   #0xffff, 0x6(R10)
        JEQ     ??OSSemPost_3
//  496         pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
        ADD.W   #0x1, 0x6(R10)
//  497         OS_EXIT_CRITICAL();
        MOV.W   R11, R12
        CALLA   #OSCPURestoreSR
//  498         return (OS_ERR_NONE);
        MOV.B   #0x0, R12
        JMP     ??OSSemPost_1
//  499     }
//  500     OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
??OSSemPost_3:
        MOV.W   R11, R12
        CALLA   #OSCPURestoreSR
//  501     return (OS_ERR_SEM_OVF);
        MOV.B   #0x33, R12
??OSSemPost_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  502 }
//  503 
//  504 /*$PAGE*/
//  505 /*
//  506 *********************************************************************************************************
//  507 *                                          QUERY A SEMAPHORE
//  508 *
//  509 * Description: This function obtains information about a semaphore
//  510 *
//  511 * Arguments  : pevent        is a pointer to the event control block associated with the desired
//  512 *                            semaphore
//  513 *
//  514 *              p_sem_data    is a pointer to a structure that will contain information about the
//  515 *                            semaphore.
//  516 *
//  517 * Returns    : OS_ERR_NONE         The call was successful and the message was sent
//  518 *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
//  519 *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
//  520 *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
//  521 *********************************************************************************************************
//  522 */
//  523 
//  524 #if OS_SEM_QUERY_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  525 INT8U  OSSemQuery (OS_EVENT     *pevent,
OSSemQuery:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function OSSemQuery
//  526                    OS_SEM_DATA  *p_sem_data)
//  527 {
        FUNCALL OSSemQuery, OSCPUSaveSR
        LOCFRAME CSTACK, 28, STACK
        FUNCALL OSSemQuery, OSCPURestoreSR
        LOCFRAME CSTACK, 28, STACK
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R7
        MOVA    R13, R10
//  528     INT8U       i;
//  529     OS_PRIO    *psrc;
//  530     OS_PRIO    *pdest;
//  531 #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
//  532     OS_CPU_SR   cpu_sr = 0u;
        MOV.W   #0x0, R6
//  533 #endif
//  534 
//  535 
//  536 
//  537 #if OS_ARG_CHK_EN > 0u
//  538     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
//  539         return (OS_ERR_PEVENT_NULL);
//  540     }
//  541     if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
//  542         return (OS_ERR_PDATA_NULL);
//  543     }
//  544 #endif
//  545     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        CMP.B   #0x3, 0(R7)
        JEQ     ??OSSemQuery_1
//  546         return (OS_ERR_EVENT_TYPE);
        MOV.B   #0x1, R12
        JMP     ??OSSemQuery_2
//  547     }
//  548     OS_ENTER_CRITICAL();
??OSSemQuery_1:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R6
//  549     p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
        MOV.B   0x8(R7), 0xa(R10)
//  550     psrc                   = &pevent->OSEventTbl[0];
        MOVA    R7, R15
        ADDA    #0x9, R15
        MOVA    R15, R8
//  551     pdest                  = &p_sem_data->OSEventTbl[0];
        MOVA    R10, R15
        ADDA    #0x2, R15
        MOVA    R15, R9
//  552     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
        MOV.B   #0x0, R11
??OSSemQuery_0:
        CMP.B   #0x8, R11
        JC      ??OSSemQuery_3
//  553         *pdest++ = *psrc++;
        MOV.B   @R8, 0(R9)
        ADDA    #0x1, R8
        ADDA    #0x1, R9
//  554     }
        ADD.B   #0x1, R11
        JMP     ??OSSemQuery_0
//  555     p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
??OSSemQuery_3:
        MOV.W   0x6(R7), 0(R10)
//  556     OS_EXIT_CRITICAL();
        MOV.W   R6, R12
        CALLA   #OSCPURestoreSR
//  557     return (OS_ERR_NONE);
        MOV.B   #0x0, R12
??OSSemQuery_2:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  558 }
//  559 #endif                                                     /* OS_SEM_QUERY_EN                          */
//  560 
//  561 /*$PAGE*/
//  562 /*
//  563 *********************************************************************************************************
//  564 *                                              SET SEMAPHORE
//  565 *
//  566 * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
//  567 *              this value would be 0.
//  568 *
//  569 *              You would typically use this function when a semaphore is used as a signaling mechanism
//  570 *              and, you want to reset the count value.
//  571 *
//  572 * Arguments  : pevent     is a pointer to the event control block
//  573 *
//  574 *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
//  575 *                         semaphore count.
//  576 *
//  577 *              perr       is a pointer to an error code returned by the function as follows:
//  578 *
//  579 *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
//  580 *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
//  581 *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
//  582 *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
//  583 *********************************************************************************************************
//  584 */
//  585 
//  586 #if OS_SEM_SET_EN > 0u

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  587 void  OSSemSet (OS_EVENT  *pevent,
OSSemSet:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function OSSemSet
//  588                 INT16U     cnt,
//  589                 INT8U     *perr)
//  590 {
        FUNCALL OSSemSet, OSCPUSaveSR
        LOCFRAME CSTACK, 20, STACK
        FUNCALL OSSemSet, OSCPURestoreSR
        LOCFRAME CSTACK, 20, STACK
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOVA    R12, R11
        MOV.W   R13, R10
        MOVA    R14, R8
//  591 #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
//  592     OS_CPU_SR  cpu_sr = 0u;
        MOV.W   #0x0, R9
//  593 #endif
//  594 
//  595 
//  596 
//  597 #ifdef OS_SAFETY_CRITICAL
//  598     if (perr == (INT8U *)0) {
//  599         OS_SAFETY_CRITICAL_EXCEPTION();
//  600     }
//  601 #endif
//  602 
//  603 #if OS_ARG_CHK_EN > 0u
//  604     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
//  605         *perr = OS_ERR_PEVENT_NULL;
//  606         return;
//  607     }
//  608 #endif
//  609     if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        CMP.B   #0x3, 0(R11)
        JEQ     ??OSSemSet_0
//  610         *perr = OS_ERR_EVENT_TYPE;
        MOV.B   #0x1, 0(R8)
//  611         return;
        JMP     ??OSSemSet_1
//  612     }
//  613     OS_ENTER_CRITICAL();
??OSSemSet_0:
        CALLA   #OSCPUSaveSR
        MOV.W   R12, R9
//  614     *perr = OS_ERR_NONE;
        MOV.B   #0x0, 0(R8)
//  615     if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
        CMP.W   #0x0, 0x6(R11)
        JEQ     ??OSSemSet_2
//  616         pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
        MOV.W   R10, 0x6(R11)
        JMP     ??OSSemSet_3
//  617     } else {                                          /* No                                            */
//  618         if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
??OSSemSet_2:
        CMP.B   #0x0, 0x8(R11)
        JNE     ??OSSemSet_4
//  619             pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
        MOV.W   R10, 0x6(R11)
        JMP     ??OSSemSet_3
//  620         } else {
//  621             *perr              = OS_ERR_TASK_WAITING;
??OSSemSet_4:
        MOV.B   #0x49, 0(R8)
//  622         }
//  623     }
//  624     OS_EXIT_CRITICAL();
??OSSemSet_3:
        MOV.W   R9, R12
        CALLA   #OSCPURestoreSR
//  625 }
??OSSemSet_1:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  626 #endif
//  627 
//  628 #endif                                                /* OS_SEM_EN                                     */
//  629 	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
// 
// 930 bytes in segment CODE
// 
// 930 bytes of CODE memory
//
//Errors: none
//Warnings: 11
