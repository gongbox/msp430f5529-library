###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:31 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mem.c                         #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mem.c -D NDEBUG -D            #
#                     RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿ #
#                     âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_mem.lst                          #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_mem.r43                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            MEMORY MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MEM.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include "includes.h"

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          #endif
     27          
     28          #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
     29          /*
     30          *********************************************************************************************************
     31          *                                        CREATE A MEMORY PARTITION
     32          *
     33          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
     34          *
     35          * Arguments   : addr     is the starting address of the memory partition
     36          *
     37          *               nblks    is the number of memory blocks to create from the partition.
     38          *
     39          *               blksize  is the size (in bytes) of each block in the memory partition.
     40          *
     41          *               perr     is a pointer to a variable containing an error message which will be set by
     42          *                        this function to either:
     43          *
     44          *                        OS_ERR_NONE              if the memory partition has been created correctly.
     45          *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
     46          *                                                 storage of the partition or, the block does not align
     47          *                                                 on a pointer boundary
     48          *                        OS_ERR_MEM_INVALID_PART  no free partitions available
     49          *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
     50          *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
     51          *                                                   - must be greater than the size of a pointer
     52          *                                                   - must be able to hold an integral number of pointers
     53          * Returns    : != (OS_MEM *)0  is the partition was created
     54          *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
     55          *                              free partition is available.
     56          *********************************************************************************************************
     57          */
     58          
     59          OS_MEM  *OSMemCreate (void   *addr,
     60                                INT32U  nblks,
     61                                INT32U  blksize,
     62                                INT8U  *perr)
     63          {
     64              OS_MEM    *pmem;
     65              INT8U     *pblk;
     66              void     **plink;
     67              INT32U     loops;
     68              INT32U     i;
     69          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
     70              OS_CPU_SR  cpu_sr = 0u;
     71          #endif
     72          
     73          
     74          
     75          #ifdef OS_SAFETY_CRITICAL
     76              if (perr == (INT8U *)0) {
     77                  OS_SAFETY_CRITICAL_EXCEPTION();
     78              }
     79          #endif
     80          
     81          #ifdef OS_SAFETY_CRITICAL_IEC61508
     82              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     83                  OS_SAFETY_CRITICAL_EXCEPTION();
     84              }
     85          #endif
     86          
     87          #if OS_ARG_CHK_EN > 0u
     88              if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
     89                  *perr = OS_ERR_MEM_INVALID_ADDR;
     90                  return ((OS_MEM *)0);
     91              }
     92              if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
     93                  *perr = OS_ERR_MEM_INVALID_ADDR;
     94                  return ((OS_MEM *)0);
     95              }
     96              if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
     97                  *perr = OS_ERR_MEM_INVALID_BLKS;
     98                  return ((OS_MEM *)0);
     99              }
    100              if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
    101                  *perr = OS_ERR_MEM_INVALID_SIZE;
    102                  return ((OS_MEM *)0);
    103              }
    104          #endif
    105              OS_ENTER_CRITICAL();
    106              pmem = OSMemFreeList;                             /* Get next free memory partition                */
    107              if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
    108                  OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
    109              }
    110              OS_EXIT_CRITICAL();
    111              if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
    112                  *perr = OS_ERR_MEM_INVALID_PART;
    113                  return ((OS_MEM *)0);
    114              }
    115              plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    116              pblk  = (INT8U *)addr;
    117              loops  = nblks - 1u;
    118              for (i = 0u; i < loops; i++) {
    119                  pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
    120                 *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
    121                  plink = (void **)pblk;                        /* Position to  NEXT      block                  */
    122              }
    123              *plink              = (void *)0;                  /* Last memory block points to NULL              */
    124              pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
    125              pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
    126              pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
    127              pmem->OSMemNBlks    = nblks;
    128              pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
    129              *perr               = OS_ERR_NONE;
    130              return (pmem);
    131          }
    132          /*$PAGE*/
    133          /*
    134          *********************************************************************************************************
    135          *                                          GET A MEMORY BLOCK
    136          *
    137          * Description : Get a memory block from a partition
    138          *
    139          * Arguments   : pmem    is a pointer to the memory partition control block
    140          *
    141          *               perr    is a pointer to a variable containing an error message which will be set by this
    142          *                       function to either:
    143          *
    144          *                       OS_ERR_NONE             if the memory partition has been created correctly.
    145          *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
    146          *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
    147          *
    148          * Returns     : A pointer to a memory block if no error is detected
    149          *               A pointer to NULL if an error is detected
    150          *********************************************************************************************************
    151          */
    152          
    153          void  *OSMemGet (OS_MEM  *pmem,
    154                           INT8U   *perr)
    155          {
    156              void      *pblk;
    157          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    158              OS_CPU_SR  cpu_sr = 0u;
    159          #endif
    160          
    161          
    162          
    163          #ifdef OS_SAFETY_CRITICAL
    164              if (perr == (INT8U *)0) {
    165                  OS_SAFETY_CRITICAL_EXCEPTION();
    166              }
    167          #endif
    168          
    169          #if OS_ARG_CHK_EN > 0u
    170              if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
    171                  *perr = OS_ERR_MEM_INVALID_PMEM;
    172                  return ((void *)0);
    173              }
    174          #endif
    175              OS_ENTER_CRITICAL();
    176              if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
    177                  pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
    178                  pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
    179                  pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
    180                  OS_EXIT_CRITICAL();
    181                  *perr = OS_ERR_NONE;                          /*      No error                                 */
    182                  return (pblk);                                /*      Return memory block to caller            */
    183              }
    184              OS_EXIT_CRITICAL();
    185              *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
    186              return ((void *)0);                               /*      Return NULL pointer to caller            */
    187          }
    188          /*$PAGE*/
    189          /*
    190          *********************************************************************************************************
    191          *                                   GET THE NAME OF A MEMORY PARTITION
    192          *
    193          * Description: This function is used to obtain the name assigned to a memory partition.
    194          *
    195          * Arguments  : pmem      is a pointer to the memory partition
    196          *
    197          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
    198          *
    199          *              perr      is a pointer to an error code that can contain one of the following values:
    200          *
    201          *                        OS_ERR_NONE                if the name was copied to 'pname'
    202          *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
    203          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    204          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    205          *
    206          * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
    207          *********************************************************************************************************
    208          */
    209          
    210          #if OS_MEM_NAME_EN > 0u
    211          INT8U  OSMemNameGet (OS_MEM   *pmem,
    212                               INT8U   **pname,
    213                               INT8U    *perr)
    214          {
    215              INT8U      len;
    216          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    217              OS_CPU_SR  cpu_sr = 0u;
    218          #endif
    219          
    220          
    221          
    222          #ifdef OS_SAFETY_CRITICAL
    223              if (perr == (INT8U *)0) {
    224                  OS_SAFETY_CRITICAL_EXCEPTION();
    225              }
    226          #endif
    227          
    228          #if OS_ARG_CHK_EN > 0u
    229              if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
    230                  *perr = OS_ERR_MEM_INVALID_PMEM;
    231                  return (0u);
    232              }
    233              if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
    234                  *perr = OS_ERR_PNAME_NULL;
    235                  return (0u);
    236              }
    237          #endif
    238              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
    239                  *perr = OS_ERR_NAME_GET_ISR;
    240                  return (0u);
    241              }
    242              OS_ENTER_CRITICAL();
    243              *pname = pmem->OSMemName;
    244              len    = OS_StrLen(*pname);
    245              OS_EXIT_CRITICAL();
    246              *perr  = OS_ERR_NONE;
    247              return (len);
    248          }
    249          #endif
    250          
    251          /*$PAGE*/
    252          /*
    253          *********************************************************************************************************
    254          *                                 ASSIGN A NAME TO A MEMORY PARTITION
    255          *
    256          * Description: This function assigns a name to a memory partition.
    257          *
    258          * Arguments  : pmem      is a pointer to the memory partition
    259          *
    260          *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
    261          *
    262          *              perr      is a pointer to an error code that can contain one of the following values:
    263          *
    264          *                        OS_ERR_NONE                if the name was copied to 'pname'
    265          *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
    266          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    267          *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
    268          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    269          *
    270          * Returns    : None
    271          *********************************************************************************************************
    272          */
    273          
    274          #if OS_MEM_NAME_EN > 0u
    275          void  OSMemNameSet (OS_MEM  *pmem,
    276                              INT8U   *pname,
    277                              INT8U   *perr)
    278          {
    279          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    280              OS_CPU_SR  cpu_sr = 0u;
    281          #endif
    282          
    283          
    284          
    285          #ifdef OS_SAFETY_CRITICAL
    286              if (perr == (INT8U *)0) {
    287                  OS_SAFETY_CRITICAL_EXCEPTION();
    288              }
    289          #endif
    290          
    291          #if OS_ARG_CHK_EN > 0u
    292              if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
    293                  *perr = OS_ERR_MEM_INVALID_PMEM;
    294                  return;
    295              }
    296              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    297                  *perr = OS_ERR_PNAME_NULL;
    298                  return;
    299              }
    300          #endif
    301              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
    302                  *perr = OS_ERR_NAME_SET_ISR;
    303                  return;
    304              }
    305              OS_ENTER_CRITICAL();
    306              pmem->OSMemName = pname;
    307              OS_EXIT_CRITICAL();
    308              *perr           = OS_ERR_NONE;
    309          }
    310          #endif
    311          
    312          /*$PAGE*/
    313          /*
    314          *********************************************************************************************************
    315          *                                         RELEASE A MEMORY BLOCK
    316          *
    317          * Description : Returns a memory block to a partition
    318          *
    319          * Arguments   : pmem    is a pointer to the memory partition control block
    320          *
    321          *               pblk    is a pointer to the memory block being released.
    322          *
    323          * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
    324          *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
    325          *                                        partition (You freed more blocks than you allocated!)
    326          *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
    327          *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
    328          *********************************************************************************************************
    329          */
    330          
    331          INT8U  OSMemPut (OS_MEM  *pmem,
    332                           void    *pblk)
    333          {
    334          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    335              OS_CPU_SR  cpu_sr = 0u;
    336          #endif
    337          
    338          
    339          
    340          #if OS_ARG_CHK_EN > 0u
    341              if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
    342                  return (OS_ERR_MEM_INVALID_PMEM);
    343              }
    344              if (pblk == (void *)0) {                     /* Must release a valid block                         */
    345                  return (OS_ERR_MEM_INVALID_PBLK);
    346              }
    347          #endif
    348              OS_ENTER_CRITICAL();
    349              if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
    350                  OS_EXIT_CRITICAL();
    351                  return (OS_ERR_MEM_FULL);
    352              }
    353              *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
    354              pmem->OSMemFreeList = pblk;
    355              pmem->OSMemNFree++;                          /* One more memory block in this partition            */
    356              OS_EXIT_CRITICAL();
    357              return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
    358          }
    359          /*$PAGE*/
    360          /*
    361          *********************************************************************************************************
    362          *                                          QUERY MEMORY PARTITION
    363          *
    364          * Description : This function is used to determine the number of free memory blocks and the number of
    365          *               used memory blocks from a memory partition.
    366          *
    367          * Arguments   : pmem        is a pointer to the memory partition control block
    368          *
    369          *               p_mem_data  is a pointer to a structure that will contain information about the memory
    370          *                           partition.
    371          *
    372          * Returns     : OS_ERR_NONE               if no errors were found.
    373          *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
    374          *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
    375          *********************************************************************************************************
    376          */
    377          
    378          #if OS_MEM_QUERY_EN > 0u
    379          INT8U  OSMemQuery (OS_MEM       *pmem,
    380                             OS_MEM_DATA  *p_mem_data)
    381          {
    382          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    383              OS_CPU_SR  cpu_sr = 0u;
    384          #endif
    385          
    386          
    387          
    388          #if OS_ARG_CHK_EN > 0u
    389              if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
    390                  return (OS_ERR_MEM_INVALID_PMEM);
    391              }
    392              if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
    393                  return (OS_ERR_MEM_INVALID_PDATA);
    394              }
    395          #endif
    396              OS_ENTER_CRITICAL();
    397              p_mem_data->OSAddr     = pmem->OSMemAddr;
    398              p_mem_data->OSFreeList = pmem->OSMemFreeList;
    399              p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    400              p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    401              p_mem_data->OSNFree    = pmem->OSMemNFree;
    402              OS_EXIT_CRITICAL();
    403              p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
    404              return (OS_ERR_NONE);
    405          }
    406          #endif                                           /* OS_MEM_QUERY_EN                                    */
    407          /*$PAGE*/
    408          /*
    409          *********************************************************************************************************
    410          *                                    INITIALIZE MEMORY PARTITION MANAGER
    411          *
    412          * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
    413          *               application MUST NOT call this function.
    414          *
    415          * Arguments   : none
    416          *
    417          * Returns     : none
    418          *
    419          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    420          *********************************************************************************************************
    421          */
    422          
    423          void  OS_MemInit (void)
    424          {
    425          #if OS_MAX_MEM_PART == 1u
    426              OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    427              OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
    428          #if OS_MEM_NAME_EN > 0u
    429              OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
    430          #endif
    431          #endif
    432          
    433          #if OS_MAX_MEM_PART >= 2u
    434              OS_MEM  *pmem;
    435              INT16U   i;
    436          
    437          
    438              OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    439              for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
    440                  pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
    441                  pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
    442          #if OS_MEM_NAME_EN > 0u
    443                  pmem->OSMemName  = (INT8U *)(void *)"?";
    444          #endif
    445              }
    446              pmem                = &OSMemTbl[i];
    447              pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
    448          #if OS_MEM_NAME_EN > 0u
    449              pmem->OSMemName = (INT8U *)(void *)"?";
    450          #endif
    451          
    452              OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
    453          #endif
    454          }
    455          #endif                                                    /* OS_MEM_EN                                 */
    456          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  


 

 


Errors: none
Warnings: 11
