###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:28 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_core.c                        #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_core.c -D NDEBUG -D           #
#                     RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿ #
#                     âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_core.lst                         #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_core.r43                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          #include "includes.h"

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_event *__data20 OSEventFreeList
   \                     OSEventFreeList:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_EVENT OSEventTbl[10U]
   \                     OSEventTbl:
   \   000000                DS8 180

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_FLAG_GRP OSFlagTbl[5U]
   \                     OSFlagTbl:
   \   000000                DS8 60

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_flag_grp *__data20 OSFlagFreeList
   \                     OSFlagFreeList:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSCPUUsage
   \                     OSCPUUsage:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT32U OSIdleCtrMax
   \                     OSIdleCtrMax:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT32U OSIdleCtrRun
   \                     OSIdleCtrRun:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   BOOLEAN OSStatRdy
   \                     OSStatRdy:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_STK OSTaskStatStk[128U]
   \                     OSTaskStatStk:
   \   000000                DS8 256

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSIntNesting
   \                     OSIntNesting:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSLockNesting
   \                     OSLockNesting:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSPrioCur
   \                     OSPrioCur:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSRdyTbl[8U]
   \                     OSRdyTbl:
   \   000000                DS8 8

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   BOOLEAN OSRunning
   \                     OSRunning:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_STK OSTaskIdleStk[128U]
   \                     OSTaskIdleStk:
   \   000000                DS8 256

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_tcb *__data20 OSTCBCur
   \                     OSTCBCur:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_tcb *__data20 OSTCBFreeList
   \                     OSTCBFreeList:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_tcb *__data20 OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_tcb *__data20 OSTCBList
   \                     OSTCBList:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   struct os_tcb *__data20 OSTCBPrioTbl[64U]
   \                     OSTCBPrioTbl:
   \   000000                DS8 256

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_TCB OSTCBTbl[12U]
   \                     OSTCBTbl:
   \   000000                DS8 984

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT8U OSTickStepState
   \                     OSTickStepState:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_Q *__data20 OSQFreeList
   \                     OSQFreeList:
   \   000000                DS8 4

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   OS_Q OSQTbl[5U]
   \                     OSQTbl:
   \   000000                DS8 120

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \   INT32U volatile OSTime
   \                     OSTime:
   \   000000                DS8 4

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     27          #endif
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                       PRIORITY RESOLUTION TABLE
     32          *
     33          * Note: Index into table is bit pattern to resolve highest priority
     34          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     35          *********************************************************************************************************
     36          */
     37          

   \                                 In  segment DATA20_C, align 1, align-sorted
     38          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   000000   000001000200 DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \            010003000100
   \            020001000400
   \            0100020001  
   \   000017   000300010002 DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \            000100050001
   \            000200010003
   \            0001000200  
   \   00002E   010004000100 DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \            020001000300
   \            010002000100
   \            0600010002  
   \   000045   000100030001 DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \            000200010004
   \            000100020001
   \            0003000100  
   \   00005C   020001000500 DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \            010002000100
   \            030001000200
   \            0100040001  
   \   000073   000200010003 DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \            000100020001
   \            000700010002
   \            0001000300  
   \   00008A   010002000100 DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \            040001000200
   \            010003000100
   \            0200010005  
   \   0000A1   000100020001 DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \            000300010002
   \            000100040001
   \            0002000100  
   \   0000B8   030001000200 DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \            010006000100
   \            020001000300
   \            0100020001  
   \   0000CF   000400010002 DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \            000100030001
   \            000200010005
   \            0001000200  
   \   0000E6   010003000100 DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \            020001000400
   \            010002000100
   \            0300010002  
   \   0000FD   000100       DC8 0, 1, 0
     39              0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
     40              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
     41              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
     42              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
     43              6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
     44              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
     45              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
     46              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
     47              7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
     48              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
     49              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
     50              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
     51              6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
     52              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
     53              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
     54              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
     55          };
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                       FUNCTION PROTOTYPES
     61          *********************************************************************************************************
     62          */
     63          
     64          static  void  OS_InitEventList(void);
     65          
     66          static  void  OS_InitMisc(void);
     67          
     68          static  void  OS_InitRdyList(void);
     69          
     70          static  void  OS_InitTaskIdle(void);
     71          
     72          #if OS_TASK_STAT_EN > 0u
     73          static  void  OS_InitTaskStat(void);
     74          #endif
     75          
     76          static  void  OS_InitTCBList(void);
     77          
     78          static  void  OS_SchedNew(void);
     79          
     80          /*$PAGE*/
     81          /*
     82          *********************************************************************************************************
     83          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     84          *
     85          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     86          *
     87          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     88          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     89          *                        type is irrelevant.
     90          *
     91          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
     92          *                        mutex, mailbox or queue.
     93          *
     94          *              perr      is a pointer to an error code that can contain one of the following values:
     95          *
     96          *                        OS_ERR_NONE                if the name was copied to 'pname'
     97          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
     98          *                                                   control block type.
     99          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    100          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    101          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    102          *
    103          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    104          *********************************************************************************************************
    105          */
    106          
    107          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
    108          INT8U  OSEventNameGet (OS_EVENT   *pevent,
    109                                 INT8U     **pname,
    110                                 INT8U      *perr)
    111          {
    112              INT8U      len;
    113          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    114              OS_CPU_SR  cpu_sr = 0u;
    115          #endif
    116          
    117          
    118          
    119          #ifdef OS_SAFETY_CRITICAL
    120              if (perr == (INT8U *)0) {
    121                  OS_SAFETY_CRITICAL_EXCEPTION();
    122              }
    123          #endif
    124          
    125          #if OS_ARG_CHK_EN > 0u
    126              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    127                  *perr = OS_ERR_PEVENT_NULL;
    128                  return (0u);
    129              }
    130              if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
    131                  *perr = OS_ERR_PNAME_NULL;
    132                  return (0u);
    133              }
    134          #endif
    135              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
    136                  *perr  = OS_ERR_NAME_GET_ISR;
    137                  return (0u);
    138              }
    139              switch (pevent->OSEventType) {
    140                  case OS_EVENT_TYPE_SEM:
    141                  case OS_EVENT_TYPE_MUTEX:
    142                  case OS_EVENT_TYPE_MBOX:
    143                  case OS_EVENT_TYPE_Q:
    144                       break;
    145          
    146                  default:
    147                       *perr = OS_ERR_EVENT_TYPE;
    148                       return (0u);
    149              }
    150              OS_ENTER_CRITICAL();
    151              *pname = pevent->OSEventName;
    152              len    = OS_StrLen(*pname);
    153              OS_EXIT_CRITICAL();
    154              *perr  = OS_ERR_NONE;
    155              return (len);
    156          }
    157          #endif
    158          
    159          /*$PAGE*/
    160          /*
    161          *********************************************************************************************************
    162          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    163          *
    164          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    165          *
    166          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    167          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    168          *                        matter the actual type.
    169          *
    170          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    171          *                        mutex, mailbox or queue.
    172          *
    173          *              perr      is a pointer to an error code that can contain one of the following values:
    174          *
    175          *                        OS_ERR_NONE                if the requested task is resumed
    176          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    177          *                                                   control block type.
    178          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    179          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    180          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    181          *
    182          * Returns    : None
    183          *********************************************************************************************************
    184          */
    185          
    186          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
    187          void  OSEventNameSet (OS_EVENT  *pevent,
    188                                INT8U     *pname,
    189                                INT8U     *perr)
    190          {
    191          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    192              OS_CPU_SR  cpu_sr = 0u;
    193          #endif
    194          
    195          
    196          
    197          #ifdef OS_SAFETY_CRITICAL
    198              if (perr == (INT8U *)0) {
    199                  OS_SAFETY_CRITICAL_EXCEPTION();
    200              }
    201          #endif
    202          
    203          #if OS_ARG_CHK_EN > 0u
    204              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    205                  *perr = OS_ERR_PEVENT_NULL;
    206                  return;
    207              }
    208              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    209                  *perr = OS_ERR_PNAME_NULL;
    210                  return;
    211              }
    212          #endif
    213              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
    214                  *perr = OS_ERR_NAME_SET_ISR;
    215                  return;
    216              }
    217              switch (pevent->OSEventType) {
    218                  case OS_EVENT_TYPE_SEM:
    219                  case OS_EVENT_TYPE_MUTEX:
    220                  case OS_EVENT_TYPE_MBOX:
    221                  case OS_EVENT_TYPE_Q:
    222                       break;
    223          
    224                  default:
    225                       *perr = OS_ERR_EVENT_TYPE;
    226                       return;
    227              }
    228              OS_ENTER_CRITICAL();
    229              pevent->OSEventName = pname;
    230              OS_EXIT_CRITICAL();
    231              *perr = OS_ERR_NONE;
    232          }
    233          #endif
    234          
    235          /*$PAGE*/
    236          /*
    237          *********************************************************************************************************
    238          *                                      PEND ON MULTIPLE EVENTS
    239          *
    240          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    241          *              pend call, then all available events are returned as ready.  If the task must pend on the
    242          *              multiple events, then only the first posted or aborted event is returned as ready.
    243          *
    244          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    245          *
    246          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    247          *                            or ready.  The size of the array MUST be greater than or equal to the size
    248          *                            of the 'pevents_pend' array, including terminating NULL.
    249          *
    250          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    251          *                            events.  The size of the array MUST be greater than or equal to the size of
    252          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    253          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    254          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    255          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    256          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    257          *
    258          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    259          *                            wait for the resources up to the amount of time specified by this argument.
    260          *                            If you specify 0, however, your task will wait forever for the specified
    261          *                            events or, until the resources becomes available (or the events occur).
    262          *
    263          *              perr          is a pointer to where an error message will be deposited.  Possible error
    264          *                            messages are:
    265          *
    266          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    267          *                                                or, the events you are waiting for occurred; check the
    268          *                                                'pevents_rdy' array for which events are available.
    269          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    270          *                                                'pevents_rdy' array for which events were aborted.
    271          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    272          *                                                'timeout'.
    273          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
    274          *                                                NULL pointer.
    275          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
    276          *                                                mailboxes, and/or queues.
    277          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    278          *                                                would lead to a suspension.
    279          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    280          *
    281          * Returns    : >  0          the number of events returned as ready or aborted.
    282          *              == 0          if no events are returned as ready because of timeout or upon error.
    283          *
    284          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
    285          *
    286          *                        semaphores, mailboxes, queues
    287          *
    288          *                 b. Return ALL available events and messages, if any
    289          *
    290          *                 c. Add    current task priority as pending to   each events's wait list
    291          *                      Performed in OS_EventTaskWaitMulti()
    292          *
    293          *                 d. Wait on any of multiple events
    294          *
    295          *                 e. Remove current task priority as pending from each events's wait list
    296          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    297          *
    298          *                 f. Return any event posted or aborted, if any
    299          *                      else
    300          *                    Return timeout
    301          *
    302          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
    303          *                 case of any error(s).
    304          *********************************************************************************************************
    305          */
    306          /*$PAGE*/
    307          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
    308          INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
    309                                    OS_EVENT  **pevents_rdy,
    310                                    void      **pmsgs_rdy,
    311                                    INT32U      timeout,
    312                                    INT8U      *perr)
    313          {
    314              OS_EVENT  **pevents;
    315              OS_EVENT   *pevent;
    316          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    317              OS_Q       *pq;
    318          #endif
    319              BOOLEAN     events_rdy;
    320              INT16U      events_rdy_nbr;
    321              INT8U       events_stat;
    322          #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
    323              OS_CPU_SR   cpu_sr = 0u;
    324          #endif
    325          
    326          
    327          
    328          #ifdef OS_SAFETY_CRITICAL
    329              if (perr == (INT8U *)0) {
    330                  OS_SAFETY_CRITICAL_EXCEPTION();
    331              }
    332          #endif
    333          
    334          #if (OS_ARG_CHK_EN > 0u)
    335              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    336                 *perr =  OS_ERR_PEVENT_NULL;
    337                  return (0u);
    338              }
    339              if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
    340                 *perr =  OS_ERR_PEVENT_NULL;
    341                  return (0u);
    342              }
    343              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    344                 *perr =  OS_ERR_PEVENT_NULL;
    345                  return (0u);
    346              }
    347              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    348                 *perr =  OS_ERR_PEVENT_NULL;
    349                  return (0u);
    350              }
    351          #endif
    352          
    353             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
    354          
    355              pevents     =  pevents_pend;
    356              pevent      = *pevents;
    357              while  (pevent != (OS_EVENT *)0) {
    358                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
    359          #if (OS_SEM_EN  > 0u)
    360                      case OS_EVENT_TYPE_SEM:
    361                           break;
    362          #endif
    363          #if (OS_MBOX_EN > 0u)
    364                      case OS_EVENT_TYPE_MBOX:
    365                           break;
    366          #endif
    367          #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
    368                      case OS_EVENT_TYPE_Q:
    369                           break;
    370          #endif
    371          
    372                      case OS_EVENT_TYPE_MUTEX:
    373                      case OS_EVENT_TYPE_FLAG:
    374                      default:
    375                          *perr = OS_ERR_EVENT_TYPE;
    376                           return (0u);
    377                  }
    378                  pevents++;
    379                  pevent = *pevents;
    380              }
    381          
    382              if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
    383                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
    384                  return (0u);
    385              }
    386              if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
    387                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
    388                  return (0u);
    389              }
    390          
    391          /*$PAGE*/
    392              OS_ENTER_CRITICAL();
    393              events_rdy     =  OS_FALSE;
    394              events_rdy_nbr =  0u;
    395              events_stat    =  OS_STAT_RDY;
    396              pevents        =  pevents_pend;
    397              pevent         = *pevents;
    398              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
    399                  switch (pevent->OSEventType) {
    400          #if (OS_SEM_EN > 0u)
    401                      case OS_EVENT_TYPE_SEM:
    402                           if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
    403                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
    404                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
    405                                events_rdy   =  OS_TRUE;
    406                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
    407                                events_rdy_nbr++;
    408          
    409                           } else {
    410                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
    411                           }
    412                           break;
    413          #endif
    414          
    415          #if (OS_MBOX_EN > 0u)
    416                      case OS_EVENT_TYPE_MBOX:
    417                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
    418                                                                  /* ... return available message,           ... */
    419                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
    420                               pevent->OSEventPtr  = (void *)0;
    421                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
    422                                events_rdy         =  OS_TRUE;
    423                                events_rdy_nbr++;
    424          
    425                           } else {
    426                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
    427                           }
    428                           break;
    429          #endif
    430          
    431          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    432                      case OS_EVENT_TYPE_Q:
    433                           pq = (OS_Q *)pevent->OSEventPtr;
    434                           if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
    435                                                                  /* ... return available message,           ... */
    436                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
    437                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
    438                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
    439                               }
    440                               pq->OSQEntries--;                  /* Update number of queue entries              */
    441                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
    442                                events_rdy   = OS_TRUE;
    443                                events_rdy_nbr++;
    444          
    445                           } else {
    446                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
    447                           }
    448                           break;
    449          #endif
    450          
    451                      case OS_EVENT_TYPE_MUTEX:
    452                      case OS_EVENT_TYPE_FLAG:
    453                      default:
    454                           OS_EXIT_CRITICAL();
    455                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
    456                          *perr        =  OS_ERR_EVENT_TYPE;
    457                           return (events_rdy_nbr);
    458                  }
    459                  pevents++;
    460                  pevent = *pevents;
    461              }
    462          
    463              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
    464                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
    465                  OS_EXIT_CRITICAL();
    466                 *perr        =  OS_ERR_NONE;
    467                  return (events_rdy_nbr);
    468              }
    469          /*$PAGE*/
    470                                                                  /* Otherwise, must wait until any event occurs */
    471              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    472                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
    473              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    474              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
    475              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
    476          
    477              OS_EXIT_CRITICAL();
    478              OS_Sched();                                         /* Find next highest priority task ready       */
    479              OS_ENTER_CRITICAL();
    480          
    481              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
    482                  case OS_STAT_PEND_OK:
    483                  case OS_STAT_PEND_ABORT:
    484                       pevent = OSTCBCur->OSTCBEventPtr;
    485                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
    486                          *pevents_rdy++ =  pevent;               /* ... return available event ...              */
    487                          *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
    488                            events_rdy_nbr++;
    489          
    490                       } else {                                   /* Else NO event available, handle as timeout  */
    491                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
    492                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
    493                       }
    494          			 break;
    495          
    496                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    497                  default:                                        /* ... remove task from events' wait lists     */
    498                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
    499                       break;
    500              }
    501          
    502              switch (OSTCBCur->OSTCBStatPend) {
    503                  case OS_STAT_PEND_OK:
    504                       switch (pevent->OSEventType) {             /* Return event's message                      */
    505          #if (OS_SEM_EN > 0u)
    506                           case OS_EVENT_TYPE_SEM:
    507                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
    508                                break;
    509          #endif
    510          
    511          #if ((OS_MBOX_EN > 0u) ||                 \
    512              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    513                           case OS_EVENT_TYPE_MBOX:
    514                           case OS_EVENT_TYPE_Q:
    515                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
    516                                break;
    517          #endif
    518          
    519                           case OS_EVENT_TYPE_MUTEX:
    520                           case OS_EVENT_TYPE_FLAG:
    521                           default:
    522                                OS_EXIT_CRITICAL();
    523                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
    524                               *perr        =  OS_ERR_EVENT_TYPE;
    525                                return (events_rdy_nbr);
    526                       }
    527                      *perr = OS_ERR_NONE;
    528                       break;
    529          
    530                  case OS_STAT_PEND_ABORT:
    531                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
    532                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
    533                       break;
    534          
    535                  case OS_STAT_PEND_TO:
    536                  default:
    537                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
    538                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
    539                       break;
    540              }
    541          
    542              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
    543              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
    544              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
    545              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    546          #if ((OS_MBOX_EN > 0u) ||                 \
    547              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    548              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
    549          #endif
    550              OS_EXIT_CRITICAL();
    551          
    552              return (events_rdy_nbr);
    553          }
    554          #endif
    555          
    556          /*$PAGE*/
    557          /*
    558          *********************************************************************************************************
    559          *                                             INITIALIZATION
    560          *
    561          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    562          *              creating any uC/OS-II object and, prior to calling OSStart().
    563          *
    564          * Arguments  : none
    565          *
    566          * Returns    : none
    567          *********************************************************************************************************
    568          */
    569          

   \                                 In  segment CODE, align 2
    570          void  OSInit (void)
   \                     OSInit:
    571          {
   \   000000   2183         SUB.W   #0x2, SP
    572              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   000002   ........     CALLA   #OSInitHookBegin
    573          
    574              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   000006   ....8243.... MOVX.W  #0x0, &OSTime
   \   00000C   ....8243.... MOVX.W  #0x0, &OSTime + 2
   \   000012   ....C243.... MOVX.B  #0x0, &OSIntNesting
   \   000018   ....C243.... MOVX.B  #0x0, &OSLockNesting
   \   00001E   ....C243.... MOVX.B  #0x0, &OSTaskCtr
   \   000024   ....C243.... MOVX.B  #0x0, &OSRunning
   \   00002A   ....8243.... MOVX.W  #0x0, &OSCtxSwCtr
   \   000030   ....8243.... MOVX.W  #0x0, &OSCtxSwCtr + 2
   \   000036   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_15:
   \   00003A   ....8243.... MOVX.W  #0x0, &OSIdleCtrRun
   \   000040   ....8243.... MOVX.W  #0x0, &OSIdleCtrRun + 2
   \   000046   ....8243.... MOVX.W  #0x0, &OSIdleCtrMax
   \   00004C   ....8243.... MOVX.W  #0x0, &OSIdleCtrMax + 2
   \   000052   ....C243.... MOVX.B  #0x0, &OSStatRdy
    575          
    576              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   000058   ....C243.... MOVX.B  #0x0, &OSRdyGrp
   \   00005E   ........     MOVA    #OSRdyTbl, R15
   \                     ??OSInit_0:
   \   000062   CF430000     MOV.B   #0x0, 0(R15)
   \   000066   CF430100     MOV.B   #0x0, 0x1(R15)
   \   00006A   EF03         ADDA    #0x2, R15
   \   00006C   ........     CMPA    #OSRdyTbl + 8, R15
   \   000070   F823         JNE     ??OSInit_0
   \   000072   ....C243.... MOVX.B  #0x0, &OSPrioCur
   \   000078   ....C243.... MOVX.B  #0x0, &OSPrioHighRdy
   \   00007E   ....C243.... MOVX.A  #0x0, &OSTCBHighRdy
   \   000084   ....C243.... MOVX.A  #0x0, &OSTCBCur
    577          
    578              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   00008A   ........     CALLA   #OS_InitTCBList
    579          
    580              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   00008E   ........     CALLA   #OS_InitEventList
    581          
    582          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    583              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   000092   ........     CALLA   #OS_FlagInit
    584          #endif
    585          
    586          #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
    587              OS_MemInit();                                                /* Initialize the memory manager            */
    588          #endif
    589          
    590          #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
    591              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   000096   ........     CALLA   #OS_QInit
    592          #endif
    593          
    594              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   00009A   30120300     PUSH.W  #0x3
   \   00009E   00184312     PUSHX.A #0x0
   \   0000A2   0312         PUSH.W  #0x0
   \   0000A4   30128000     PUSH.W  #0x80
   \   0000A8   ....7012.... PUSHX.A #OSTaskIdleStk
   \   0000AE   3312         PUSH.W  #0xffff
   \   0000B0   7F403F00     MOV.B   #0x3f, R15
   \   0000B4   ........     MOVA    #OSTaskIdleStk + 254, R14
   \   0000B8   4D43         MOVA    #0x0, R13
   \   0000BA   ........     MOVA    #OS_TaskIdle, R12
   \   0000BE   ........     CALLA   #OSTaskCreateExt
   \   0000C2   0E41         MOV.W   SP, R14
   \   0000C4   3E501100     ADD.W   #0x11, R14
   \   0000C8   ........     MOVA    #`?<Constant "uC/OS-II Idle">`, R13
   \   0000CC   7C403F00     MOV.B   #0x3f, R12
   \   0000D0   ........     CALLA   #OSTaskNameSet
    595          #if OS_TASK_STAT_EN > 0u
    596              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \   0000D4   30120300     PUSH.W  #0x3
   \   0000D8   00184312     PUSHX.A #0x0
   \   0000DC   0312         PUSH.W  #0x0
   \   0000DE   30128000     PUSH.W  #0x80
   \   0000E2   ....7012.... PUSHX.A #OSTaskStatStk
   \   0000E8   3012FEFF     PUSH.W  #0xfffe
   \   0000EC   7F403E00     MOV.B   #0x3e, R15
   \   0000F0   ........     MOVA    #OSTaskStatStk + 254, R14
   \   0000F4   4D43         MOVA    #0x0, R13
   \   0000F6   ........     MOVA    #OS_TaskStat, R12
   \   0000FA   ........     CALLA   #OSTaskCreateExt
   \   0000FE   0E41         MOV.W   SP, R14
   \   000100   3E502000     ADD.W   #0x20, R14
   \   000104   ........     MOVA    #`?<Constant "uC/OS-II Stat">`, R13
   \   000108   7C403E00     MOV.B   #0x3e, R12
   \   00010C   ........     CALLA   #OSTaskNameSet
    597          #endif
    598          
    599          #if OS_TMR_EN > 0u
    600              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    601          #endif
    602          
    603              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   000110   ........     CALLA   #OSInitHookEnd
    604          
    605          #if OS_DEBUG_EN > 0u
    606              OSDebugInit();
    607          #endif
    608          }
   \   000114   31502200     ADD.W   #0x22, SP
   \   000118   1001         RETA
    609          /*$PAGE*/
    610          /*
    611          *********************************************************************************************************
    612          *                                              ENTER ISR
    613          *
    614          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    615          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    616          *              only perform rescheduling at the last nested ISR.
    617          *
    618          * Arguments  : none
    619          *
    620          * Returns    : none
    621          *
    622          * Notes      : 1) This function should be called ith interrupts already disabled
    623          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    624          *                 OSIntNesting has been declared 'global'.
    625          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    626          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    627          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    628          *                 end of the ISR.
    629          *              5) You are allowed to nest interrupts up to 255 levels deep.
    630          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    631          *                 OSIntEnter() is always called with interrupts disabled.
    632          *********************************************************************************************************
    633          */
    634          

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   ....D293.... CMPX.B  #0x1, &OSRunning
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    635          void  OSIntEnter (void)
   \                     OSIntEnter:
    636          {
    637              if (OSRunning == OS_TRUE) {
   \   000000   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_12:
   \   000004   0720         JNE     ??OSIntEnter_0
    638                  if (OSIntNesting < 255u) {
   \   000006   ....F293.... CMPX.B  #0xff, &OSIntNesting
   \   00000C   0324         JEQ     ??OSIntEnter_0
    639                      OSIntNesting++;                      /* Increment ISR nesting level                        */
   \   00000E   ....D253.... ADDX.B  #0x1, &OSIntNesting
    640                  }
    641              }
    642          }
   \                     ??OSIntEnter_0:
   \   000014   1001         RETA
    643          /*$PAGE*/
    644          /*
    645          *********************************************************************************************************
    646          *                                               EXIT ISR
    647          *
    648          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    649          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    650          *              a new, high-priority task, is ready to run.
    651          *
    652          * Arguments  : none
    653          *
    654          * Returns    : none
    655          *
    656          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    657          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    658          *                 end of the ISR.
    659          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    660          *********************************************************************************************************
    661          */
    662          

   \                                 In  segment CODE, align 2
    663          void  OSIntExit (void)
   \                     OSIntExit:
    664          {
   \   000000   0A14         PUSHM.A #0x1, R10
    665          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    666              OS_CPU_SR  cpu_sr = 0u;
    667          #endif
    668          
    669          
    670          
    671              if (OSRunning == OS_TRUE) {
   \   000002   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_11:
   \   000006   1920         JNE     ??OSIntExit_0
    672                  OS_ENTER_CRITICAL();
   \   000008   ........     CALLA   #OSCPUSaveSR
   \   00000C   0A4C         MOV.W   R12, R10
    673                  if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
   \   00000E   ........     MOVA    #OSIntNesting, R15
   \   000012   CF930000     CMP.B   #0x0, 0(R15)
   \   000016   0324         JEQ     ??OSIntExit_1
    674                      OSIntNesting--;
   \   000018   FF530000     ADD.B   #0xff, 0(R15)
    675                  }
    676                  if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
   \   00001C   0B20         JNE     ??OSIntExit_2
    677                      if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
   \                     ??OSIntExit_1:
   \   00001E   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   000024   0720         JNE     ??OSIntExit_2
    678                          OS_SchedNew();
   \   000026   ........     CALLA   #?Subroutine2
    679                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
    680                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \                     ??CrossCallReturnLabel_5:
   \   00002A   0424         JEQ     ??OSIntExit_2
    681          #if OS_TASK_PROFILE_EN > 0u
    682                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00002C   ........     CALLA   #?Subroutine3
    683          #endif
    684                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
    685                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \                     ??CrossCallReturnLabel_7:
   \   000030   ........     CALLA   #OSIntCtxSw
    686                          }
    687                      }
    688                  }
    689                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2:
   \   000034   0C4A         MOV.W   R10, R12
   \   000036   ........     CALLA   #OSCPURestoreSR
    690              }
    691          }
   \                     ??OSIntExit_0:
   \   00003A   0A16         POPM.A  #0x1, R10
   \   00003C   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   9F533600     ADD.W   #0x1, 0x36(R15)
   \   000004   8F633800     ADDC.W  #0x0, 0x38(R15)
   \   000008   ....9253.... ADDX.W  #0x1, &OSCtxSwCtr
   \   00000E   ....8263.... ADDCX.W #0x0, &OSCtxSwCtr + 2
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #OS_SchedNew
   \   000004   ....5F42.... MOVX.B  &OSPrioHighRdy, R15
   \   00000A   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_14:
   \   00000E   ....D292.... CMPX.B  &OSPrioCur, &OSPrioHighRdy
   \            ....        
   \   000016   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   4F06         RLAM.A  #0x2, R15
   \   000002   ....5F4F.... MOVX.A  OSTCBPrioTbl(R15), R15
   \   000008   ........     MOVA    R15, &OSTCBHighRdy
   \   00000C   1001         RETA
    692          /*$PAGE*/
    693          /*
    694          *********************************************************************************************************
    695          *                            INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    696          *
    697          * Description: This function is called by the application code to indicate that all initialization has
    698          *              been completed and that kernel objects are no longer allowed to be created.
    699          *
    700          * Arguments  : none
    701          *
    702          * Returns    : none
    703          *
    704          * Note(s)    : 1) You should call this function when you no longer want to allow application code to
    705          *                 create kernel objects.
    706          *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
    707          *********************************************************************************************************
    708          */
    709          
    710          #ifdef OS_SAFETY_CRITICAL_IEC61508
    711          void  OSSafetyCriticalStart (void)
    712          {
    713              OSSafetyCriticalStartFlag = OS_TRUE;
    714          }
    715          
    716          #endif
    717          
    718          /*$PAGE*/
    719          /*
    720          *********************************************************************************************************
    721          *                                          PREVENT SCHEDULING
    722          *
    723          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    724          *              to prevent context switches until you are ready to permit context switching.
    725          *
    726          * Arguments  : none
    727          *
    728          * Returns    : none
    729          *
    730          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    731          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    732          *********************************************************************************************************
    733          */
    734          
    735          #if OS_SCHED_LOCK_EN > 0u

   \                                 In  segment CODE, align 2
    736          void  OSSchedLock (void)
   \                     OSSchedLock:
    737          {
    738          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    739              OS_CPU_SR  cpu_sr = 0u;
    740          #endif
    741          
    742          
    743          
    744              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   000000   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_10:
   \   000004   0F20         JNE     ??OSSchedLock_0
    745                  OS_ENTER_CRITICAL();
   \   000006   ........     CALLA   #OSCPUSaveSR
    746                  if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
   \   00000A   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   000010   0720         JNE     ??OSSchedLock_1
    747                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   000012   ....F293.... CMPX.B  #0xff, &OSLockNesting
   \   000018   0324         JEQ     ??OSSchedLock_1
    748                          OSLockNesting++;                 /* Increment lock nesting level                       */
   \   00001A   ....D253.... ADDX.B  #0x1, &OSLockNesting
    749                      }
    750                  }
    751                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1:
   \   000020   ........     CALLA   #OSCPURestoreSR
    752              }
    753          }
   \                     ??OSSchedLock_0:
   \   000024   1001         RETA
    754          #endif
    755          
    756          /*$PAGE*/
    757          /*
    758          *********************************************************************************************************
    759          *                                          ENABLE SCHEDULING
    760          *
    761          * Description: This function is used to re-allow rescheduling.
    762          *
    763          * Arguments  : none
    764          *
    765          * Returns    : none
    766          *
    767          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    768          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    769          *********************************************************************************************************
    770          */
    771          
    772          #if OS_SCHED_LOCK_EN > 0u

   \                                 In  segment CODE, align 2
    773          void  OSSchedUnlock (void)
   \                     OSSchedUnlock:
    774          {
    775          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    776              OS_CPU_SR  cpu_sr = 0u;
    777          #endif
    778          
    779          
    780          
    781              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   000000   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_9:
   \   000004   1420         JNE     ??OSSchedUnlock_0
    782                  OS_ENTER_CRITICAL();
   \   000006   ........     CALLA   #OSCPUSaveSR
    783                  if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
   \   00000A   ........     MOVA    #OSLockNesting, R15
   \   00000E   CF930000     CMP.B   #0x0, 0(R15)
   \   000012   0B24         JEQ     ??OSSchedUnlock_1
    784                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   000014   FF530000     ADD.B   #0xff, 0(R15)
    785                      if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
   \   000018   0820         JNE     ??OSSchedUnlock_1
    786                          if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
   \   00001A   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   000020   0420         JNE     ??OSSchedUnlock_1
    787                              OS_EXIT_CRITICAL();
   \   000022   ........     CALLA   #OSCPURestoreSR
    788                              OS_Sched();                            /* See if a HPT is ready                    */
   \   000026   ........     BRA     #OS_Sched
    789                          } else {
    790                              OS_EXIT_CRITICAL();
    791                          }
    792                      } else {
    793                          OS_EXIT_CRITICAL();
    794                      }
    795                  } else {
    796                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1:
   \   00002A   ........     CALLA   #OSCPURestoreSR
    797                  }
    798              }
    799          }
   \                     ??OSSchedUnlock_0:
   \   00002E   1001         RETA
    800          #endif
    801          
    802          /*$PAGE*/
    803          /*
    804          *********************************************************************************************************
    805          *                                          START MULTITASKING
    806          *
    807          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    808          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    809          *              and you MUST have created at least one task.
    810          *
    811          * Arguments  : none
    812          *
    813          * Returns    : none
    814          *
    815          * Note       : OSStartHighRdy() MUST:
    816          *                 a) Call OSTaskSwHook() then,
    817          *                 b) Set OSRunning to OS_TRUE.
    818          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    819          *                 d_ Execute the task.
    820          *********************************************************************************************************
    821          */
    822          

   \                                 In  segment CODE, align 2
    823          void  OSStart (void)
   \                     OSStart:
    824          {
    825              if (OSRunning == OS_FALSE) {
   \   000000   ....C293.... CMPX.B  #0x0, &OSRunning
   \   000006   0E20         JNE     ??OSStart_0
    826                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   000008   ........     CALLA   #OS_SchedNew
    827                  OSPrioCur     = OSPrioHighRdy;
   \   00000C   ....5F42.... MOVX.B  &OSPrioHighRdy, R15
   \   000012   ....C24F.... MOVX.B  R15, &OSPrioCur
    828                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   000018   ........     CALLA   #?Subroutine5
    829                  OSTCBCur      = OSTCBHighRdy;
   \                     ??CrossCallReturnLabel_13:
   \   00001C   ........     MOVA    R15, &OSTCBCur
    830                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   000020   ........     CALLA   #OSStartHighRdy
    831              }
    832          }
   \                     ??OSStart_0:
   \   000024   1001         RETA
    833          /*$PAGE*/
    834          /*
    835          *********************************************************************************************************
    836          *                                        STATISTICS INITIALIZATION
    837          *
    838          * Description: This function is called by your application to establish CPU usage by first determining
    839          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    840          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    841          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    842          *              determined by:
    843          *
    844          *                                             OSIdleCtr
    845          *                 CPU Usage (%) = 100 * (1 - ------------)
    846          *                                            OSIdleCtrMax
    847          *
    848          * Arguments  : none
    849          *
    850          * Returns    : none
    851          *********************************************************************************************************
    852          */
    853          
    854          #if OS_TASK_STAT_EN > 0u

   \                                 In  segment CODE, align 2
    855          void  OSStatInit (void)
   \                     OSStatInit:
    856          {
    857          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    858              OS_CPU_SR  cpu_sr = 0u;
    859          #endif
    860          
    861          
    862          
    863              OSTimeDly(2u);                               /* Synchronize with clock tick                        */
   \   000000   2C43         MOV.W   #0x2, R12
   \   000002   ........     CALLA   #?Subroutine1
    864              OS_ENTER_CRITICAL();
    865              OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
   \                     ??CrossCallReturnLabel_3:
   \   000006   ........     CALLA   #?Subroutine0
    866              OS_EXIT_CRITICAL();
    867              OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
   \                     ??CrossCallReturnLabel_0:
   \   00000A   3C406400     MOV.W   #0x64, R12
   \   00000E   ........     CALLA   #?Subroutine1
    868              OS_ENTER_CRITICAL();
    869              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \                     ??CrossCallReturnLabel_2:
   \   000012   ....9242.... MOVX.W  &OSIdleCtr, &OSIdleCtrMax
   \            ....        
   \   00001A   ....9242.... MOVX.W  &OSIdleCtr + 2, &OSIdleCtrMax + 2
   \            ....        
    870              OSStatRdy    = OS_TRUE;
   \   000022   ....D243.... MOVX.B  #0x1, &OSStatRdy
    871              OS_EXIT_CRITICAL();
   \   000028   ........     BRA     #OSCPURestoreSR
    872          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   0D43         MOV.W   #0x0, R13
   \   000002   ........     CALLA   #OSTimeDly
   \   000006   ........     BRA     #OSCPUSaveSR

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_16:
   \   000004   ........     BRA     #OSCPURestoreSR

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   ....8243.... MOVX.W  #0x0, &OSIdleCtr
   \   000006   ....8243.... MOVX.W  #0x0, &OSIdleCtr + 2
   \   00000C   1001         RETA
    873          #endif
    874          /*$PAGE*/
    875          /*
    876          *********************************************************************************************************
    877          *                                         PROCESS SYSTEM TICK
    878          *
    879          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    880          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    881          *              called by a high priority task.
    882          *
    883          * Arguments  : none
    884          *
    885          * Returns    : none
    886          *********************************************************************************************************
    887          */
    888          

   \                                 In  segment CODE, align 2
    889          void  OSTimeTick (void)
   \                     OSTimeTick:
    890          {
   \   000000   0A14         PUSHM.A #0x1, R10
    891              OS_TCB    *ptcb;
    892          #if OS_TICK_STEP_EN > 0u
    893              BOOLEAN    step;
    894          #endif
    895          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
    896              OS_CPU_SR  cpu_sr = 0u;
    897          #endif
    898          
    899          
    900          
    901          #if OS_TIME_TICK_HOOK_EN > 0u
    902              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   000002   ........     CALLA   #OSTimeTickHook
    903          #endif
    904          #if OS_TIME_GET_SET_EN > 0u
    905              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   000006   ........     CALLA   #OSCPUSaveSR
    906              OSTime++;
   \   00000A   ....9253.... ADDX.W  #0x1, &OSTime
   \   000010   ....8263.... ADDCX.W #0x0, &OSTime + 2
    907              OS_EXIT_CRITICAL();
   \   000016   ........     CALLA   #OSCPURestoreSR
    908          #endif
    909              if (OSRunning == OS_TRUE) {
   \   00001A   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_8:
   \   00001E   4420         JNE     ??OSTimeTick_5
    910          #if OS_TICK_STEP_EN > 0u
    911                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   000020   ........     MOVA    #OSTickStepState, R15
   \   000024   6E4F         MOV.B   @R15, R14
   \   000026   4E83         SUB.B   #0x0, R14
   \   000028   0924         JEQ     ??OSTimeTick_6
   \   00002A   5E83         SUB.B   #0x1, R14
   \   00002C   3D24         JEQ     ??OSTimeTick_5
   \   00002E   5E83         SUB.B   #0x1, R14
   \   000030   0320         JNE     ??OSTimeTick_4
    912                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    913                           step = OS_TRUE;
    914                           break;
    915          
    916                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    917                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    918                           break;
    919          
    920                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    921                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
    922                           OSTickStepState = OS_TICK_STEP_WAIT;
   \   000032   DF430000     MOV.B   #0x1, 0(R15)
    923                           break;
   \   000036   023C         JMP     ??OSTimeTick_6
    924          
    925                      default:                                       /* Invalid case, correct situation              */
    926                           step            = OS_TRUE;
    927                           OSTickStepState = OS_TICK_STEP_DIS;
   \                     ??OSTimeTick_4:
   \   000038   CF430000     MOV.B   #0x0, 0(R15)
    928                           break;
    929                  }
    930                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
    931                      return;
    932                  }
    933          #endif
    934                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_6:
   \   00003C   ........     MOVA    &OSTCBList, R10
   \   000040   143C         JMP     ??OSTimeTick_7
    935                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
    936                      OS_ENTER_CRITICAL();
    937                      if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
    938                          ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
    939                          if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
    940          
    941                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    942                                  ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    943                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    944                              } else {
    945                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_1:
   \   000042   4E43         MOV.B   #0x0, R14
   \                     ??OSTimeTick_2:
   \   000044   CA4E2F00     MOV.B   R14, 0x2f(R10)
    946                              }
    947          
    948                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \   000048   FAB22E00     BIT.B   #0x8, 0x2e(R10)
   \   00004C   0A2C         JC      ??OSTimeTick_0
    949                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   00004E   ....D2DA3400 BISX.B  0x34(R10), &OSRdyGrp
   \            ....        
    950                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000056   5F4A3200     MOV.B   0x32(R10), R15
   \   00005A   ....DFDA3300 BISX.B  0x33(R10), OSRdyTbl(R15)
   \            ....        
    951                              }
    952                          }
    953                      }
    954                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_0:
   \   000062   3A0A1400     MOVA    0x14(R10), R10
    955                      OS_EXIT_CRITICAL();
   \   000066   ........     CALLA   #OSCPURestoreSR
   \                     ??OSTimeTick_7:
   \   00006A   FA903F003000 CMP.B   #0x3f, 0x30(R10)
   \   000070   1B24         JEQ     ??OSTimeTick_5
   \   000072   ........     CALLA   #OSCPUSaveSR
   \   000076   1F4A2A00     MOV.W   0x2a(R10), R15
   \   00007A   1FDA2C00     BIS.W   0x2c(R10), R15
   \   00007E   0F93         CMP.W   #0x0, R15
   \   000080   F027         JEQ     ??OSTimeTick_0
   \   000082   BA532A00     ADD.W   #0xffff, 0x2a(R10)
   \   000086   BA632C00     ADDC.W  #0xffff, 0x2c(R10)
   \   00008A   1F4A2A00     MOV.W   0x2a(R10), R15
   \   00008E   1FDA2C00     BIS.W   0x2c(R10), R15
   \   000092   0F93         CMP.W   #0x0, R15
   \   000094   E623         JNE     ??OSTimeTick_0
   \   000096   FAB037002E00 BIT.B   #0x37, 0x2e(R10)
   \   00009C   D227         JEQ     ??OSTimeTick_1
   \   00009E   FAF0C8002E00 AND.B   #0xc8, 0x2e(R10)
   \   0000A4   5E43         MOV.B   #0x1, R14
   \   0000A6   CE3F         JMP     ??OSTimeTick_2
    956                  }
    957              }
   \                     ??OSTimeTick_5:
   \   0000A8   0A16         POPM.A  #0x1, R10
   \   0000AA   1001         RETA
    958          }
    959          
    960          /*$PAGE*/
    961          /*
    962          *********************************************************************************************************
    963          *                                             GET VERSION
    964          *
    965          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    966          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    967          *              would be returned as 200.
    968          *
    969          * Arguments  : none
    970          *
    971          * Returns    : the version number of uC/OS-II multiplied by 100.
    972          *********************************************************************************************************
    973          */
    974          

   \                                 In  segment CODE, align 2
    975          INT16U  OSVersion (void)
   \                     OSVersion:
    976          {
    977              return (OS_VERSION);
   \   000000   3C402301     MOV.W   #0x123, R12
   \   000004   1001         RETA
    978          }
    979          
    980          /*$PAGE*/
    981          /*
    982          *********************************************************************************************************
    983          *                                            DUMMY FUNCTION
    984          *
    985          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    986          *
    987          * Arguments  : none
    988          *
    989          * Returns    : none
    990          *********************************************************************************************************
    991          */
    992          
    993          #if OS_TASK_DEL_EN > 0u

   \                                 In  segment CODE, align 2
    994          void  OS_Dummy (void)
   \                     OS_Dummy:
    995          {
    996          }
   \   000000   1001         RETA
    997          #endif
    998          
    999          /*$PAGE*/
   1000          /*
   1001          *********************************************************************************************************
   1002          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
   1003          *
   1004          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
   1005          *              waiting for an event to occur.
   1006          *
   1007          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
   1008          *
   1009          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
   1010          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
   1011          *                          service functions.
   1012          *
   1013          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
   1014          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
   1015          *
   1016          *              pend_stat   is used to indicate the readied task's pending status:
   1017          *
   1018          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
   1019          *                                               an abort.
   1020          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
   1021          *
   1022          * Returns    : none
   1023          *
   1024          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1025          *********************************************************************************************************
   1026          */
   1027          #if (OS_EVENT_EN)

   \                                 In  segment CODE, align 2
   1028          INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
   \                     OS_EventTaskRdy:
   1029                                  void      *pmsg,
   1030                                  INT8U      msk,
   1031                                  INT8U      pend_stat)
   1032          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   4B4E         MOV.B   R14, R11
   \   000004   484F         MOV.B   R15, R8
   1033              OS_TCB   *ptcb;
   1034              INT8U     y;
   1035              INT8U     x;
   1036              INT8U     prio;
   1037          #if OS_LOWEST_PRIO > 63u
   1038              OS_PRIO  *ptbl;
   1039          #endif
   1040          
   1041          
   1042          #if OS_LOWEST_PRIO <= 63u
   1043              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   000006   5F4C0800     MOV.B   0x8(R12), R15
   \   00000A   ....5A4F.... MOVX.B  OSUnMapTbl(R15), R10
   1044              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
   1045              prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
   \   000010   4E4A         MOV.B   R10, R14
   \   000012                RPT     #0x3
   \   000012   42184A5A     RLAX.B  R10
   \   000016   CF0C         MOVA    R12, R15
   \   000018   EF0E         ADDA    R14, R15
   \   00001A   5F4F0900     MOV.B   0x9(R15), R15
   \   00001E   ....5A5F.... ADDX.B  OSUnMapTbl(R15), R10
   1046          #else
   1047              if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
   1048                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
   1049              } else {
   1050                  y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
   1051              }
   1052              ptbl = &pevent->OSEventTbl[y];
   1053              if ((*ptbl & 0xFFu) != 0u) {
   1054                  x = OSUnMapTbl[*ptbl & 0xFFu];
   1055              } else {
   1056                  x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
   1057              }
   1058              prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
   1059          #endif
   1060          
   1061              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \   000024   4F4A         MOV.B   R10, R15
   \   000026   4F06         RLAM.A  #0x2, R15
   \   000028   ....5F4F.... MOVX.A  OSTCBPrioTbl(R15), R15
   1062              ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
   \   00002E   8F432A00     MOV.W   #0x0, 0x2a(R15)
   \   000032   8F432C00     MOV.W   #0x0, 0x2c(R15)
   1063          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
   1064              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   000036   7F0D2000     MOVA    R13, 0x20(R15)
   1065          #else
   1066              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1067          #endif
   1068              ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
   \   00003A   CFCB2E00     BIC.B   R11, 0x2e(R15)
   1069              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   00003E   CF482F00     MOV.B   R8, 0x2f(R15)
   1070                                                                  /* See if task is ready (could be susp'd)      */
   1071              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   000042   FFB22E00     BIT.B   #0x8, 0x2e(R15)
   \   000046   082C         JC      ??OS_EventTaskRdy_0
   1072                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   000048   ....D2DF3400 BISX.B  0x34(R15), &OSRdyGrp
   \            ....        
   1073                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   000050   ....DEDF3300 BISX.B  0x33(R15), OSRdyTbl(R14)
   \            ....        
   1074              }
   1075          
   1076              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0:
   \   000058   CD0C         MOVA    R12, R13
   \   00005A   CC0F         MOVA    R15, R12
   \   00005C   ........     CALLA   #OS_EventTaskRemove
   1077          #if (OS_EVENT_MULTI_EN > 0u)
   1078              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   1079                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   1080                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   1081              }
   1082          #endif
   1083          
   1084              return (prio);
   \   000060   4C4A         MOV.B   R10, R12
   \   000062   3816         POPM.A  #0x4, R11
   \   000064   1001         RETA
   1085          }
   1086          #endif
   1087          /*$PAGE*/
   1088          /*
   1089          *********************************************************************************************************
   1090          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
   1091          *
   1092          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1093          *              not occurred.
   1094          *
   1095          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1096          *
   1097          * Returns    : none
   1098          *
   1099          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1100          *********************************************************************************************************
   1101          */
   1102          #if (OS_EVENT_EN)

   \                                 In  segment CODE, align 2
   1103          void  OS_EventTaskWait (OS_EVENT *pevent)
   \                     OS_EventTaskWait:
   1104          {
   \   000000   0A14         PUSHM.A #0x1, R10
   1105              INT8U  y;
   1106          
   1107          
   1108              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \   000002   ........     MOVA    #OSTCBCur, R14
   \   000006   0D0E         MOVA    @R14, R13
   \   000008   7D0C1C00     MOVA    R12, 0x1c(R13)
   1109          
   1110              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   00000C   5F4D3200     MOV.B   0x32(R13), R15
   \   000010   CA0C         MOVA    R12, R10
   \   000012   EA0F         ADDA    R15, R10
   \   000014   DADD33000900 BIS.B   0x33(R13), 0x9(R10)
   1111              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00001A   0F0E         MOVA    @R14, R15
   \   00001C   DCDF34000800 BIS.B   0x34(R15), 0x8(R12)
   1112          
   1113              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   000022   0E0E         MOVA    @R14, R14
   \   000024   5F4E3200     MOV.B   0x32(R14), R15
   1114              OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   000028   ....DFCE3300 BICX.B  0x33(R14), OSRdyTbl(R15)
   \            ....        
   1115              if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
   \   000030   ....CF93.... CMPX.B  #0x0, OSRdyTbl(R15)
   \   000036   0420         JNE     ??OS_EventTaskWait_0
   1116                  OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   000038   ....D2CE3400 BICX.B  0x34(R14), &OSRdyGrp
   \            ....        
   1117              }
   1118          }
   \                     ??OS_EventTaskWait_0:
   \   000040   0A16         POPM.A  #0x1, R10
   \   000042   1001         RETA
   1119          #endif
   1120          /*$PAGE*/
   1121          /*
   1122          *********************************************************************************************************
   1123          *                          MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1124          *
   1125          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1126          *              multiple events has not occurred.
   1127          *
   1128          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
   1129          *                               which the task will be waiting for.
   1130          *
   1131          * Returns    : none.
   1132          *
   1133          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1134          *********************************************************************************************************
   1135          */
   1136          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
   1137          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1138          {
   1139              OS_EVENT **pevents;
   1140              OS_EVENT  *pevent;
   1141              INT8U      y;
   1142          
   1143          
   1144              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   1145              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   1146          
   1147              pevents =  pevents_wait;
   1148              pevent  = *pevents;
   1149              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   1150                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   1151                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   1152                  pevents++;
   1153                  pevent = *pevents;
   1154              }
   1155          
   1156              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   1157              OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   1158              if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
   1159                  OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   1160              }
   1161          }
   1162          #endif
   1163          /*$PAGE*/
   1164          /*
   1165          *********************************************************************************************************
   1166          *                                   REMOVE TASK FROM EVENT WAIT LIST
   1167          *
   1168          * Description: Remove a task from an event's wait list.
   1169          *
   1170          * Arguments  : ptcb     is a pointer to the task to remove.
   1171          *
   1172          *              pevent   is a pointer to the event control block.
   1173          *
   1174          * Returns    : none
   1175          *
   1176          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1177          *********************************************************************************************************
   1178          */
   1179          #if (OS_EVENT_EN)

   \                                 In  segment CODE, align 2
   1180          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   \                     OS_EventTaskRemove:
   1181                                    OS_EVENT *pevent)
   1182          {
   1183              INT8U  y;
   1184          
   1185          
   1186              y                       =  ptcb->OSTCBY;
   \   000000   5F4C3200     MOV.B   0x32(R12), R15
   1187              pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
   \   000004   CE0D         MOVA    R13, R14
   \   000006   EE0F         ADDA    R15, R14
   \   000008   DECC33000900 BIC.B   0x33(R12), 0x9(R14)
   1188              if (pevent->OSEventTbl[y] == 0u) {
   \   00000E   CE930900     CMP.B   #0x0, 0x9(R14)
   \   000012   0320         JNE     ??OS_EventTaskRemove_0
   1189                  pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   000014   DDCC34000800 BIC.B   0x34(R12), 0x8(R13)
   1190              }
   1191          }
   \                     ??OS_EventTaskRemove_0:
   \   00001A   1001         RETA
   1192          #endif
   1193          /*$PAGE*/
   1194          /*
   1195          *********************************************************************************************************
   1196          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1197          *
   1198          * Description: Remove a task from multiple events' wait lists.
   1199          *
   1200          * Arguments  : ptcb             is a pointer to the task to remove.
   1201          *
   1202          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1203          *
   1204          * Returns    : none
   1205          *
   1206          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1207          *********************************************************************************************************
   1208          */
   1209          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
   1210          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1211                                         OS_EVENT **pevents_multi)
   1212          {
   1213              OS_EVENT **pevents;
   1214              OS_EVENT  *pevent;
   1215              INT8U      y;
   1216              OS_PRIO    bity;
   1217              OS_PRIO    bitx;
   1218          
   1219          
   1220              y       =  ptcb->OSTCBY;
   1221              bity    =  ptcb->OSTCBBitY;
   1222              bitx    =  ptcb->OSTCBBitX;
   1223              pevents =  pevents_multi;
   1224              pevent  = *pevents;
   1225              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   1226                  pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
   1227                  if (pevent->OSEventTbl[y] == 0u) {
   1228                      pevent->OSEventGrp &= (OS_PRIO)~bity;
   1229                  }
   1230                  pevents++;
   1231                  pevent = *pevents;
   1232              }
   1233          }
   1234          #endif
   1235          /*$PAGE*/
   1236          /*
   1237          *********************************************************************************************************
   1238          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1239          *
   1240          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1241          *
   1242          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1243          *
   1244          * Returns    : none
   1245          *
   1246          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1247          *********************************************************************************************************
   1248          */
   1249          #if (OS_EVENT_EN)

   \                                 In  segment CODE, align 2
   1250          void  OS_EventWaitListInit (OS_EVENT *pevent)
   \                     OS_EventWaitListInit:
   1251          {
   1252              INT8U  i;
   1253          
   1254          
   1255              pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
   \   000000   CC430800     MOV.B   #0x0, 0x8(R12)
   1256              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   000004   CF0C         MOVA    R12, R15
   \   000006   AF000800     ADDA    #0x8, R15
   1257                  pevent->OSEventTbl[i] = 0u;
   \                     ??OS_EventWaitListInit_0:
   \   00000A   CC430900     MOV.B   #0x0, 0x9(R12)
   1258              }
   \   00000E   AC000100     ADDA    #0x1, R12
   \   000012   DC0F         CMPA    R15, R12
   \   000014   FA23         JNE     ??OS_EventWaitListInit_0
   1259          }
   \   000016   1001         RETA
   1260          #endif
   1261          /*$PAGE*/
   1262          /*
   1263          *********************************************************************************************************
   1264          *                                             INITIALIZATION
   1265          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1266          *
   1267          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1268          *
   1269          * Arguments  : none
   1270          *
   1271          * Returns    : none
   1272          *********************************************************************************************************
   1273          */
   1274          

   \                                 In  segment CODE, align 2
   1275          static  void  OS_InitEventList (void)
   \                     OS_InitEventList:
   1276          {
   1277          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
   1278          #if (OS_MAX_EVENTS > 1u)
   1279              INT16U     ix;
   1280              INT16U     ix_next;
   1281              OS_EVENT  *pevent1;
   1282              OS_EVENT  *pevent2;
   1283          
   1284          
   1285              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   \   000000   ........     MOVA    #OSEventTbl, R14
   \   000004   3D40B400     MOV.W   #0xb4, R13
   \   000008   CC0E         MOVA    R14, R12
   \   00000A   ........     CALLA   #OS_MemClr
   1286              for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
   \   00000E   0F43         MOV.W   #0x0, R15
   \   000010   CD0E         MOVA    R14, R13
   1287                  ix_next = ix + 1u;
   1288                  pevent1 = &OSEventTbl[ix];
   1289                  pevent2 = &OSEventTbl[ix_next];
   1290                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_InitEventList_0:
   \   000012   CD430000     MOV.B   #0x0, 0(R13)
   1291                  pevent1->OSEventPtr     = pevent2;
   \   000016   CC0D         MOVA    R13, R12
   \   000018   AC001200     ADDA    #0x12, R12
   \   00001C   7D0C0200     MOVA    R12, 0x2(R13)
   1292          #if OS_EVENT_NAME_EN > 0u
   1293                  pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
   1294          #endif
   1295              }
   \   000020   1F53         ADD.W   #0x1, R15
   \   000022   AD001200     ADDA    #0x12, R13
   \   000026   3F900900     CMP.W   #0x9, R15
   \   00002A   F32B         JNC     ??OS_InitEventList_0
   1296              pevent1                         = &OSEventTbl[ix];
   \   00002C   EF0F         ADDA    R15, R15
   \   00002E   CD0F         MOVA    R15, R13
   \   000030   4F0A         RLAM.A  #0x3, R15
   \   000032   EF0D         ADDA    R13, R15
   \   000034   CD0F         MOVA    R15, R13
   \   000036   CF0E         MOVA    R14, R15
   \   000038   EF0D         ADDA    R13, R15
   1297              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   \   00003A   CF430000     MOV.B   #0x0, 0(R15)
   1298              pevent1->OSEventPtr             = (OS_EVENT *)0;
   \   00003E   0018CF430200 MOVX.A  #0x0, 0x2(R15)
   1299          #if OS_EVENT_NAME_EN > 0u
   1300              pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
   1301          #endif
   1302              OSEventFreeList                 = &OSEventTbl[0];
   \   000044   ........     MOVA    R14, &OSEventFreeList
   1303          #else
   1304              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1305              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1306              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1307          #if OS_EVENT_NAME_EN > 0u
   1308              OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
   1309          #endif
   1310          #endif
   1311          #endif
   1312          }
   \   000048   1001         RETA
   1313          /*$PAGE*/
   1314          /*
   1315          *********************************************************************************************************
   1316          *                                             INITIALIZATION
   1317          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1318          *
   1319          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1320          *
   1321          * Arguments  : none
   1322          *
   1323          * Returns    : none
   1324          *********************************************************************************************************
   1325          */
   1326          
   1327          static  void  OS_InitMisc (void)
   1328          {
   1329          #if OS_TIME_GET_SET_EN > 0u
   1330              OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
   1331          #endif
   1332          
   1333              OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
   1334              OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
   1335          
   1336              OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
   1337          
   1338              OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
   1339          
   1340              OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
   1341              OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
   1342          
   1343          #if OS_TASK_STAT_EN > 0u
   1344              OSIdleCtrRun              = 0uL;
   1345              OSIdleCtrMax              = 0uL;
   1346              OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
   1347          #endif
   1348          
   1349          #ifdef OS_SAFETY_CRITICAL_IEC61508
   1350              OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
   1351          #endif
   1352          }
   1353          /*$PAGE*/
   1354          /*
   1355          *********************************************************************************************************
   1356          *                                             INITIALIZATION
   1357          *                                       INITIALIZE THE READY LIST
   1358          *
   1359          * Description: This function is called by OSInit() to initialize the Ready List.
   1360          *
   1361          * Arguments  : none
   1362          *
   1363          * Returns    : none
   1364          *********************************************************************************************************
   1365          */
   1366          
   1367          static  void  OS_InitRdyList (void)
   1368          {
   1369              INT8U  i;
   1370          
   1371          
   1372              OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
   1373              for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
   1374                  OSRdyTbl[i] = 0u;
   1375              }
   1376          
   1377              OSPrioCur     = 0u;
   1378              OSPrioHighRdy = 0u;
   1379          
   1380              OSTCBHighRdy  = (OS_TCB *)0;
   1381              OSTCBCur      = (OS_TCB *)0;
   1382          }
   1383          
   1384          /*$PAGE*/
   1385          /*
   1386          *********************************************************************************************************
   1387          *                                             INITIALIZATION
   1388          *                                         CREATING THE IDLE TASK
   1389          *
   1390          * Description: This function creates the Idle Task.
   1391          *
   1392          * Arguments  : none
   1393          *
   1394          * Returns    : none
   1395          *********************************************************************************************************
   1396          */
   1397          
   1398          static  void  OS_InitTaskIdle (void)
   1399          {
   1400          #if OS_TASK_NAME_EN > 0u
   1401              INT8U  err;
   1402          #endif
   1403          
   1404          
   1405          #if OS_TASK_CREATE_EXT_EN > 0u
   1406              #if OS_STK_GROWTH == 1u
   1407              (void)OSTaskCreateExt(OS_TaskIdle,
   1408                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1409                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
   1410                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1411                                    OS_TASK_IDLE_ID,
   1412                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1413                                    OS_TASK_IDLE_STK_SIZE,
   1414                                    (void *)0,                                 /* No TCB extension                     */
   1415                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1416              #else
   1417              (void)OSTaskCreateExt(OS_TaskIdle,
   1418                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1419                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1420                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1421                                    OS_TASK_IDLE_ID,
   1422                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
   1423                                    OS_TASK_IDLE_STK_SIZE,
   1424                                    (void *)0,                                 /* No TCB extension                     */
   1425                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1426              #endif
   1427          #else
   1428              #if OS_STK_GROWTH == 1u
   1429              (void)OSTaskCreate(OS_TaskIdle,
   1430                                 (void *)0,
   1431                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
   1432                                 OS_TASK_IDLE_PRIO);
   1433              #else
   1434              (void)OSTaskCreate(OS_TaskIdle,
   1435                                 (void *)0,
   1436                                 &OSTaskIdleStk[0],
   1437                                 OS_TASK_IDLE_PRIO);
   1438              #endif
   1439          #endif
   1440          
   1441          #if OS_TASK_NAME_EN > 0u
   1442              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
   1443          #endif
   1444          }
   1445          /*$PAGE*/
   1446          /*
   1447          *********************************************************************************************************
   1448          *                                             INITIALIZATION
   1449          *                                      CREATING THE STATISTIC TASK
   1450          *
   1451          * Description: This function creates the Statistic Task.
   1452          *
   1453          * Arguments  : none
   1454          *
   1455          * Returns    : none
   1456          *********************************************************************************************************
   1457          */
   1458          
   1459          #if OS_TASK_STAT_EN > 0u
   1460          static  void  OS_InitTaskStat (void)
   1461          {
   1462          #if OS_TASK_NAME_EN > 0u
   1463              INT8U  err;
   1464          #endif
   1465          
   1466          
   1467          #if OS_TASK_CREATE_EXT_EN > 0u
   1468              #if OS_STK_GROWTH == 1u
   1469              (void)OSTaskCreateExt(OS_TaskStat,
   1470                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1471                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
   1472                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1473                                    OS_TASK_STAT_ID,
   1474                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1475                                    OS_TASK_STAT_STK_SIZE,
   1476                                    (void *)0,                                   /* No TCB extension               */
   1477                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1478              #else
   1479              (void)OSTaskCreateExt(OS_TaskStat,
   1480                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1481                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1482                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1483                                    OS_TASK_STAT_ID,
   1484                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
   1485                                    OS_TASK_STAT_STK_SIZE,
   1486                                    (void *)0,                                   /* No TCB extension               */
   1487                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1488              #endif
   1489          #else
   1490              #if OS_STK_GROWTH == 1u
   1491              (void)OSTaskCreate(OS_TaskStat,
   1492                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1493                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
   1494                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1495              #else
   1496              (void)OSTaskCreate(OS_TaskStat,
   1497                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1498                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1499                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1500              #endif
   1501          #endif
   1502          
   1503          #if OS_TASK_NAME_EN > 0u
   1504              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
   1505          #endif
   1506          }
   1507          #endif
   1508          /*$PAGE*/
   1509          /*
   1510          *********************************************************************************************************
   1511          *                                             INITIALIZATION
   1512          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1513          *
   1514          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1515          *
   1516          * Arguments  : none
   1517          *
   1518          * Returns    : none
   1519          *********************************************************************************************************
   1520          */
   1521          

   \                                 In  segment CODE, align 2
   1522          static  void  OS_InitTCBList (void)
   \                     OS_InitTCBList:
   1523          {
   1524              INT8U    ix;
   1525              INT8U    ix_next;
   1526              OS_TCB  *ptcb1;
   1527              OS_TCB  *ptcb2;
   1528          
   1529          
   1530              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   \   000000   ........     MOVA    #OSTCBTbl, R14
   \   000004   3D40D803     MOV.W   #0x3d8, R13
   \   000008   CC0E         MOVA    R14, R12
   \   00000A   ........     CALLA   #OS_MemClr
   1531              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   \   00000E   3D400001     MOV.W   #0x100, R13
   \   000012   ........     MOVA    #OSTCBPrioTbl, R12
   \   000016   ........     CALLA   #OS_MemClr
   1532              for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
   \   00001A   4F43         MOV.B   #0x0, R15
   \   00001C   CD0E         MOVA    R14, R13
   1533                  ix_next =  ix + 1u;
   1534                  ptcb1   = &OSTCBTbl[ix];
   1535                  ptcb2   = &OSTCBTbl[ix_next];
   1536                  ptcb1->OSTCBNext = ptcb2;
   \                     ??OS_InitTCBList_0:
   \   00001E   CC0D         MOVA    R13, R12
   \   000020   AC005200     ADDA    #0x52, R12
   \   000024   7D0C1400     MOVA    R12, 0x14(R13)
   1537          #if OS_TASK_NAME_EN > 0u
   1538                  ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
   \   000028   ....FD40.... MOVX.A  #`?<Constant "?">`, 0x4a(R13)
   \            4A00        
   1539          #endif
   1540              }
   \   000030   5F53         ADD.B   #0x1, R15
   \   000032   AD005200     ADDA    #0x52, R13
   \   000036   7F900B00     CMP.B   #0xb, R15
   \   00003A   F12B         JNC     ??OS_InitTCBList_0
   1541              ptcb1                   = &OSTCBTbl[ix];
   \   00003C   EF0F         ADDA    R15, R15
   \   00003E   CD0F         MOVA    R15, R13
   \   000040   4F0A         RLAM.A  #0x3, R15
   \   000042   ED0F         ADDA    R15, R13
   \   000044   4F06         RLAM.A  #0x2, R15
   \   000046   EF0D         ADDA    R13, R15
   \   000048   CD0F         MOVA    R15, R13
   \   00004A   CF0E         MOVA    R14, R15
   \   00004C   EF0D         ADDA    R13, R15
   1542              ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
   \   00004E   0018CF431400 MOVX.A  #0x0, 0x14(R15)
   1543          #if OS_TASK_NAME_EN > 0u
   1544              ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
   \   000054   ....FF40.... MOVX.A  #`?<Constant "?">`, 0x4a(R15)
   \            4A00        
   1545          #endif
   1546              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   \   00005C   ....C243.... MOVX.A  #0x0, &OSTCBList
   1547              OSTCBFreeList           = &OSTCBTbl[0];
   \   000062   ........     MOVA    R14, &OSTCBFreeList
   1548          }
   \   000066   1001         RETA
   1549          /*$PAGE*/
   1550          /*
   1551          *********************************************************************************************************
   1552          *                                        CLEAR A SECTION OF MEMORY
   1553          *
   1554          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1555          *
   1556          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1557          *
   1558          *              size     is the number of bytes to clear.
   1559          *
   1560          * Returns    : none
   1561          *
   1562          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1563          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1564          *                 of the uses of this function gets close to this limit.
   1565          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1566          *                 of the alignment of the destination.
   1567          *********************************************************************************************************
   1568          */
   1569          

   \                                 In  segment CODE, align 2
   1570          void  OS_MemClr (INT8U  *pdest,
   \                     OS_MemClr:
   1571                           INT16U  size)
   1572          {
   \   000000   0D93         CMP.W   #0x0, R13
   \   000002   0624         JEQ     ??OS_MemClr_1
   1573              while (size > 0u) {
   1574                  *pdest++ = (INT8U)0;
   \                     ??OS_MemClr_0:
   \   000004   CC430000     MOV.B   #0x0, 0(R12)
   \   000008   AC000100     ADDA    #0x1, R12
   1575                  size--;
   \   00000C   3D53         ADD.W   #0xffff, R13
   1576              }
   \   00000E   FA23         JNE     ??OS_MemClr_0
   1577          }
   \                     ??OS_MemClr_1:
   \   000010   1001         RETA
   1578          /*$PAGE*/
   1579          /*
   1580          *********************************************************************************************************
   1581          *                                        COPY A BLOCK OF MEMORY
   1582          *
   1583          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1584          *              location to another.
   1585          *
   1586          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1587          *
   1588          *              psrc     is a pointer to the 'source'      memory block
   1589          *
   1590          *              size     is the number of bytes to copy.
   1591          *
   1592          * Returns    : none
   1593          *
   1594          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1595          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1596          *                 is not a situation that will happen.
   1597          *              2) Note that we can only copy up to 64K bytes of RAM
   1598          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1599          *                 of the alignment of the source and destination.
   1600          *********************************************************************************************************
   1601          */
   1602          

   \                                 In  segment CODE, align 2
   1603          void  OS_MemCopy (INT8U  *pdest,
   \                     OS_MemCopy:
   1604                            INT8U  *psrc,
   1605                            INT16U  size)
   1606          {
   \   000000   0E93         CMP.W   #0x0, R14
   \   000002   0624         JEQ     ??OS_MemCopy_1
   1607              while (size > 0u) {
   1608                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_0:
   \   000004   FC4D0000     MOV.B   @R13+, 0(R12)
   \   000008   AC000100     ADDA    #0x1, R12
   1609                  size--;
   \   00000C   3E53         ADD.W   #0xffff, R14
   1610              }
   \   00000E   FA23         JNE     ??OS_MemCopy_0
   1611          }
   \                     ??OS_MemCopy_1:
   \   000010   1001         RETA
   1612          /*$PAGE*/
   1613          /*
   1614          *********************************************************************************************************
   1615          *                                              SCHEDULER
   1616          *
   1617          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1618          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1619          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1620          *
   1621          * Arguments  : none
   1622          *
   1623          * Returns    : none
   1624          *
   1625          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1626          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1627          *********************************************************************************************************
   1628          */
   1629          

   \                                 In  segment CODE, align 2
   1630          void  OS_Sched (void)
   \                     OS_Sched:
   1631          {
   \   000000   0A14         PUSHM.A #0x1, R10
   1632          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
   1633              OS_CPU_SR  cpu_sr = 0u;
   1634          #endif
   1635          
   1636          
   1637          
   1638              OS_ENTER_CRITICAL();
   \   000002   ........     CALLA   #OSCPUSaveSR
   \   000006   0A4C         MOV.W   R12, R10
   1639              if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
   \   000008   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00000E   0B20         JNE     ??OS_Sched_0
   1640                  if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
   \   000010   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   000016   0720         JNE     ??OS_Sched_0
   1641                      OS_SchedNew();
   \   000018   ........     CALLA   #?Subroutine2
   1642                      OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   1643                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \                     ??CrossCallReturnLabel_4:
   \   00001C   0424         JEQ     ??OS_Sched_0
   1644          #if OS_TASK_PROFILE_EN > 0u
   1645                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00001E   ........     CALLA   #?Subroutine3
   1646          #endif
   1647                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   1648                          OS_TASK_SW();                          /* Perform a context switch                     */
   \                     ??CrossCallReturnLabel_6:
   \   000022   ........     CALLA   #OSCtxSw
   1649                      }
   1650                  }
   1651              }
   1652              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0:
   \   000026   0C4A         MOV.W   R10, R12
   \   000028   ........     CALLA   #OSCPURestoreSR
   1653          }
   \   00002C   0A16         POPM.A  #0x1, R10
   \   00002E   1001         RETA
   1654          
   1655          
   1656          /*
   1657          *********************************************************************************************************
   1658          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1659          *
   1660          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1661          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1662          *
   1663          * Arguments  : none
   1664          *
   1665          * Returns    : none
   1666          *
   1667          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1668          *              2) Interrupts are assumed to be disabled when this function is called.
   1669          *********************************************************************************************************
   1670          */
   1671          

   \                                 In  segment CODE, align 2
   1672          static  void  OS_SchedNew (void)
   \                     OS_SchedNew:
   1673          {
   1674          #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
   1675              INT8U   y;
   1676          
   1677          
   1678              y             = OSUnMapTbl[OSRdyGrp];
   \   000000   ....5F42.... MOVX.B  &OSRdyGrp, R15
   \   000006   ....5F4F.... MOVX.B  OSUnMapTbl(R15), R15
   1679              OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
   \   00000C   4E4F         MOV.B   R15, R14
   \   00000E                RPT     #0x3
   \   00000E   42184E5E     RLAX.B  R14
   \   000012   ....5F4F.... MOVX.B  OSRdyTbl(R15), R15
   \   000018   ....5E5F.... ADDX.B  OSUnMapTbl(R15), R14
   \   00001E   ....C24E.... MOVX.B  R14, &OSPrioHighRdy
   1680          #else                                            /* We support up to 256 tasks                         */
   1681              INT8U     y;
   1682              OS_PRIO  *ptbl;
   1683          
   1684          
   1685              if ((OSRdyGrp & 0xFFu) != 0u) {
   1686                  y = OSUnMapTbl[OSRdyGrp & 0xFFu];
   1687              } else {
   1688                  y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
   1689              }
   1690              ptbl = &OSRdyTbl[y];
   1691              if ((*ptbl & 0xFFu) != 0u) {
   1692                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
   1693              } else {
   1694                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
   1695              }
   1696          #endif
   1697          }
   \   000024   1001         RETA
   1698          
   1699          /*$PAGE*/
   1700          /*
   1701          *********************************************************************************************************
   1702          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1703          *
   1704          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1705          *              (excluding the NUL character).
   1706          *
   1707          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1708          *
   1709          * Returns    : The size of the string (excluding the NUL terminating character)
   1710          *
   1711          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1712          *              2) The string to check must be less than 255 characters long.
   1713          *********************************************************************************************************
   1714          */
   1715          
   1716          #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)

   \                                 In  segment CODE, align 2
   1717          INT8U  OS_StrLen (INT8U *psrc)
   \                     OS_StrLen:
   1718          {
   1719              INT8U  len;
   1720          
   1721          
   1722              len = 0u;
   \   000000   4E43         MOV.B   #0x0, R14
   \   000002   013C         JMP     ??OS_StrLen_1
   1723              while (*psrc != OS_ASCII_NUL) {
   1724                  psrc++;
   1725                  len++;
   \                     ??OS_StrLen_0:
   \   000004   5E53         ADD.B   #0x1, R14
   1726              }
   \                     ??OS_StrLen_1:
   \   000006   7F4C         MOV.B   @R12+, R15
   \   000008   4F93         CMP.B   #0x0, R15
   \   00000A   FC23         JNE     ??OS_StrLen_0
   1727              return (len);
   \   00000C   4C4E         MOV.B   R14, R12
   \   00000E   1001         RETA
   1728          }
   1729          #endif
   1730          /*$PAGE*/
   1731          /*
   1732          *********************************************************************************************************
   1733          *                                              IDLE TASK
   1734          *
   1735          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1736          *              executes because they are ALL waiting for event(s) to occur.
   1737          *
   1738          * Arguments  : none
   1739          *
   1740          * Returns    : none
   1741          *
   1742          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1743          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1744          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1745          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1746          *                 interrupts.
   1747          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1748          *                 power.
   1749          *********************************************************************************************************
   1750          */
   1751          

   \                                 In  segment CODE, align 2
   1752          void  OS_TaskIdle (void *p_arg)
   \                     OS_TaskIdle:
   \                     ??OS_TaskIdle_0:
   1753          {
   1754          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1755              OS_CPU_SR  cpu_sr = 0u;
   1756          #endif
   1757          
   1758          
   1759          
   1760              p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
   1761              for (;;) {
   1762                  OS_ENTER_CRITICAL();
   \   000000   ........     CALLA   #OSCPUSaveSR
   1763                  OSIdleCtr++;
   \   000004   ....9253.... ADDX.W  #0x1, &OSIdleCtr
   \   00000A   ....8263.... ADDCX.W #0x0, &OSIdleCtr + 2
   1764                  OS_EXIT_CRITICAL();
   \   000010   ........     CALLA   #OSCPURestoreSR
   1765                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   000014   ........     CALLA   #OSTaskIdleHook
   \   000018   F33F         JMP     ??OS_TaskIdle_0
   \   00001A   0343         NOP
   1766              }
   1767          }
   1768          /*$PAGE*/
   1769          /*
   1770          *********************************************************************************************************
   1771          *                                            STATISTICS TASK
   1772          *
   1773          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1774          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1775          *              CPU usage is determined by:
   1776          *
   1777          *                                          OSIdleCtr
   1778          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1779          *                                         OSIdleCtrMax
   1780          *
   1781          * Arguments  : parg     this pointer is not used at this time.
   1782          *
   1783          * Returns    : none
   1784          *
   1785          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1786          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1787          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1788          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1789          *                 maximum value for the idle counter.
   1790          *********************************************************************************************************
   1791          */
   1792          
   1793          #if OS_TASK_STAT_EN > 0u

   \                                 In  segment CODE, align 2
   1794          void  OS_TaskStat (void *p_arg)
   \                     OS_TaskStat:
   1795          {
   \   000000   1B14         PUSHM.A #0x2, R11
   1796          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1797              OS_CPU_SR  cpu_sr = 0u;
   1798          #endif
   1799          
   1800          
   1801          
   1802              p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
   \   000002   053C         JMP     ??OS_TaskStat_2
   1803              while (OSStatRdy == OS_FALSE) {
   1804                  OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
   \                     ??OS_TaskStat_0:
   \   000004   3C40C800     MOV.W   #0xc8, R12
   \   000008   0D43         MOV.W   #0x0, R13
   \   00000A   ........     CALLA   #OSTimeDly
   1805              }
   \                     ??OS_TaskStat_2:
   \   00000E   ....C293.... CMPX.B  #0x0, &OSStatRdy
   \   000014   F727         JEQ     ??OS_TaskStat_0
   1806              OSIdleCtrMax /= 100uL;
   \   000016   ........     MOVA    #OSIdleCtrMax, R10
   \   00001A   2C4A         MOV.W   @R10, R12
   \   00001C   1D4A0200     MOV.W   0x2(R10), R13
   \   000020   3E406400     MOV.W   #0x64, R14
   \   000024   0F43         MOV.W   #0x0, R15
   \   000026   ........     CALLA   #?DivMod32u
   \   00002A   8A4C0000     MOV.W   R12, 0(R10)
   \   00002E   8A4D0200     MOV.W   R13, 0x2(R10)
   1807              if (OSIdleCtrMax == 0uL) {
   \   000032   0F4C         MOV.W   R12, R15
   \   000034   0FDD         BIS.W   R13, R15
   \   000036   0F93         CMP.W   #0x0, R15
   \   000038   0620         JNE     ??OS_TaskStat_1
   1808                  OSCPUUsage = 0u;
   \   00003A   ....C243.... MOVX.B  #0x0, &OSCPUUsage
   1809          #if OS_TASK_SUSPEND_EN > 0u
   1810                  (void)OSTaskSuspend(OS_PRIO_SELF);
   \   000040   7C43         MOV.B   #0xff, R12
   \   000042   ........     CALLA   #OSTaskSuspend
   1811          #else
   1812                  for (;;) {
   1813                      OSTimeDly(OS_TICKS_PER_SEC);
   1814                  }
   1815          #endif
   1816              }
   1817              for (;;) {
   1818                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_1:
   \   000046   ........     CALLA   #OSCPUSaveSR
   1819                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   \   00004A   ....9242.... MOVX.W  &OSIdleCtr, &OSIdleCtrRun
   \            ....        
   \   000052   ....9242.... MOVX.W  &OSIdleCtr + 2, &OSIdleCtrRun + 2
   \            ....        
   1820                  OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
   \   00005A   ........     CALLA   #?Subroutine0
   1821                  OS_EXIT_CRITICAL();
   1822                  OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
   \                     ??CrossCallReturnLabel_1:
   \   00005E   7B406400     MOV.B   #0x64, R11
   \   000062   ....1C42.... MOVX.W  &OSIdleCtrRun, R12
   \   000068   ....1D42.... MOVX.W  &OSIdleCtrRun + 2, R13
   \   00006E   2E4A         MOV.W   @R10, R14
   \   000070   1F4A0200     MOV.W   0x2(R10), R15
   \   000074   ........     CALLA   #?DivMod32u
   \   000078   4B8C         SUB.B   R12, R11
   \   00007A   ....C24B.... MOVX.B  R11, &OSCPUUsage
   1823                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \   000080   ........     CALLA   #OSTaskStatHook
   1824          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
   1825                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   \   000084   ........     CALLA   #OS_TaskStatStkChk
   1826          #endif
   1827                  OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
   \   000088   3C406400     MOV.W   #0x64, R12
   \   00008C   0D43         MOV.W   #0x0, R13
   \   00008E   ........     CALLA   #OSTimeDly
   \   000092   D93F         JMP     ??OS_TaskStat_1
   \   000094   0343         NOP
   1828              }
   1829          }
   1830          #endif
   1831          /*$PAGE*/
   1832          /*
   1833          *********************************************************************************************************
   1834          *                                      CHECK ALL TASK STACKS
   1835          *
   1836          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1837          *
   1838          * Arguments  : none
   1839          *
   1840          * Returns    : none
   1841          *********************************************************************************************************
   1842          */
   1843          
   1844          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)

   \                                 In  segment CODE, align 2
   1845          void  OS_TaskStatStkChk (void)
   \                     OS_TaskStatStkChk:
   1846          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
   1847              OS_TCB      *ptcb;
   1848              OS_STK_DATA  stk_data;
   1849              INT8U        err;
   1850              INT8U        prio;
   1851          
   1852          
   1853              for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \   000004   4B43         MOV.B   #0x0, R11
   \   000006   ........     MOVA    #OSTCBPrioTbl, R8
   \   00000A   0A41         MOV.W   SP, R10
   \   00000C   0A53         ADD.W   #0x0, R10
   1854                  err = OSTaskStkChk(prio, &stk_data);
   1855                  if (err == OS_ERR_NONE) {
   \                     ??OS_TaskStatStkChk_0:
   \   00000E   CD0A         MOVA    R10, R13
   \   000010   4C4B         MOV.B   R11, R12
   \   000012   ........     CALLA   #OSTaskStkChk
   \   000016   4C93         CMP.B   #0x0, R12
   \   000018   1420         JNE     ??OS_TaskStatStkChk_1
   1856                      ptcb = OSTCBPrioTbl[prio];
   \   00001A   0F08         MOVA    @R8, R15
   1857                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \   00001C   DF03         CMPA    #0x0, R15
   \   00001E   1124         JEQ     ??OS_TaskStatStkChk_1
   1858                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \   000020   9F000100     CMPA    #0x1, R15
   \   000024   0E24         JEQ     ??OS_TaskStatStkChk_1
   1859          #if OS_TASK_PROFILE_EN > 0u
   1860                              #if OS_STK_GROWTH == 1u
   1861                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \   000026   3E0F0800     MOVA    0x8(R15), R14
   \   00002A   3D0F0C00     MOVA    0xc(R15), R13
   \   00002E   ED0D         ADDA    R13, R13
   \   000030   EE0D         ADDA    R13, R14
   \   000032   7F0E4200     MOVA    R14, 0x42(R15)
   1862                              #else
   1863                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1864                              #endif
   1865                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   \   000036   9F4104004600 MOV.W   0x4(SP), 0x46(R15)
   \   00003C   9F4106004800 MOV.W   0x6(SP), 0x48(R15)
   1866          #endif
   1867                          }
   1868                      }
   1869                  }
   1870              }
   \                     ??OS_TaskStatStkChk_1:
   \   000042   5B53         ADD.B   #0x1, R11
   \   000044   A8000400     ADDA    #0x4, R8
   \   000048   7B904000     CMP.B   #0x40, R11
   \   00004C   E02B         JNC     ??OS_TaskStatStkChk_0
   1871          }
   \   00004E   3152         ADD.W   #0x8, SP
   \   000050   3816         POPM.A  #0x4, R11
   \   000052   1001         RETA
   1872          #endif
   1873          /*$PAGE*/
   1874          /*
   1875          *********************************************************************************************************
   1876          *                                            INITIALIZE TCB
   1877          *
   1878          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1879          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1880          *
   1881          * Arguments  : prio          is the priority of the task being created
   1882          *
   1883          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1884          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1885          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1886          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1887          *                            specific.
   1888          *
   1889          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1890          *                            'OSTaskCreate()'.
   1891          *
   1892          *              id            is the task's ID (0..65535)
   1893          *
   1894          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1895          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1896          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1897          *                            units are established by the #define constant OS_STK which is CPU
   1898          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1899          *
   1900          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1901          *                            control block.  This allows you to store the contents of floating-point
   1902          *                            registers, MMU registers or anything else you could find useful during a
   1903          *                            context switch.  You can even assign a name to each task and store this name
   1904          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1905          *
   1906          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1907          *                            0 if called from 'OSTaskCreate()'.
   1908          *
   1909          * Returns    : OS_ERR_NONE         if the call was successful
   1910          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1911          *                                  be created.
   1912          *
   1913          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1914          *********************************************************************************************************
   1915          */
   1916          

   \                                 In  segment CODE, align 2
   1917          INT8U  OS_TCBInit (INT8U    prio,
   \                     OS_TCBInit:
   1918                             OS_STK  *ptos,
   1919                             OS_STK  *pbos,
   1920                             INT16U   id,
   1921                             INT32U   stk_size,
   1922                             void    *pext,
   1923                             INT16U   opt)
   1924          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   4A4C         MOV.B   R12, R10
   \   000006   C50E         MOVA    R14, R5
   \   000008   064F         MOV.W   R15, R6
   \   00000A   18412800     MOV.W   0x28(SP), R8
   \   00000E   19412A00     MOV.W   0x2a(SP), R9
   \   000012   37012C00     MOVA    0x2c(SP), R7
   \   000016   14413000     MOV.W   0x30(SP), R4
   1925              OS_TCB    *ptcb;
   1926          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
   1927              OS_CPU_SR  cpu_sr = 0u;
   1928          #endif
   1929          #if OS_TASK_REG_TBL_SIZE > 0u
   1930              INT8U      i;
   1931          #endif
   1932          
   1933          
   1934              OS_ENTER_CRITICAL();
   \   00001A   ........     CALLA   #OSCPUSaveSR
   1935              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   00001E   ........     MOVA    &OSTCBFreeList, R11
   1936              if (ptcb != (OS_TCB *)0) {
   \   000022   DB03         CMPA    #0x0, R11
   \   000024   8624         JEQ     ??OS_TCBInit_0
   1937                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   000026   ....D24B1400 MOVX.A  0x14(R11), &OSTCBFreeList
   \            ....        
   1938                  OS_EXIT_CRITICAL();
   \   00002E   ........     CALLA   #OSCPURestoreSR
   1939                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   000032   0F01         MOVA    @SP, R15
   \   000034   7B0F0000     MOVA    R15, 0(R11)
   1940                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   \   000038   CB4A3000     MOV.B   R10, 0x30(R11)
   1941                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   00003C   CB432E00     MOV.B   #0x0, 0x2e(R11)
   1942                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   000040   CB432F00     MOV.B   #0x0, 0x2f(R11)
   1943                  ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
   \   000044   8B432A00     MOV.W   #0x0, 0x2a(R11)
   \   000048   8B432C00     MOV.W   #0x0, 0x2c(R11)
   1944          
   1945          #if OS_TASK_CREATE_EXT_EN > 0u
   1946                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \   00004C   7B070400     MOVA    R7, 0x4(R11)
   1947                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \   000050   8B480C00     MOV.W   R8, 0xc(R11)
   \   000054   8B490E00     MOV.W   R9, 0xe(R11)
   1948                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \   000058   7B050800     MOVA    R5, 0x8(R11)
   1949                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \   00005C   8B441000     MOV.W   R4, 0x10(R11)
   1950                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   \   000060   8B461200     MOV.W   R6, 0x12(R11)
   1951          #else
   1952                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1953                  stk_size                 = stk_size;
   1954                  pbos                     = pbos;
   1955                  opt                      = opt;
   1956                  id                       = id;
   1957          #endif
   1958          
   1959          #if OS_TASK_DEL_EN > 0u
   1960                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   \   000064   CB433500     MOV.B   #0x0, 0x35(R11)
   1961          #endif
   1962          
   1963          #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
   1964                  ptcb->OSTCBY             = (INT8U)(prio >> 3u);
   \   000068   4C4A         MOV.B   R10, R12
   \   00006A                RPT     #0x3
   \   00006A   42194C10     RRUX.B  R12
   \   00006E   CB4C3200     MOV.B   R12, 0x32(R11)
   1965                  ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
   \   000072   4F4A         MOV.B   R10, R15
   \   000074   7FF00700     AND.B   #0x7, R15
   \   000078   CB4F3100     MOV.B   R15, 0x31(R11)
   1966          #else                                                             /* Pre-compute X, Y                  */
   1967                  ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
   1968                  ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
   1969          #endif
   1970                                                                            /* Pre-compute BitX and BitY         */
   1971                  ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   00007C   ........     CALLA   #?OneBitMask32
   \   000080   CB4C3400     MOV.B   R12, 0x34(R11)
   1972                  ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   000084   5E43         MOV.B   #0x1, R14
   \   000086   5F83         SUB.B   #0x1, R15
   \   000088   0230         JN      ??OS_TCBInit_1
   \   00008A                RPT     R15
   \   00008A   CF184E5E     RLAX.B  R14
   \                     ??OS_TCBInit_1:
   \   00008E   CB4E3300     MOV.B   R14, 0x33(R11)
   1973          
   1974          #if (OS_EVENT_EN)
   1975                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   000092   0018CB431C00 MOVX.A  #0x0, 0x1c(R11)
   1976          #if (OS_EVENT_MULTI_EN > 0u)
   1977                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   1978          #endif
   1979          #endif
   1980          
   1981          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
   1982                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   000098   0018CB432400 MOVX.A  #0x0, 0x24(R11)
   1983          #endif
   1984          
   1985          #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
   1986                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   00009E   0018CB432000 MOVX.A  #0x0, 0x20(R11)
   1987          #endif
   1988          
   1989          #if OS_TASK_PROFILE_EN > 0u
   1990                  ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
   \   0000A4   8B433600     MOV.W   #0x0, 0x36(R11)
   \   0000A8   8B433800     MOV.W   #0x0, 0x38(R11)
   1991                  ptcb->OSTCBCyclesStart = 0uL;
   \   0000AC   8B433E00     MOV.W   #0x0, 0x3e(R11)
   \   0000B0   8B434000     MOV.W   #0x0, 0x40(R11)
   1992                  ptcb->OSTCBCyclesTot   = 0uL;
   \   0000B4   8B433A00     MOV.W   #0x0, 0x3a(R11)
   \   0000B8   8B433C00     MOV.W   #0x0, 0x3c(R11)
   1993                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   0000BC   0018CB434200 MOVX.A  #0x0, 0x42(R11)
   1994                  ptcb->OSTCBStkUsed     = 0uL;
   \   0000C2   8B434600     MOV.W   #0x0, 0x46(R11)
   \   0000C6   8B434800     MOV.W   #0x0, 0x48(R11)
   1995          #endif
   1996          
   1997          #if OS_TASK_NAME_EN > 0u
   1998                  ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
   \   0000CA   ....FB40.... MOVX.A  #`?<Constant "?">`, 0x4a(R11)
   \            4A00        
   1999          #endif
   2000          
   2001          #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
   2002                  for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
   2003                      ptcb->OSTCBRegTbl[i] = 0u;
   \   0000D2   8B434E00     MOV.W   #0x0, 0x4e(R11)
   \   0000D6   8B435000     MOV.W   #0x0, 0x50(R11)
   2004                  }
   2005          #endif
   2006          
   2007                  OSTCBInitHook(ptcb);
   \   0000DA   CC0B         MOVA    R11, R12
   \   0000DC   ........     CALLA   #OSTCBInitHook
   2008          
   2009                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   0000E0   CC0B         MOVA    R11, R12
   \   0000E2   ........     CALLA   #OSTaskCreateHook
   2010          
   2011                  OS_ENTER_CRITICAL();
   \   0000E6   ........     CALLA   #OSCPUSaveSR
   2012                  OSTCBPrioTbl[prio] = ptcb;
   \   0000EA   4A06         RLAM.A  #0x2, R10
   \   0000EC   ....CA4B.... MOVX.A  R11, OSTCBPrioTbl(R10)
   2013                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   0000F2   ........     MOVA    #OSTCBList, R15
   \   0000F6   0018EB4F1400 MOVX.A  @R15, 0x14(R11)
   2014                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   0000FC   0018CB431800 MOVX.A  #0x0, 0x18(R11)
   2015                  if (OSTCBList != (OS_TCB *)0) {
   \   000102   070F         MOVA    @R15, R7
   \   000104   D703         CMPA    #0x0, R7
   \   000106   0224         JEQ     ??OS_TCBInit_2
   2016                      OSTCBList->OSTCBPrev = ptcb;
   \   000108   770B1800     MOVA    R11, 0x18(R7)
   2017                  }
   2018                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_2:
   \   00010C   7F0B0000     MOVA    R11, 0(R15)
   2019                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   000110   ....D2DB3400 BISX.B  0x34(R11), &OSRdyGrp
   \            ....        
   2020                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000118   5F4B3200     MOV.B   0x32(R11), R15
   \   00011C   ....DFDB3300 BISX.B  0x33(R11), OSRdyTbl(R15)
   \            ....        
   2021                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   000124   ....D253.... ADDX.B  #0x1, &OSTaskCtr
   2022                  OS_EXIT_CRITICAL();
   \   00012A   ........     CALLA   #OSCPURestoreSR
   2023                  return (OS_ERR_NONE);
   \   00012E   4C43         MOV.B   #0x0, R12
   \   000130   043C         JMP     ??OS_TCBInit_3
   2024              }
   2025              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0:
   \   000132   ........     CALLA   #OSCPURestoreSR
   2026              return (OS_ERR_TASK_NO_MORE_TCB);
   \   000136   7C404200     MOV.B   #0x42, R12
   \                     ??OS_TCBInit_3:
   \   00013A   2152         ADD.W   #0x4, SP
   \   00013C   7416         POPM.A  #0x8, R11
   \   00013E   1001         RETA
   2027          }

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "uC/OS-II Idle">`:
   \   000000   75432F4F532D DC8 "uC/OS-II Idle"
   \            49492049646C
   \            6500        

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "uC/OS-II Stat">`:
   \   000000   75432F4F532D DC8 "uC/OS-II Stat"
   \            494920537461
   \            7400        

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "?">`:
   \   000000   3F00         DC8 "?"
   2028          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      38  OSInit
             6 -> OSInitHookBegin
            38 -> OSInitHookEnd
            22 -> OSTaskCreateExt
            38 -> OSTaskCreateExt
            22 -> OSTaskNameSet
            38 -> OSTaskNameSet
             6 -> OS_FlagInit
             6 -> OS_InitEventList
             6 -> OS_InitTCBList
             6 -> OS_QInit
       4  OSIntEnter
       8  OSIntExit
             8 -> OSCPURestoreSR
             8 -> OSCPUSaveSR
             8 -> OSIntCtxSw
             8 -> OS_SchedNew
       4  OSSchedLock
             4 -> OSCPURestoreSR
             4 -> OSCPUSaveSR
       4  OSSchedUnlock
             4 -> OSCPURestoreSR
             4 -> OSCPUSaveSR
             4 -> OS_Sched
       4  OSStart
             4 -> OSStartHighRdy
             4 -> OS_SchedNew
       4  OSStatInit
             4 -> OSCPURestoreSR
             4 -> OSCPUSaveSR
             4 -> OSTimeDly
       8  OSTimeTick
             8 -> OSCPURestoreSR
             8 -> OSCPUSaveSR
             8 -> OSTimeTickHook
       4  OSVersion
       4  OS_Dummy
      20  OS_EventTaskRdy
            20 -> OS_EventTaskRemove
       4  OS_EventTaskRemove
       8  OS_EventTaskWait
       4  OS_EventWaitListInit
       4  OS_InitEventList
             4 -> OS_MemClr
       4  OS_InitTCBList
             4 -> OS_MemClr
       4  OS_MemClr
       4  OS_MemCopy
       8  OS_Sched
             8 -> OSCPURestoreSR
             8 -> OSCPUSaveSR
             8 -> OSCtxSw
             8 -> OS_SchedNew
       4  OS_SchedNew
       4  OS_StrLen
      40  OS_TCBInit
            40 -> OSCPURestoreSR
            40 -> OSCPUSaveSR
            40 -> OSTCBInitHook
            40 -> OSTaskCreateHook
       4  OS_TaskIdle
             4 -> OSCPURestoreSR
             4 -> OSCPUSaveSR
             4 -> OSTaskIdleHook
      12  OS_TaskStat
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
            12 -> OSTaskStatHook
            12 -> OSTaskSuspend
            12 -> OSTimeDly
            12 -> OS_TaskStatStkChk
      28  OS_TaskStatStkChk
            28 -> OSTaskStkChk


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
      14  ?<Constant "uC/OS-II Idle">
      14  ?<Constant "uC/OS-II Stat">
       8  ?Subroutine0
      10  ?Subroutine1
      24  ?Subroutine2
      22  ?Subroutine3
       8  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
       1  OSCPUUsage
       4  OSCtxSwCtr
       4  OSEventFreeList
     180  OSEventTbl
       4  OSFlagFreeList
      60  OSFlagTbl
       4  OSIdleCtr
       4  OSIdleCtrMax
       4  OSIdleCtrRun
     282  OSInit
      22  OSIntEnter
      62  OSIntExit
       1  OSIntNesting
       1  OSLockNesting
       1  OSPrioCur
       1  OSPrioHighRdy
       4  OSQFreeList
     120  OSQTbl
       1  OSRdyGrp
       8  OSRdyTbl
       1  OSRunning
      38  OSSchedLock
      48  OSSchedUnlock
      38  OSStart
      44  OSStatInit
       1  OSStatRdy
       4  OSTCBCur
       4  OSTCBFreeList
       4  OSTCBHighRdy
       4  OSTCBList
     256  OSTCBPrioTbl
     984  OSTCBTbl
       1  OSTaskCtr
     256  OSTaskIdleStk
     256  OSTaskStatStk
       1  OSTickStepState
       4  OSTime
     172  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     102  OS_EventTaskRdy
      28  OS_EventTaskRemove
      68  OS_EventTaskWait
      24  OS_EventWaitListInit
      74  OS_InitEventList
     104  OS_InitTCBList
      18  OS_MemClr
      18  OS_MemCopy
      48  OS_Sched
      38  OS_SchedNew
      16  OS_StrLen
     320  OS_TCBInit
      28  OS_TaskIdle
     150  OS_TaskStat
      84  OS_TaskStatStkChk

 
 1 934 bytes in segment CODE
   286 bytes in segment DATA20_C
 2 178 bytes in segment DATA20_Z
 
 1 934 bytes of CODE  memory
   286 bytes of CONST memory
 2 178 bytes of DATA  memory

Errors: none
Warnings: 11
