###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:31 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mutex.c                       #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mutex.c -D NDEBUG -D          #
#                     RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿ #
#                     âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_mutex.lst                        #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_mutex.r43                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_mutex.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MUTEX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include "ucos_ii.h"

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          #endif
     27          
     28          
     29          #if OS_MUTEX_EN > 0u
     30          /*
     31          *********************************************************************************************************
     32          *                                            LOCAL CONSTANTS
     33          *********************************************************************************************************
     34          */
     35          
     36          #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
     37          #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
     38          
     39          #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            LOCAL CONSTANTS
     44          *********************************************************************************************************
     45          */
     46          
     47          static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
     48          
     49          /*$PAGE*/
     50          /*
     51          *********************************************************************************************************
     52          *                                   ACCEPT MUTUAL EXCLUSION SEMAPHORE
     53          *
     54          * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
     55          *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
     56          *              not available or the event did not occur.
     57          *
     58          * Arguments  : pevent     is a pointer to the event control block
     59          *
     60          *              perr       is a pointer to an error code which will be returned to your application:
     61          *                            OS_ERR_NONE         if the call was successful.
     62          *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
     63          *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
     64          *                            OS_ERR_PEND_ISR     if you called this function from an ISR
     65          *                            OS_ERR_PIP_LOWER    If the priority of the task that owns the Mutex is
     66          *                                                HIGHER (i.e. a lower number) than the PIP.  This error
     67          *                                                indicates that you did not set the PIP higher (lower
     68          *                                                number) than ALL the tasks that compete for the Mutex.
     69          *                                                Unfortunately, this is something that could not be
     70          *                                                detected when the Mutex is created because we don't know
     71          *                                                what tasks will be using the Mutex.
     72          *
     73          * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
     74          *              == OS_FALSE   a) if the resource is not available
     75          *                            b) you didn't pass a pointer to a mutual exclusion semaphore
     76          *                            c) you called this function from an ISR
     77          *
     78          * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
     79          *              intended to be used by tasks only.
     80          *********************************************************************************************************
     81          */
     82          
     83          #if OS_MUTEX_ACCEPT_EN > 0u

   \                                 In  segment CODE, align 2
     84          BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
   \                     OSMutexAccept:
     85                                  INT8U     *perr)
     86          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   CB0D         MOVA    R13, R11
     87              INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
     88          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
     89              OS_CPU_SR  cpu_sr = 0u;
     90          #endif
     91          
     92          
     93          
     94          #ifdef OS_SAFETY_CRITICAL
     95              if (perr == (INT8U *)0) {
     96                  OS_SAFETY_CRITICAL_EXCEPTION();
     97              }
     98          #endif
     99          
    100          #if OS_ARG_CHK_EN > 0u
    101              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    102                  *perr = OS_ERR_PEVENT_NULL;
    103                  return (OS_FALSE);
    104              }
    105          #endif
    106              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
   \   000006   EC920000     CMP.B   #0x4, 0(R12)
   \   00000A   0324         JEQ     ??OSMutexAccept_1
    107                  *perr = OS_ERR_EVENT_TYPE;
   \   00000C   DD430000     MOV.B   #0x1, 0(R13)
    108                  return (OS_FALSE);
   \   000010   283C         JMP     ??OSMutexAccept_0
    109              }
    110              if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
   \                     ??OSMutexAccept_1:
   \   000012   ........     CALLA   #??Subroutine0_0
   \                     ??CrossCallReturnLabel_11:
   \   000016   0324         JEQ     ??OSMutexAccept_2
    111                  *perr = OS_ERR_PEND_ISR;
   \   000018   ED430000     MOV.B   #0x2, 0(R13)
    112                  return (OS_FALSE);
   \   00001C   223C         JMP     ??OSMutexAccept_0
    113              }
    114              OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
   \                     ??OSMutexAccept_2:
   \   00001E   ........     CALLA   #OSCPUSaveSR
    115              pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
   \   000022   1E4A0600     MOV.W   0x6(R10), R14
   \   000026   0F4E         MOV.W   R14, R15
   \   000028   8F10         SWPB    R15
    116              if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   00002A   7E93         CMP.B   #0xff, R14
   \   00002C   1820         JNE     ??OSMutexAccept_3
    117                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
   \   00002E   BAF000FF0600 AND.W   #0xff00, 0x6(R10)
    118                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
   \   000034   ........     MOVA    &OSTCBCur, R13
   \   000038   5E4D3000     MOV.B   0x30(R13), R14
   \   00003C   8ADE0600     BIS.W   R14, 0x6(R10)
    119                  pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
   \   000040   7A0D0200     MOVA    R13, 0x2(R10)
    120                  if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
   \   000044   5F9D3000     CMP.B   0x30(R13), R15
   \   000048   0628         JNC     ??OSMutexAccept_4
    121                      OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
   \   00004A   ........     CALLA   #OSCPURestoreSR
    122                      *perr = OS_ERR_PIP_LOWER;
   \   00004E   FB4078000000 MOV.B   #0x78, 0(R11)
   \   000054   023C         JMP     ??OSMutexAccept_5
    123                  } else {
    124                      OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_4:
   \   000056   ........     CALLA   #?Subroutine2
    125                      *perr = OS_ERR_NONE;
    126                  }
    127                  return (OS_TRUE);
   \                     ??OSMutexAccept_5:
   \   00005A   5C43         MOV.B   #0x1, R12
   \   00005C   033C         JMP     ??OSMutexAccept_6
    128              }
    129              OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_3:
   \   00005E   ........     CALLA   #?Subroutine2
    130              *perr = OS_ERR_NONE;
    131              return (OS_FALSE);
   \                     ??OSMutexAccept_0:
   \   000062   4C43         MOV.B   #0x0, R12
   \                     ??OSMutexAccept_6:
   \   000064   1A16         POPM.A  #0x2, R11
   \   000066   1001         RETA
    132          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #OSCPURestoreSR
   \   000004   CB430000     MOV.B   #0x0, 0(R11)
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ??Subroutine0_0:
   \   000000   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   000006   1001         RETA
    133          #endif
    134          
    135          /*$PAGE*/
    136          /*
    137          *********************************************************************************************************
    138          *                                  CREATE A MUTUAL EXCLUSION SEMAPHORE
    139          *
    140          * Description: This function creates a mutual exclusion semaphore.
    141          *
    142          * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
    143          *                            other words, when the semaphore is acquired and a higher priority task
    144          *                            attempts to obtain the semaphore then the priority of the task owning the
    145          *                            semaphore is raised to this priority.  It is assumed that you will specify
    146          *                            a priority that is LOWER in value than ANY of the tasks competing for the
    147          *                            mutex.
    148          *
    149          *              perr          is a pointer to an error code which will be returned to your application:
    150          *                               OS_ERR_NONE         if the call was successful.
    151          *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
    152          *                               OS_ERR_PRIO_EXIST   if a task at the priority inheritance priority
    153          *                                                   already exist.
    154          *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
    155          *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
    156          *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
    157          *
    158          * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    159          *                            created mutex.
    160          *              == (void *)0  if an error is detected.
    161          *
    162          * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' are used to hold the priority number
    163          *                 of the task owning the mutex or 0xFF if no task owns the mutex.
    164          *
    165          *              2) The MOST  significant 8 bits of '.OSEventCnt' are used to hold the priority number
    166          *                 to use to reduce priority inversion.
    167          *********************************************************************************************************
    168          */
    169          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   CB0D         MOVA    R13, R11
   \   000002                REQUIRE ??Subroutine0_0
   \   000002                // Fall through to label ??Subroutine0_0

   \                                 In  segment CODE, align 2
    170          OS_EVENT  *OSMutexCreate (INT8U   prio,
   \                     OSMutexCreate:
    171                                    INT8U  *perr)
    172          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   ........     CALLA   #?Subroutine0
    173              OS_EVENT  *pevent;
    174          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    175              OS_CPU_SR  cpu_sr = 0u;
    176          #endif
    177          
    178          
    179          
    180          #ifdef OS_SAFETY_CRITICAL
    181              if (perr == (INT8U *)0) {
    182                  OS_SAFETY_CRITICAL_EXCEPTION();
    183              }
    184          #endif
    185          
    186          #ifdef OS_SAFETY_CRITICAL_IEC61508
    187              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    188                  OS_SAFETY_CRITICAL_EXCEPTION();
    189              }
    190          #endif
    191          
    192          #if OS_ARG_CHK_EN > 0u
    193              if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
    194                  *perr = OS_ERR_PRIO_INVALID;
    195                  return ((OS_EVENT *)0);
    196              }
    197          #endif
    198              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??CrossCallReturnLabel_7:
   \   000008   0424         JEQ     ??OSMutexCreate_1
    199                  *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
   \   00000A   FD4010000000 MOV.B   #0x10, 0(R13)
    200                  return ((OS_EVENT *)0);
   \   000010   1E3C         JMP     ??OSMutexCreate_0
    201              }
    202              OS_ENTER_CRITICAL();
   \                     ??OSMutexCreate_1:
   \   000012   ........     CALLA   #OSCPUSaveSR
    203              if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
   \   000016   4F4A         MOV.B   R10, R15
   \   000018   4F06         RLAM.A  #0x2, R15
   \   00001A   ....5E4F.... MOVX.A  OSTCBPrioTbl(R15), R14
   \   000020   DE03         CMPA    #0x0, R14
   \   000022   0624         JEQ     ??OSMutexCreate_2
    204                  OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
   \   000024   ........     CALLA   #OSCPURestoreSR
    205                  *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
   \   000028   FB4028000000 MOV.B   #0x28, 0(R11)
    206                  return ((OS_EVENT *)0);
   \   00002E   0F3C         JMP     ??OSMutexCreate_0
    207              }
    208              OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
   \                     ??OSMutexCreate_2:
   \   000030   ....DF43.... MOVX.A  #0x1, OSTCBPrioTbl(R15)
   \   000036   ........     MOVA    &OSEventFreeList, R14
   \   00003A   C80E         MOVA    R14, R8
    209              pevent             = OSEventFreeList;                  /* Get next free event control block        */
    210              if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
   \   00003C   DE03         CMPA    #0x0, R14
   \   00003E   0920         JNE     ??OSMutexCreate_3
    211                  OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
   \   000040   ....CF43.... MOVX.A  #0x0, OSTCBPrioTbl(R15)
    212                  OS_EXIT_CRITICAL();
   \   000046   ........     CALLA   #OSCPURestoreSR
    213                  *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
   \   00004A   EB420000     MOV.B   #0x4, 0(R11)
    214                  return (pevent);
   \                     ??OSMutexCreate_0:
   \   00004E   4C43         MOVA    #0x0, R12
   \   000050   163C         JMP     ??OSMutexCreate_4
    215              }
    216              OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
   \                     ??OSMutexCreate_3:
   \   000052   ....D24E0200 MOVX.A  0x2(R14), &OSEventFreeList
   \            ....        
    217              OS_EXIT_CRITICAL();
   \   00005A   ........     CALLA   #OSCPURestoreSR
    218              pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
   \   00005E   E8420000     MOV.B   #0x4, 0(R8)
    219              pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
   \   000062   8A10         SWPB    R10
   \   000064   3AD0FF00     BIS.W   #0xff, R10
   \   000068   884A0600     MOV.W   R10, 0x6(R8)
    220              pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
   \   00006C   0018C8430200 MOVX.A  #0x0, 0x2(R8)
    221          #if OS_EVENT_NAME_EN > 0u
    222              pevent->OSEventName    = (INT8U *)(void *)"?";
    223          #endif
    224              OS_EventWaitListInit(pevent);
   \   000072   CC08         MOVA    R8, R12
   \   000074   ........     CALLA   #OS_EventWaitListInit
    225              *perr                  = OS_ERR_NONE;
   \   000078   CB430000     MOV.B   #0x0, 0(R11)
    226              return (pevent);
   \   00007C   CC08         MOVA    R8, R12
   \                     ??OSMutexCreate_4:
   \   00007E   3816         POPM.A  #0x4, R11
   \   000080   1001         RETA
    227          }
    228          
    229          /*$PAGE*/
    230          /*
    231          *********************************************************************************************************
    232          *                                          DELETE A MUTEX
    233          *
    234          * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
    235          *
    236          * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
    237          *
    238          *              opt           determines delete options as follows:
    239          *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
    240          *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
    241          *                                                    In this case, all the tasks pending will be readied.
    242          *
    243          *              perr          is a pointer to an error code that can contain one of the following values:
    244          *                            OS_ERR_NONE             The call was successful and the mutex was deleted
    245          *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
    246          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    247          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
    248          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    249          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    250          *
    251          * Returns    : pevent        upon error
    252          *              (OS_EVENT *)0 if the mutex was successfully deleted.
    253          *
    254          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    255          *                 the mutex MUST check the return code of OSMutexPend().
    256          *
    257          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    258          *                 time is directly proportional to the number of tasks waiting on the mutex.
    259          *
    260          *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
    261          *                 resource(s) will no longer be guarded by the mutex.
    262          *
    263          *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
    264          *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
    265          *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
    266          *                            that task will be made ready-to-run at its original priority.
    267          *********************************************************************************************************
    268          */
    269          
    270          #if OS_MUTEX_DEL_EN > 0u

   \                                 In  segment CODE, align 2
    271          OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
   \                     OSMutexDel:
    272                                 INT8U      opt,
    273                                 INT8U     *perr)
    274          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   464D         MOV.B   R13, R6
   \   000006   CB0E         MOVA    R14, R11
    275              BOOLEAN    tasks_waiting;
    276              OS_EVENT  *pevent_return;
    277              INT8U      pip;                                        /* Priority inheritance priority            */
    278              INT8U      prio;
    279              OS_TCB    *ptcb;
    280          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    281              OS_CPU_SR  cpu_sr = 0u;
    282          #endif
    283          
    284          
    285          
    286          #ifdef OS_SAFETY_CRITICAL
    287              if (perr == (INT8U *)0) {
    288                  OS_SAFETY_CRITICAL_EXCEPTION();
    289              }
    290          #endif
    291          
    292          #if OS_ARG_CHK_EN > 0u
    293              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    294                  *perr = OS_ERR_PEVENT_NULL;
    295                  return (pevent);
    296              }
    297          #endif
    298              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   000008   EC920000     CMP.B   #0x4, 0(R12)
   \   00000C   0324         JEQ     ??OSMutexDel_2
    299                  *perr = OS_ERR_EVENT_TYPE;
   \   00000E   DE430000     MOV.B   #0x1, 0(R14)
    300                  return (pevent);
   \   000012   4D3C         JMP     ??OSMutexDel_3
    301              }
    302              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMutexDel_2:
   \   000014   ........     CALLA   #??Subroutine0_0
   \                     ??CrossCallReturnLabel_10:
   \   000018   0424         JEQ     ??OSMutexDel_4
    303                  *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
   \   00001A   FE400F000000 MOV.B   #0xf, 0(R14)
    304                  return (pevent);
   \   000020   463C         JMP     ??OSMutexDel_3
    305              }
    306              OS_ENTER_CRITICAL();
   \                     ??OSMutexDel_4:
   \   000022   ........     CALLA   #OSCPUSaveSR
   \   000026   094C         MOV.W   R12, R9
    307              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
   \   000028   CA930800     CMP.B   #0x0, 0x8(R10)
   \   00002C   0220         JNE     ??OSMutexDel_5
   \   00002E   4843         MOV.B   #0x0, R8
   \   000030   013C         JMP     ??OSMutexDel_6
   \                     ??OSMutexDel_5:
   \   000032   5843         MOV.B   #0x1, R8
    308                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    309              } else {
    310                  tasks_waiting = OS_FALSE;                          /* No                                       */
    311              }
    312              switch (opt) {
   \                     ??OSMutexDel_6:
   \   000034   4683         SUB.B   #0x0, R6
   \   000036   0324         JEQ     ??OSMutexDel_7
   \   000038   5683         SUB.B   #0x1, R6
   \   00003A   0E24         JEQ     ??OSMutexDel_8
   \   00003C   323C         JMP     ??OSMutexDel_9
    313                  case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
    314                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMutexDel_7:
   \   00003E   58B3         BIT.B   #0x1, R8
   \   000040   052C         JC      ??OSMutexDel_10
    315          #if OS_EVENT_NAME_EN > 0u
    316                           pevent->OSEventName = (INT8U *)(void *)"?";
    317          #endif
    318                           pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
    319                           OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
   \   000042   ........     CALLA   #?Subroutine3
    320                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
    321                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
    322                           pevent->OSEventCnt  = 0u;
    323                           OSEventFreeList     = pevent;
    324                           OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_4:
   \   000046   ........     CALLA   #OSCPURestoreSR
    325                           *perr               = OS_ERR_NONE;
   \   00004A   273C         JMP     ??OSMutexDel_1
    326                           pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
    327                       } else {
    328                           OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_10:
   \   00004C   ........     CALLA   #OSCPURestoreSR
    329                           *perr               = OS_ERR_TASK_WAITING;
   \   000050   FB4049000000 MOV.B   #0x49, 0(R11)
    330                           pevent_return       = pevent;
   \   000056   2A3C         JMP     ??OSMutexDel_11
    331                       }
   \                     ??OSMutexDel_8:
   \   000058   1F4A0600     MOV.W   0x6(R10), R15
   \   00005C   4D4F         MOV.B   R15, R13
    332                       break;
    333          
    334                  case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
    335                       pip  = (INT8U)(pevent->OSEventCnt >> 8u);                    /* Get PIP of mutex          */
    336                       prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
    337                       ptcb = (OS_TCB *)pevent->OSEventPtr;
   \   00005E   3C0A0200     MOVA    0x2(R10), R12
    338                       if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
   \   000062   DC03         CMPA    #0x0, R12
   \   000064   0E24         JEQ     ??OSMutexDel_12
    339                           if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
   \   000066   8F10         SWPB    R15
   \   000068   CC9F3000     CMP.B   R15, 0x30(R12)
   \   00006C   0A20         JNE     ??OSMutexDel_12
    340                               OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
   \   00006E   ........     CALLA   #OSMutex_RdyAtPrio
   \   000072   073C         JMP     ??OSMutexDel_12
    341                           }
    342                       }
    343                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
    344                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
   \                     ??OSMutexDel_0:
   \   000074   4F43         MOV.B   #0x0, R15
   \   000076   7E401000     MOV.B   #0x10, R14
   \   00007A   4D43         MOVA    #0x0, R13
   \   00007C   CC0A         MOVA    R10, R12
   \   00007E   ........     CALLA   #OS_EventTaskRdy
    345                       }
   \                     ??OSMutexDel_12:
   \   000082   CA930800     CMP.B   #0x0, 0x8(R10)
   \   000086   F623         JNE     ??OSMutexDel_0
    346          #if OS_EVENT_NAME_EN > 0u
    347                       pevent->OSEventName = (INT8U *)(void *)"?";
    348          #endif
    349                       pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
    350                       OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
   \   000088   ........     CALLA   #?Subroutine3
    351                       pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
    352                       pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
    353                       pevent->OSEventCnt  = 0u;
    354                       OSEventFreeList     = pevent;                 /* Get next free event control block        */
    355                       OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_5:
   \   00008C   0C49         MOV.W   R9, R12
   \   00008E   ........     CALLA   #OSCPURestoreSR
    356                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000092   58B3         BIT.B   #0x1, R8
   \   000094   0228         JNC     ??OSMutexDel_1
    357                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000096   ........     CALLA   #OS_Sched
    358                       }
    359                       *perr         = OS_ERR_NONE;
   \                     ??OSMutexDel_1:
   \   00009A   CB430000     MOV.B   #0x0, 0(R11)
    360                       pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
   \   00009E   4A43         MOVA    #0x0, R10
    361                       break;
   \   0000A0   053C         JMP     ??OSMutexDel_11
    362          
    363                  default:
    364                       OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_9:
   \   0000A2   ........     CALLA   #OSCPURestoreSR
    365                       *perr         = OS_ERR_INVALID_OPT;
   \   0000A6   FB4007000000 MOV.B   #0x7, 0(R11)
    366                       pevent_return = pevent;
    367                       break;
    368              }
    369              return (pevent_return);
   \                     ??OSMutexDel_11:
   \   0000AC   CC0A         MOVA    R10, R12
   \                     ??OSMutexDel_3:
   \   0000AE   5616         POPM.A  #0x6, R11
   \   0000B0   1001         RETA
    370          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   5F4A0700     MOV.B   0x7(R10), R15
   \   000004   4F06         RLAM.A  #0x2, R15
   \   000006   ....CF43.... MOVX.A  #0x0, OSTCBPrioTbl(R15)
   \   00000C   CA430000     MOV.B   #0x0, 0(R10)
   \   000010   ....DA42.... MOVX.A  &OSEventFreeList, 0x2(R10)
   \            0200        
   \   000018   8A430600     MOV.W   #0x0, 0x6(R10)
   \   00001C   ........     MOVA    R10, &OSEventFreeList
   \   000020   1001         RETA
    371          #endif
    372          
    373          /*$PAGE*/
    374          /*
    375          *********************************************************************************************************
    376          *                                  PEND ON MUTUAL EXCLUSION SEMAPHORE
    377          *
    378          * Description: This function waits for a mutual exclusion semaphore.
    379          *
    380          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    381          *                            mutex.
    382          *
    383          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    384          *                            wait for the resource up to the amount of time specified by this argument.
    385          *                            If you specify 0, however, your task will wait forever at the specified
    386          *                            mutex or, until the resource becomes available.
    387          *
    388          *              perr          is a pointer to where an error message will be deposited.  Possible error
    389          *                            messages are:
    390          *                               OS_ERR_NONE        The call was successful and your task owns the mutex
    391          *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
    392          *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
    393          *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
    394          *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
    395          *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
    396          *                                                  would lead to a suspension.
    397          *                               OS_ERR_PIP_LOWER   If the priority of the task that owns the Mutex is
    398          *                                                  HIGHER (i.e. a lower number) than the PIP.  This error
    399          *                                                  indicates that you did not set the PIP higher (lower
    400          *                                                  number) than ALL the tasks that compete for the Mutex.
    401          *                                                  Unfortunately, this is something that could not be
    402          *                                                  detected when the Mutex is created because we don't know
    403          *                                                  what tasks will be using the Mutex.
    404          *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
    405          *
    406          * Returns    : none
    407          *
    408          * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
    409          *
    410          *              2) You MUST NOT change the priority of the task that owns the mutex
    411          *********************************************************************************************************
    412          */
    413          

   \                                 In  segment CODE, align 2
    414          void  OSMutexPend (OS_EVENT  *pevent,
   \                     OSMutexPend:
    415                             INT32U     timeout,
    416                             INT8U     *perr)
    417          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0F12         PUSH.W  R15
   \   000004   0E12         PUSH.W  R14
   \   000006   CA0C         MOVA    R12, R10
   \   000008   CB0D         MOVA    R13, R11
    418              INT8U      pip;                                        /* Priority Inheritance Priority (PIP)      */
    419              INT8U      mprio;                                      /* Mutex owner priority                     */
    420              BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    421              OS_TCB    *ptcb;
    422              OS_EVENT  *pevent2;
    423              INT8U      y;
    424          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    425              OS_CPU_SR  cpu_sr = 0u;
    426          #endif
    427          
    428          
    429          
    430          #ifdef OS_SAFETY_CRITICAL
    431              if (perr == (INT8U *)0) {
    432                  OS_SAFETY_CRITICAL_EXCEPTION();
    433              }
    434          #endif
    435          
    436          #if OS_ARG_CHK_EN > 0u
    437              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    438                  *perr = OS_ERR_PEVENT_NULL;
    439                  return;
    440              }
    441          #endif
    442              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   00000A   EC920000     CMP.B   #0x4, 0(R12)
   \   00000E   0324         JEQ     ??OSMutexPend_0
    443                  *perr = OS_ERR_EVENT_TYPE;
   \   000010   DD430000     MOV.B   #0x1, 0(R13)
    444                  return;
   \   000014   CD3C         JMP     ??OSMutexPend_1
    445              }
    446              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMutexPend_0:
   \   000016   ........     CALLA   #??Subroutine0_0
   \                     ??CrossCallReturnLabel_9:
   \   00001A   0324         JEQ     ??OSMutexPend_2
    447                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   00001C   ED430000     MOV.B   #0x2, 0(R13)
    448                  return;
   \   000020   C73C         JMP     ??OSMutexPend_1
    449              }
    450              if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
   \                     ??OSMutexPend_2:
   \   000022   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   000028   0424         JEQ     ??OSMutexPend_3
    451                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   00002A   FD400D000000 MOV.B   #0xd, 0(R13)
    452                  return;
   \   000030   BF3C         JMP     ??OSMutexPend_1
    453              }
    454          /*$PAGE*/
    455              OS_ENTER_CRITICAL();
   \                     ??OSMutexPend_3:
   \   000032   ........     CALLA   #OSCPUSaveSR
   \   000036   074C         MOV.W   R12, R7
    456              pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
   \   000038   1E4A0600     MOV.W   0x6(R10), R14
   \   00003C   0F4E         MOV.W   R14, R15
   \   00003E   8F10         SWPB    R15
    457                                                                     /* Is Mutex available?                      */
    458              if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   000040   ........     MOVA    #OSTCBCur, R8
   \   000044   7E93         CMP.B   #0xff, R14
   \   000046   1720         JNE     ??OSMutexPend_4
    459                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
   \   000048   BAF000FF0600 AND.W   #0xff00, 0x6(R10)
    460                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
   \   00004E   0D08         MOVA    @R8, R13
   \   000050   5E4D3000     MOV.B   0x30(R13), R14
   \   000054   8ADE0600     BIS.W   R14, 0x6(R10)
    461                  pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
   \   000058   0018EA480200 MOVX.A  @R8, 0x2(R10)
    462                  if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
   \   00005E   5F9D3000     CMP.B   0x30(R13), R15
   \   000062   0628         JNC     ??OSMutexPend_5
    463                      OS_EXIT_CRITICAL();                            /*      ... than current task!              */
   \   000064   ........     CALLA   #OSCPURestoreSR
    464                      *perr = OS_ERR_PIP_LOWER;
   \   000068   FB4078000000 MOV.B   #0x78, 0(R11)
   \   00006E   A03C         JMP     ??OSMutexPend_1
    465                  } else {
    466                      OS_EXIT_CRITICAL();
   \                     ??OSMutexPend_5:
   \   000070   ........     CALLA   #?Subroutine2
    467                      *perr = OS_ERR_NONE;
    468                  }
    469                  return;
    470              }
   \                     ??CrossCallReturnLabel_3:
   \   000074   9D3C         JMP     ??OSMutexPend_1
    471              mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
    472              ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
   \                     ??OSMutexPend_4:
   \   000076   390A0200     MOVA    0x2(R10), R9
   \   00007A   5F993000     CMP.B   0x30(R9), R15
   \   00007E   5F2C         JC      ??OSMutexPend_6
    473              if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
    474                  if (mprio > OSTCBCur->OSTCBPrio) {
   \   000080   0D08         MOVA    @R8, R13
   \   000082   CD9E3000     CMP.B   R14, 0x30(R13)
   \   000086   5B2C         JC      ??OSMutexPend_6
    475                      y = ptcb->OSTCBY;
   \   000088   C609         MOVA    R9, R6
   \   00008A   A6003200     ADDA    #0x32, R6
   \   00008E   6E46         MOV.B   @R6, R14
    476                      if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {          /*     See if mutex owner is ready   */
   \   000090   54493300     MOV.B   0x33(R9), R4
   \   000094   ....5D4E.... MOVX.B  OSRdyTbl(R14), R13
   \   00009A   4DB4         BIT.B   R4, R13
   \   00009C   0D24         JEQ     ??OSMutexPend_7
    477                          OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;         /*     Yes, Remove owner from Rdy ...*/
   \   00009E   ....CEC4.... BICX.B  R4, OSRdyTbl(R14)
    478                          if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
   \   0000A4   ....CE93.... CMPX.B  #0x0, OSRdyTbl(R14)
   \   0000AA   0420         JNE     ??OSMutexPend_8
    479                              OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   0000AC   ....D2C93400 BICX.B  0x34(R9), &OSRdyGrp
   \            ....        
    480                          }
    481                          rdy = OS_TRUE;
   \                     ??OSMutexPend_8:
   \   0000B4   5543         MOV.B   #0x1, R5
   \   0000B6   0F3C         JMP     ??OSMutexPend_9
    482                      } else {
    483                          pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_7:
   \   0000B8   3D091C00     MOVA    0x1c(R9), R13
    484                          if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
   \   0000BC   DD03         CMPA    #0x0, R13
   \   0000BE   0A24         JEQ     ??OSMutexPend_10
    485                              y = ptcb->OSTCBY;
    486                              pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
   \   0000C0   C50D         MOVA    R13, R5
   \   0000C2   E50E         ADDA    R14, R5
   \   0000C4   C5C40900     BIC.B   R4, 0x9(R5)
    487                              if (pevent2->OSEventTbl[y] == 0u) {
   \   0000C8   C5930900     CMP.B   #0x0, 0x9(R5)
   \   0000CC   0320         JNE     ??OSMutexPend_10
    488                                  pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   0000CE   DDC934000800 BIC.B   0x34(R9), 0x8(R13)
    489                              }
    490                          }
    491                          rdy = OS_FALSE;                            /* No                                       */
   \                     ??OSMutexPend_10:
   \   0000D4   4543         MOV.B   #0x0, R5
    492                      }
    493                      ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
   \                     ??OSMutexPend_9:
   \   0000D6   C94F3000     MOV.B   R15, 0x30(R9)
    494          #if OS_LOWEST_PRIO <= 63u
    495                      ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
   \   0000DA   444F         MOV.B   R15, R4
   \   0000DC   4C4F         MOV.B   R15, R12
   \   0000DE                RPT     #0x3
   \   0000DE   42194C10     RRUX.B  R12
   \   0000E2   C94C3200     MOV.B   R12, 0x32(R9)
    496                      ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
   \   0000E6   74F00700     AND.B   #0x7, R4
   \   0000EA   C9443100     MOV.B   R4, 0x31(R9)
    497          #else
    498                      ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
    499                      ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
    500          #endif
    501                      ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   0000EE   ........     CALLA   #?OneBitMask32
   \   0000F2   C94C3400     MOV.B   R12, 0x34(R9)
    502                      ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   0000F6   5E43         MOV.B   #0x1, R14
   \   0000F8   5483         SUB.B   #0x1, R4
   \   0000FA   0230         JN      ??OSMutexPend_11
   \   0000FC                RPT     R4
   \   0000FC   C4184E5E     RLAX.B  R14
   \                     ??OSMutexPend_11:
   \   000100   C94E3300     MOV.B   R14, 0x33(R9)
    503          
    504                      if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
   \   000104   55B3         BIT.B   #0x1, R5
   \   000106   0A28         JNC     ??OSMutexPend_12
    505                          OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
   \   000108   ....D2D93400 BISX.B  0x34(R9), &OSRdyGrp
   \            ....        
    506                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000110   6E46         MOV.B   @R6, R14
   \   000112   ....DED93300 BISX.B  0x33(R9), OSRdyTbl(R14)
   \            ....        
   \   00011A   0C3C         JMP     ??OSMutexPend_13
    507                      } else {
    508                          pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_12:
   \   00011C   3D091C00     MOVA    0x1c(R9), R13
    509                          if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
   \   000120   DD03         CMPA    #0x0, R13
   \   000122   0824         JEQ     ??OSMutexPend_13
    510                              pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
   \   000124   DDD934000800 BIS.B   0x34(R9), 0x8(R13)
    511                              pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00012A   6E46         MOV.B   @R6, R14
   \   00012C   ED0E         ADDA    R14, R13
   \   00012E   DDD933000900 BIS.B   0x33(R9), 0x9(R13)
    512                          }
    513                      }
    514                      OSTCBPrioTbl[pip] = ptcb;
   \                     ??OSMutexPend_13:
   \   000134   4F4F         MOV.B   R15, R15
   \   000136   4F06         RLAM.A  #0x2, R15
   \   000138   ....CF49.... MOVX.A  R9, OSTCBPrioTbl(R15)
    515                  }
    516              }
    517              OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
   \                     ??OSMutexPend_6:
   \   00013E   0F08         MOVA    @R8, R15
   \   000140   FFD010002E00 BIS.B   #0x10, 0x2e(R15)
    518              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   000146   0F08         MOVA    @R8, R15
   \   000148   CF432F00     MOV.B   #0x0, 0x2f(R15)
    519              OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
   \   00014C   0F08         MOVA    @R8, R15
   \   00014E   AF412A00     MOV.W   @SP, 0x2a(R15)
   \   000152   9F4102002C00 MOV.W   0x2(SP), 0x2c(R15)
    520              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   000158   CC0A         MOVA    R10, R12
   \   00015A   ........     CALLA   #OS_EventTaskWait
    521              OS_EXIT_CRITICAL();
   \   00015E   0C47         MOV.W   R7, R12
   \   000160   ........     CALLA   #?Subroutine1
    522              OS_Sched();                                       /* Find next highest priority task ready         */
    523              OS_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_0:
   \   000164   ........     CALLA   #OSCPUSaveSR
   \   000168   074C         MOV.W   R12, R7
   \   00016A   0F08         MOVA    @R8, R15
   \   00016C   5E4F2F00     MOV.B   0x2f(R15), R14
   \   000170   4E83         SUB.B   #0x0, R14
   \   000172   0324         JEQ     ??OSMutexPend_14
   \   000174   6E83         SUB.B   #0x2, R14
   \   000176   0424         JEQ     ??OSMutexPend_15
   \   000178   073C         JMP     ??OSMutexPend_16
    524              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
    525                  case OS_STAT_PEND_OK:
    526                       *perr = OS_ERR_NONE;
   \                     ??OSMutexPend_14:
   \   00017A   CB430000     MOV.B   #0x0, 0(R11)
    527                       break;
   \   00017E   0B3C         JMP     ??OSMutexPend_17
    528          
    529                  case OS_STAT_PEND_ABORT:
    530                       *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
   \                     ??OSMutexPend_15:
   \   000180   FB400E000000 MOV.B   #0xe, 0(R11)
    531                       break;
   \   000186   073C         JMP     ??OSMutexPend_17
    532          
    533                  case OS_STAT_PEND_TO:
    534                  default:
    535                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSMutexPend_16:
   \   000188   CD0A         MOVA    R10, R13
   \   00018A   0C08         MOVA    @R8, R12
   \   00018C   ........     CALLA   #OS_EventTaskRemove
    536                       *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
   \   000190   FB400A000000 MOV.B   #0xa, 0(R11)
    537                       break;
    538              }
    539              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSMutexPend_17:
   \   000196   0F08         MOVA    @R8, R15
   \   000198   CF432E00     MOV.B   #0x0, 0x2e(R15)
    540              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   00019C   0F08         MOVA    @R8, R15
   \   00019E   CF432F00     MOV.B   #0x0, 0x2f(R15)
    541              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   0001A2   0F08         MOVA    @R8, R15
   \   0001A4   0018CF431C00 MOVX.A  #0x0, 0x1c(R15)
    542          #if (OS_EVENT_MULTI_EN > 0u)
    543              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    544          #endif
    545              OS_EXIT_CRITICAL();
   \   0001AA   0C47         MOV.W   R7, R12
   \   0001AC   ........     CALLA   #OSCPURestoreSR
    546          }
   \                     ??OSMutexPend_1:
   \   0001B0   2152         ADD.W   #0x4, SP
   \   0001B2   7416         POPM.A  #0x8, R11
   \   0001B4   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   ........     CALLA   #OSCPURestoreSR
   \   000004   ........     BRA     #OS_Sched
    547          /*$PAGE*/
    548          /*
    549          *********************************************************************************************************
    550          *                                  POST TO A MUTUAL EXCLUSION SEMAPHORE
    551          *
    552          * Description: This function signals a mutual exclusion semaphore
    553          *
    554          * Arguments  : pevent              is a pointer to the event control block associated with the desired
    555          *                                  mutex.
    556          *
    557          * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
    558          *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    559          *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
    560          *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
    561          *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
    562          *              OS_ERR_PIP_LOWER        If the priority of the new task that owns the Mutex is
    563          *                                      HIGHER (i.e. a lower number) than the PIP.  This error
    564          *                                      indicates that you did not set the PIP higher (lower
    565          *                                      number) than ALL the tasks that compete for the Mutex.
    566          *                                      Unfortunately, this is something that could not be
    567          *                                      detected when the Mutex is created because we don't know
    568          *                                      what tasks will be using the Mutex.
    569          *********************************************************************************************************
    570          */
    571          

   \                                 In  segment CODE, align 2
    572          INT8U  OSMutexPost (OS_EVENT *pevent)
   \                     OSMutexPost:
    573          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CB0C         MOVA    R12, R11
    574              INT8U      pip;                                   /* Priority inheritance priority                 */
    575              INT8U      prio;
    576          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    577              OS_CPU_SR  cpu_sr = 0u;
    578          #endif
    579          
    580          
    581          
    582              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
   \   000004   ........     CALLA   #??Subroutine0_0
   \                     ??CrossCallReturnLabel_8:
   \   000008   0324         JEQ     ??OSMutexPost_0
    583                  return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
   \   00000A   7C400500     MOV.B   #0x5, R12
   \   00000E   4F3C         JMP     ??OSMutexPost_1
    584              }
    585          #if OS_ARG_CHK_EN > 0u
    586              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    587                  return (OS_ERR_PEVENT_NULL);
    588              }
    589          #endif
    590              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
   \                     ??OSMutexPost_0:
   \   000010   EC920000     CMP.B   #0x4, 0(R12)
   \   000014   0224         JEQ     ??OSMutexPost_2
    591                  return (OS_ERR_EVENT_TYPE);
   \   000016   5C43         MOV.B   #0x1, R12
   \   000018   4A3C         JMP     ??OSMutexPost_1
    592              }
    593              OS_ENTER_CRITICAL();
   \                     ??OSMutexPost_2:
   \   00001A   ........     CALLA   #OSCPUSaveSR
   \   00001E   0A4C         MOV.W   R12, R10
   \   000020   1D4B0600     MOV.W   0x6(R11), R13
   \   000024   084D         MOV.W   R13, R8
   \   000026   8810         SWPB    R8
    594              pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
    595              prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
    596              if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
   \   000028   ........     MOVA    &OSTCBCur, R12
   \   00002C   3F0B0200     MOVA    0x2(R11), R15
   \   000030   DC0F         CMPA    R15, R12
   \   000032   0624         JEQ     ??OSMutexPost_3
    597                  OS_EXIT_CRITICAL();
   \   000034   0C4A         MOV.W   R10, R12
   \   000036   ........     CALLA   #OSCPURestoreSR
    598                  return (OS_ERR_NOT_MUTEX_OWNER);
   \   00003A   7C406400     MOV.B   #0x64, R12
   \   00003E   373C         JMP     ??OSMutexPost_1
    599              }
    600              if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
   \                     ??OSMutexPost_3:
   \   000040   CC983000     CMP.B   R8, 0x30(R12)
   \   000044   0220         JNE     ??OSMutexPost_4
    601                  OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
   \   000046   ........     CALLA   #OSMutex_RdyAtPrio
    602              }
    603              OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
   \                     ??OSMutexPost_4:
   \   00004A   4F48         MOV.B   R8, R15
   \   00004C   4F06         RLAM.A  #0x2, R15
   \   00004E   ....DF43.... MOVX.A  #0x1, OSTCBPrioTbl(R15)
    604              if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
   \   000054   CB930800     CMP.B   #0x0, 0x8(R11)
   \   000058   2024         JEQ     ??OSMutexPost_5
    605                                                                /* Yes, Make HPT waiting for mutex ready         */
    606                  prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
   \   00005A   4F43         MOV.B   #0x0, R15
   \   00005C   7E401000     MOV.B   #0x10, R14
   \   000060   4D43         MOVA    #0x0, R13
   \   000062   CC0B         MOVA    R11, R12
   \   000064   ........     CALLA   #OS_EventTaskRdy
   \   000068   4D4C         MOV.B   R12, R13
    607                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
    608                  pevent->OSEventCnt |= prio;
   \   00006A   1F4B0600     MOV.W   0x6(R11), R15
   \   00006E   3FF000FF     AND.W   #0xff00, R15
   \   000072   0FDD         BIS.W   R13, R15
   \   000074   8B4F0600     MOV.W   R15, 0x6(R11)
    609                  pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
   \   000078   4F4C         MOV.B   R12, R15
   \   00007A   4F06         RLAM.A  #0x2, R15
   \   00007C   ....DB4F.... MOVX.A  OSTCBPrioTbl(R15), 0x2(R11)
   \            0200        
    610                  if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
   \   000084   489C         CMP.B   R12, R8
   \   000086   0C4A         MOV.W   R10, R12
   \   000088   0528         JNC     ??OSMutexPost_6
    611                      OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
   \   00008A   ........     CALLA   #?Subroutine1
    612                      OS_Sched();                               /*      Find highest priority task ready to run  */
    613                      return (OS_ERR_PIP_LOWER);
   \                     ??CrossCallReturnLabel_2:
   \   00008E   7C407800     MOV.B   #0x78, R12
   \   000092   0D3C         JMP     ??OSMutexPost_1
    614                  } else {
    615                      OS_EXIT_CRITICAL();
   \                     ??OSMutexPost_6:
   \   000094   ........     CALLA   #?Subroutine1
    616                      OS_Sched();                               /*      Find highest priority task ready to run  */
    617                      return (OS_ERR_NONE);
   \                     ??CrossCallReturnLabel_1:
   \   000098   093C         JMP     ??OSMutexPost_7
    618                  }
    619              }
    620              pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
   \                     ??OSMutexPost_5:
   \   00009A   BBD0FF000600 BIS.W   #0xff, 0x6(R11)
    621              pevent->OSEventPtr  = (void *)0;
   \   0000A0   0018CB430200 MOVX.A  #0x0, 0x2(R11)
    622              OS_EXIT_CRITICAL();
   \   0000A6   0C4A         MOV.W   R10, R12
   \   0000A8   ........     CALLA   #OSCPURestoreSR
    623              return (OS_ERR_NONE);
   \                     ??OSMutexPost_7:
   \   0000AC   4C43         MOV.B   #0x0, R12
   \                     ??OSMutexPost_1:
   \   0000AE   3816         POPM.A  #0x4, R11
   \   0000B0   1001         RETA
    624          }
    625          /*$PAGE*/
    626          /*
    627          *********************************************************************************************************
    628          *                                     QUERY A MUTUAL EXCLUSION SEMAPHORE
    629          *
    630          * Description: This function obtains information about a mutex
    631          *
    632          * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
    633          *
    634          *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
    635          *
    636          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    637          *              OS_ERR_QUERY_ISR     If you called this function from an ISR
    638          *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
    639          *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
    640          *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
    641          *********************************************************************************************************
    642          */
    643          
    644          #if OS_MUTEX_QUERY_EN > 0u

   \                                 In  segment CODE, align 2
    645          INT8U  OSMutexQuery (OS_EVENT       *pevent,
   \                     OSMutexQuery:
    646                               OS_MUTEX_DATA  *p_mutex_data)
    647          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   ........     CALLA   #?Subroutine0
    648              INT8U       i;
    649              OS_PRIO    *psrc;
    650              OS_PRIO    *pdest;
    651          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    652              OS_CPU_SR   cpu_sr = 0u;
    653          #endif
    654          
    655          
    656          
    657              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??CrossCallReturnLabel_6:
   \   000008   0324         JEQ     ??OSMutexQuery_1
    658                  return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
   \   00000A   7C400600     MOV.B   #0x6, R12
   \   00000E   283C         JMP     ??OSMutexQuery_2
    659              }
    660          #if OS_ARG_CHK_EN > 0u
    661              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    662                  return (OS_ERR_PEVENT_NULL);
    663              }
    664              if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
    665                  return (OS_ERR_PDATA_NULL);
    666              }
    667          #endif
    668              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \                     ??OSMutexQuery_1:
   \   000010   EC920000     CMP.B   #0x4, 0(R12)
   \   000014   0224         JEQ     ??OSMutexQuery_3
    669                  return (OS_ERR_EVENT_TYPE);
   \   000016   5C43         MOV.B   #0x1, R12
   \   000018   233C         JMP     ??OSMutexQuery_2
    670              }
    671              OS_ENTER_CRITICAL();
   \                     ??OSMutexQuery_3:
   \   00001A   ........     CALLA   #OSCPUSaveSR
    672              p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8u);
   \   00001E   DB4A07000B00 MOV.B   0x7(R10), 0xb(R11)
    673              p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
   \   000024   DB4A06000A00 MOV.B   0x6(R10), 0xa(R11)
    674              if (p_mutex_data->OSOwnerPrio == 0xFFu) {
   \   00002A   FB930A00     CMP.B   #0xff, 0xa(R11)
   \   00002E   0224         JEQ     ??OSMutexQuery_4
   \   000030   4E43         MOV.B   #0x0, R14
   \   000032   013C         JMP     ??OSMutexQuery_5
   \                     ??OSMutexQuery_4:
   \   000034   5E43         MOV.B   #0x1, R14
   \                     ??OSMutexQuery_5:
   \   000036   CB4E0900     MOV.B   R14, 0x9(R11)
    675                  p_mutex_data->OSValue = OS_TRUE;
    676              } else {
    677                  p_mutex_data->OSValue = OS_FALSE;
    678              }
    679              p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
   \   00003A   DB4A08000800 MOV.B   0x8(R10), 0x8(R11)
    680              psrc                      = &pevent->OSEventTbl[0];
   \   000040   AA000900     ADDA    #0x9, R10
    681              pdest                     = &p_mutex_data->OSEventTbl[0];
    682              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   000044   6E42         MOV.B   #0x4, R14
    683                  *pdest++ = *psrc++;
   \                     ??OSMutexQuery_0:
   \   000046   FB4A0000     MOV.B   @R10+, 0(R11)
   \   00004A   AB000100     ADDA    #0x1, R11
   \   00004E   FB4A0000     MOV.B   @R10+, 0(R11)
   \   000052   AB000100     ADDA    #0x1, R11
    684              }
   \   000056   7E53         ADD.B   #0xff, R14
   \   000058   F623         JNE     ??OSMutexQuery_0
    685              OS_EXIT_CRITICAL();
   \   00005A   ........     CALLA   #OSCPURestoreSR
    686              return (OS_ERR_NONE);
   \   00005E   4C43         MOV.B   #0x0, R12
   \                     ??OSMutexQuery_2:
   \   000060   1A16         POPM.A  #0x2, R11
   \   000062   1001         RETA
    687          }
    688          #endif                                                     /* OS_MUTEX_QUERY_EN                        */
    689          
    690          /*$PAGE*/
    691          /*
    692          *********************************************************************************************************
    693          *                                RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
    694          *
    695          * Description: This function makes a task ready at the specified priority
    696          *
    697          * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
    698          *
    699          *              prio            is the desired priority
    700          *
    701          * Returns    : none
    702          *********************************************************************************************************
    703          */
    704          

   \                                 In  segment CODE, align 2
    705          static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
   \                     OSMutex_RdyAtPrio:
    706                                           INT8U    prio)
    707          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   5F4C3200     MOV.B   0x32(R12), R15
    708              INT8U  y;
    709          
    710          
    711              y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    712              OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
   \   000006   ....DFCC3300 BICX.B  0x33(R12), OSRdyTbl(R15)
   \            ....        
    713              if (OSRdyTbl[y] == 0u) {
   \   00000E   ....CF93.... CMPX.B  #0x0, OSRdyTbl(R15)
   \   000014   0420         JNE     ??OSMutex_RdyAtPrio_0
    714                  OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   000016   ....D2CC3400 BICX.B  0x34(R12), &OSRdyGrp
   \            ....        
    715              }
    716              ptcb->OSTCBPrio         = prio;
   \                     ??OSMutex_RdyAtPrio_0:
   \   00001E   CC4D3000     MOV.B   R13, 0x30(R12)
    717              OSPrioCur               = prio;                        /* The current task is now at this priority */
   \   000022   ....C24D.... MOVX.B  R13, &OSPrioCur
   \   000028   4E4D         MOV.B   R13, R14
   \   00002A                RPT     #0x3
   \   00002A   42194E10     RRUX.B  R14
   \   00002E   7EF00700     AND.B   #0x7, R14
   \   000032   CC4E3200     MOV.B   R14, 0x32(R12)
    718          #if OS_LOWEST_PRIO <= 63u
    719              ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
    720              ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
   \   000036   4F4D         MOV.B   R13, R15
   \   000038   7FF00700     AND.B   #0x7, R15
   \   00003C   CC4F3100     MOV.B   R15, 0x31(R12)
    721          #else
    722              ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
    723              ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
    724          #endif
    725              ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   000040   5A43         MOV.B   #0x1, R10
   \   000042   5E83         SUB.B   #0x1, R14
   \   000044   0230         JN      ??OSMutex_RdyAtPrio_1
   \   000046                RPT     R14
   \   000046   CE184A5A     RLAX.B  R10
   \                     ??OSMutex_RdyAtPrio_1:
   \   00004A   CC4A3400     MOV.B   R10, 0x34(R12)
    726              ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   00004E   5E43         MOV.B   #0x1, R14
   \   000050   5F83         SUB.B   #0x1, R15
   \   000052   0230         JN      ??OSMutex_RdyAtPrio_2
   \   000054                RPT     R15
   \   000054   CF184E5E     RLAX.B  R14
   \                     ??OSMutex_RdyAtPrio_2:
   \   000058   CC4E3300     MOV.B   R14, 0x33(R12)
    727              OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
   \   00005C   ....C2DA.... BISX.B  R10, &OSRdyGrp
    728              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000062   5F4C3200     MOV.B   0x32(R12), R15
   \   000066   ....DFDC3300 BISX.B  0x33(R12), OSRdyTbl(R15)
   \            ....        
    729              OSTCBPrioTbl[prio]      = ptcb;
   \   00006E   4D4D         MOV.B   R13, R13
   \   000070   4D06         RLAM.A  #0x2, R13
   \   000072   ....CD4C.... MOVX.A  R12, OSTCBPrioTbl(R13)
    730          
    731          }
   \   000078   0A16         POPM.A  #0x1, R10
   \   00007A   1001         RETA
    732          
    733          
    734          #endif                                                     /* OS_MUTEX_EN                              */
    735          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      12  OSMutexAccept
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
      20  OSMutexCreate
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventWaitListInit
      28  OSMutexDel
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OSMutex_RdyAtPrio
            28 -> OS_EventTaskRdy
            28 -> OS_Sched
      40  OSMutexPend
            40 -> OSCPURestoreSR
            40 -> OSCPUSaveSR
            40 -> OS_EventTaskRemove
            40 -> OS_EventTaskWait
            40 -> OS_Sched
      20  OSMutexPost
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OSMutex_RdyAtPrio
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      12  OSMutexQuery
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
       8  OSMutex_RdyAtPrio


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine0_0
       2  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
      34  ?Subroutine3
     104  OSMutexAccept
     130  OSMutexCreate
     178  OSMutexDel
     438  OSMutexPend
     178  OSMutexPost
     100  OSMutexQuery
     124  OSMutex_RdyAtPrio

 
 1 314 bytes in segment CODE
 
 1 314 bytes of CODE memory

Errors: none
Warnings: 11
