###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:37 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c         #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c -D      #
#                     NDEBUG -D RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MS #
#                     P430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\usb.lst                             #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\usb.r43                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c
      1          // (c)2010 by Texas Instruments Incorporated, All Rights Reserved.
      2          /*----------------------------------------------------------------------------+
      3          |                                                                             |
      4          |                              Texas Instruments                              |
      5          |                                                                             |
      6          |                          MSP430 USB-Example (CDC/HID Driver)                |
      7          |                                                                             |
      8          +-----------------------------------------------------------------------------+
      9          |  Source: usb.c, File Version 1.02 2010/06/17                                |
     10          |  Author: RSTO                                                               |
     11          |                                                                             |
     12          |  WHO          WHEN         WHAT                                             |
     13          |  ---          ----------   ------------------------------------------------ |
     14          |  RSTO         2008/09/03   born                                             |
     15          |  RSTO         2008/12/23   enhancements of CDC API                          |
     16          |  RSTO         2009/01/12   enhancements for USB serial number               |
     17          |  RSTO         2009/05/15   added USB_connectionState()                      |
     18          |  RSTO         2009/07/17   added __data16 qualifier for USB buffers         |
     19          |  RSTO         2009/08/04   workaround for PLL start up problem              |
     20          |  MSP,Biju     2009/10/20   Changes for composite support                    |
     21          |  RSTO         2009/10/21   updated USB_InitSerialStringDescriptor()         |
     22          |  RSTO         2009/11/05   updated USB_connectionState()                    |
     23          |  MSP,Biju     2010/07/15   Updated for MSC                                  |
     24          +----------------------------------------------------------------------------*/
     25          /*----------------------------------------------------------------------------+
     26          | Include files                                                               |
     27          +----------------------------------------------------------------------------*/
     28          
     29          #include "../USB_Common/device.h"

   \                                 In  segment DATA16_AN, at 0x900
   \   union <unnamed> __data16 _A_USBKEYID_L
   \                     _A_USBKEYID_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x902
   \   union <unnamed> __data16 _A_USBCNF_L
   \                     _A_USBCNF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x904
   \   union <unnamed> __data16 _A_USBPHYCTL_L
   \                     _A_USBPHYCTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x908
   \   union <unnamed> __data16 _A_USBPWRCTL_L
   \                     _A_USBPWRCTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x910
   \   union <unnamed> __data16 _A_USBPLLCTL_L
   \                     _A_USBPLLCTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x912
   \   union <unnamed> __data16 _A_USBPLLDIVB_L
   \                     _A_USBPLLDIVB_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x914
   \   union <unnamed> __data16 _A_USBPLLIR_L
   \                     _A_USBPLLIR_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x92e
   \   unsigned char volatile __data16 USBIEPIE
   \                     USBIEPIE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x92f
   \   unsigned char volatile __data16 USBOEPIE
   \                     USBOEPIE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x93c
   \   unsigned char volatile __data16 USBCTL
   \                     USBCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x93d
   \   unsigned char volatile __data16 USBIE
   \                     USBIE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x93e
   \   unsigned char volatile __data16 USBIFG
   \                     USBIFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x93f
   \   unsigned char volatile __data16 USBFUNADR
   \                     USBFUNADR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x16c
   \   union <unnamed> __data16 _A_UCSCTL6_L
   \                     _A_UCSCTL6_L:
   \   000000                DS8 2
     30          #include "../USB_Common/types.h"              // Basic Type declarations
     31          #include "../USB_Common/defMSP430USB.h"
     32          #include "../USB_Common/usb.h"  // USB-specific Data Structures
     33          #include "../USB_CDC_API/UsbCdc.h"
     34          #include "../USB_HID_API/UsbHidReq.h"
     35          #include "../USB_MSC_API/UsbMscScsi.h"
     36          #include <descriptors.h>
     37          
     38          #include <HAL_UCS.h>
     39          #include <HAL_TLV.h>
     40          #include <string.h>
     41          
     42          /*----------------------------------------------------------------------------+
     43           | Internal Constant Definition                                               |
     44           +----------------------------------------------------------------------------*/
     45          #define NO_MORE_DATA    0xFFFF
     46          #define EPBCT_NAK       0x80
     47          #define EPCNF_TOGLE     0x20
     48          
     49          #define DIRECTION_IN	0x80
     50          #define DIRECTION_OUT	0x00
     51          
     52          /*----------------------------------------------------------------------------+
     53          | Internal Variables                                                          |
     54          +----------------------------------------------------------------------------*/
     55          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     56          static BYTE bConfigurationNumber;      // Set to 1 when USB device has been
   \                     bConfigurationNumber:
   \   000000                DS8 1
     57                                          // configured, set to 0 when unconfigured
     58          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     59          static BYTE bInterfaceNumber;   // interface number
   \                     bInterfaceNumber:
   \   000000                DS8 1
     60          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     61          WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
   \                     wBytesRemainingOnIEP0:
   \   000000                DS8 2
     62                                          // Holds count of bytes remaining to be
     63                                          // transmitted by endpoint 0.  A value
     64                                          // of 0 means that a 0-length data packet
     65                                          // A value of 0xFFFF means that transfer
     66                                          // is complete.
     67          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     68          WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
   \                     wBytesRemainingOnOEP0:
   \   000000                DS8 2
     69                                          // Holds count of bytes remaining to be
     70                                          // received by endpoint 0.  A value
     71                                          // of 0 means that a 0-length data packet
     72                                          // A value of 0xFFFF means that transfer
     73                                          // is complete.
     74          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     75          static PBYTE pbIEP0Buffer;      // A buffer pointer to input end point 0
   \                     pbIEP0Buffer:
   \   000000                DS8 4
     76                                          // Data sent back to host is copied from
     77                                          // this pointed memory location
     78          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     79          static PBYTE pbOEP0Buffer;      // A buffer pointer to output end point 0
   \                     pbOEP0Buffer:
   \   000000                DS8 4
     80                                          // Data sent from host is copied to
     81                                          // this pointed memory location
     82          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     83          static BYTE bHostAskMoreDataThanAvailable=0;
   \                     bHostAskMoreDataThanAvailable:
   \   000000                DS8 1
     84          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     85          BYTE abUsbRequestReturnData[USB_RETURN_DATA_LENGTH];
   \                     abUsbRequestReturnData:
   \   000000                DS8 8

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     86          BYTE abUsbRequestIncomingData[USB_RETURN_DATA_LENGTH];
   \                     abUsbRequestIncomingData:
   \   000000                DS8 8
     87          

   \                                 In  segment DATA20_N, align 1, align-sorted
     88          __no_init BYTE abramSerialStringDescriptor[34];
   \                     abramSerialStringDescriptor:
   \   000000                DS8 34
     89          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     90          BYTE bStatusAction;
   \                     bStatusAction:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     91          BYTE bFunctionSuspended=FALSE;  // TRUE if function is suspended
   \                     bFunctionSuspended:
   \   000000                DS8 1

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     92          BYTE bEnumerationStatus = 0;    //is 0 if not enumerated
   \                     bEnumerationStatus:
   \   000000                DS8 1
     93          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     94          static BYTE bRemoteWakeup;
   \                     bRemoteWakeup:
   \   000000                DS8 1
     95          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     96          WORD wUsbEventMask;             //used by USB_getEnabledEvents() and USB_setEnabledEvents()
   \                     wUsbEventMask:
   \   000000                DS8 2
     97          
     98          #ifdef _MSC_
     99          void MscResetData();
    100          extern BOOL bMcsCommandSupported;
    101          extern BOOL isMSCConfigured;
    102          
    103          extern BYTE bMscResetRequired;
    104          #endif
    105          
    106          /*----------------------------------------------------------------------------+
    107          | Global Variables                                                            |
    108          +----------------------------------------------------------------------------*/
    109          /*----------------------------------------------------------------------------+
    110          | Hardware Related Structure Definition                                       |
    111          +----------------------------------------------------------------------------*/
    112          
    113          #ifdef __IAR_SYSTEMS_ICC__
    114          
    115          #pragma location = 0x2380

   \                                 In  segment DATA16_AN, at 0x2380
    116          __no_init tDEVICE_REQUEST __data16 tSetupPacket;
   \                     tSetupPacket:
   \   000000                DS8 8
    117          
    118          #pragma location = 0x0920

   \                                 In  segment DATA16_AN, at 0x920
    119          __no_init tEDB0 __data16 tEndPoint0DescriptorBlock;
   \                     tEndPoint0DescriptorBlock:
   \   000000                DS8 4
    120          
    121          #pragma location = 0x23C8

   \                                 In  segment DATA16_AN, at 0x23c8
    122          __no_init tEDB __data16 tInputEndPointDescriptorBlock[7];
   \                     tInputEndPointDescriptorBlock:
   \   000000                DS8 56
    123          
    124          #pragma location = 0x2388

   \                                 In  segment DATA16_AN, at 0x2388
    125          __no_init tEDB __data16 tOutputEndPointDescriptorBlock[7];
   \                     tOutputEndPointDescriptorBlock:
   \   000000                DS8 56
    126          
    127          #pragma location = 0x2378

   \                                 In  segment DATA16_AN, at 0x2378
    128          __no_init BYTE __data16 abIEP0Buffer[EP0_MAX_PACKET_SIZE];
   \                     abIEP0Buffer:
   \   000000                DS8 8
    129          
    130          #pragma location = 0x2370

   \                                 In  segment DATA16_AN, at 0x2370
    131          __no_init BYTE __data16 abOEP0Buffer[EP0_MAX_PACKET_SIZE];
   \                     abOEP0Buffer:
   \   000000                DS8 8
    132          
    133          #pragma location = OEP1_X_BUFFER_ADDRESS
    134           __no_init BYTE __data16 pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
    135          
    136          #pragma location = OEP1_Y_BUFFER_ADDRESS
    137           __no_init BYTE __data16 pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
    138          
    139          #pragma location = IEP1_X_BUFFER_ADDRESS
    140           __no_init BYTE __data16 pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
    141          
    142          #pragma location = IEP1_Y_BUFFER_ADDRESS
    143           __no_init BYTE __data16 pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
    144          
    145          #pragma location = OEP2_X_BUFFER_ADDRESS
    146           __no_init BYTE __data16 pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
    147          
    148          #pragma location = OEP2_Y_BUFFER_ADDRESS
    149           __no_init BYTE __data16 pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
    150          
    151          #pragma location = IEP2_X_BUFFER_ADDRESS
    152           __no_init BYTE __data16 pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
    153          
    154          #pragma location = IEP2_Y_BUFFER_ADDRESS
    155           __no_init BYTE __data16 pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
    156          
    157          #pragma location = OEP3_X_BUFFER_ADDRESS
    158          __no_init BYTE __data16 pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
    159          
    160          #pragma location = OEP3_Y_BUFFER_ADDRESS
    161          __no_init BYTE __data16 pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
    162          
    163          #pragma location = IEP3_X_BUFFER_ADDRESS
    164          __no_init BYTE __data16 pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
    165          
    166          #pragma location = IEP3_Y_BUFFER_ADDRESS
    167          __no_init BYTE __data16 pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
    168          
    169          #pragma location = OEP4_X_BUFFER_ADDRESS
    170          __no_init BYTE __data16 pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
    171          
    172          #pragma location = OEP4_Y_BUFFER_ADDRESS
    173          __no_init BYTE __data16 pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
    174          
    175          #pragma location = IEP4_X_BUFFER_ADDRESS
    176          __no_init BYTE __data16 pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
    177          
    178          #pragma location = IEP4_Y_BUFFER_ADDRESS
    179          __no_init BYTE __data16 pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
    180          
    181          #pragma location = OEP5_X_BUFFER_ADDRESS
    182          __no_init BYTE __data16 pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
    183          
    184          #pragma location = OEP5_Y_BUFFER_ADDRESS
    185          __no_init BYTE __data16 pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
    186          
    187          #pragma location = IEP5_X_BUFFER_ADDRESS
    188          __no_init BYTE __data16 pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
    189          
    190          #pragma location = IEP5_Y_BUFFER_ADDRESS
    191          __no_init BYTE __data16 pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
    192          
    193          #pragma location = OEP6_X_BUFFER_ADDRESS
    194          __no_init BYTE __data16 pbXBufferAddressEp6[EP_MAX_PACKET_SIZE];
    195          
    196          #pragma location = OEP6_Y_BUFFER_ADDRESS
    197          __no_init BYTE __data16 pbYBufferAddressEp6[EP_MAX_PACKET_SIZE];
    198          
    199          #pragma location = IEP6_X_BUFFER_ADDRESS
    200          __no_init BYTE __data16 pbXBufferAddressEp86[EP_MAX_PACKET_SIZE];
    201          
    202          #pragma location = IEP6_Y_BUFFER_ADDRESS
    203          __no_init BYTE __data16 pbYBufferAddressEp86[EP_MAX_PACKET_SIZE];
    204          
    205          #pragma location = OEP7_X_BUFFER_ADDRESS
    206          __no_init BYTE __data16 pbXBufferAddressEp7[EP_MAX_PACKET_SIZE];
    207          
    208          #pragma location = OEP7_Y_BUFFER_ADDRESS
    209          __no_init BYTE __data16 pbYBufferAddressEp7[EP_MAX_PACKET_SIZE];
    210          
    211          #pragma location = IEP7_X_BUFFER_ADDRESS
    212          __no_init BYTE __data16 pbXBufferAddressEp87[EP_MAX_PACKET_SIZE];
    213          
    214          #pragma location = IEP7_Y_BUFFER_ADDRESS
    215          __no_init BYTE __data16 pbYBufferAddressEp87[EP_MAX_PACKET_SIZE];
    216          
    217          
    218          
    219          #endif
    220          
    221          #ifdef __TI_COMPILER_VERSION__
    222          extern __no_init tDEVICE_REQUEST tSetupPacket;
    223          extern __no_init tEDB0 tEndPoint0DescriptorBlock;
    224          extern __no_init tEDB tInputEndPointDescriptorBlock[7];
    225          extern __no_init tEDB tOutputEndPointDescriptorBlock[7];
    226          extern __no_init BYTE abIEP0Buffer[EP0_MAX_PACKET_SIZE];
    227          extern __no_init BYTE abOEP0Buffer[EP0_MAX_PACKET_SIZE];
    228          extern __no_init BYTE pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
    229          extern __no_init BYTE pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
    230          extern __no_init BYTE pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
    231          extern __no_init BYTE pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
    232          extern __no_init BYTE pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
    233          extern __no_init BYTE pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
    234          extern __no_init BYTE pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
    235          extern __no_init BYTE pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
    236          extern __no_init BYTE pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
    237          extern __no_init BYTE pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
    238          extern __no_init BYTE pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
    239          extern __no_init BYTE pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
    240          
    241          extern __no_init BYTE pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
    242          extern __no_init BYTE pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
    243          extern __no_init BYTE pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
    244          extern __no_init BYTE pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
    245          
    246          extern __no_init BYTE pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
    247          extern __no_init BYTE pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
    248          extern __no_init BYTE pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
    249          extern __no_init BYTE pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
    250          
    251          #endif
    252          
    253          VOID CdcResetData();
    254          VOID HidResetData();
    255          
    256          VOID USB_InitSerialStringDescriptor(VOID);
    257          VOID USB_initMemcpy(VOID);
    258          
    259          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   B24000960009 MOV.W   #0x9600, &0x900
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   B24028960009 MOV.W   #0x9628, &0x900
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    260          BYTE USB_init(VOID)
   \                     USB_init:
    261          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   2183         SUB.W   #0x2, SP
    262              WORD bGIE  = __get_SR_register() &GIE;  //save interrupt status
   \   000004   0A42         MOV.W   SR, R10
   \   000006   3AF2         AND.W   #0x8, R10
    263              // atomic operation - disable interrupts
    264              __disable_interrupt();               // Disable global interrupts
   \   000008   32C2         DINT
   \   00000A   0343         NOP
    265          
    266              // configuration of USB module
    267              USBKEYPID   =     0x9628;            // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   00000C   ........     CALLA   #?Subroutine6
    268          
    269              USBPHYCTL   =     PUSEL;             // use DP and DM as USB terminals (not needed because an external PHY is connected to port 9)
   \                     ??CrossCallReturnLabel_10:
   \   000010   B24080000409 MOV.W   #0x80, &0x904
    270          
    271              USBPWRCTL   =     VUSBEN + SLDOAON; // enable primary and secondary LDO (3.3 and 1.8 V)
   \   000016   B24040080809 MOV.W   #0x840, &0x908
    272              {
    273              	volatile unsigned int i;
    274              	for (i =0; i < USB_MCLK_FREQ/1000*2/10; i++);      // wait some time for LDOs (1ms delay)
   \   00001C   81430000     MOV.W   #0x0, 0(SP)
   \   000020   043C         JMP     ??USB_init_1
   \                     ??USB_init_0:
   \   000022   2F41         MOV.W   @SP, R15
   \   000024   1F53         ADD.W   #0x1, R15
   \   000026   814F0000     MOV.W   R15, 0(SP)
   \                     ??USB_init_1:
   \   00002A   B19088130000 CMP.W   #0x1388, 0(SP)
   \   000030   F82B         JNC     ??USB_init_0
    275              }
    276          
    277              USBPWRCTL   =   VUSBEN + SLDOAON + VBONIE;  // enable interrupt VBUSon
   \   000032   B240400A0809 MOV.W   #0xa40, &0x908
    278              USBKEYPID   =    0x9600;            // access to configuration registers disabled
   \   000038   ........     CALLA   #?Subroutine7
    279          
    280              //reset events mask
    281              wUsbEventMask = 0;
   \                     ??CrossCallReturnLabel_14:
   \   00003C   ....8243.... MOVX.W  #0x0, &wUsbEventMask
    282          
    283              //init Serial Number
    284          #if (USB_STR_INDEX_SERNUM != 0)
    285              USB_InitSerialStringDescriptor();
   \   000042   ........     CALLA   #USB_InitSerialStringDescriptor
    286          #endif
    287          
    288              // init memcpy() function: DMA or non-DMA
    289              USB_initMemcpy();
   \   000046   ........     CALLA   #USB_initMemcpy
    290          #ifdef _MSC_
    291              MscResetCtrlLun();
   \   00004A   ........     CALLA   #MscResetCtrlLun
    292          #endif
    293          
    294              __bis_SR_register(bGIE); //restore interrupt status
   \   00004E   02DA         BIS.W   R10, SR
    295              return kUSB_succeed;
   \   000050   4C43         MOV.B   #0x0, R12
   \   000052   2153         ADD.W   #0x2, SP
   \   000054   0A16         POPM.A  #0x1, R10
   \   000056   1001         RETA
   \   000058                REQUIRE _A_USBKEYID_L
   \   000058                REQUIRE _A_USBPHYCTL_L
   \   000058                REQUIRE _A_USBPWRCTL_L
    296          }
    297          
    298          //----------------------------------------------------------------------------
    299          // This function will be compiled only if
    300          #if (USB_STR_INDEX_SERNUM != 0)

   \                                 In  segment CODE, align 2
    301          VOID USB_InitSerialStringDescriptor(VOID)
   \                     USB_InitSerialStringDescriptor:
    302          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   31800600     SUB.W   #0x6, SP
    303              BYTE i,j,hexValue;
    304              PBYTE pbSerNum;
    305              BYTE bBytes;
    306          
    307              j=1;                   // we start with second byte, first byte (lenght) will be filled later
    308              pbSerNum=0;
   \   000006   0018C1430200 MOVX.A  #0x0, 0x2(SP)
    309              abramSerialStringDescriptor[j++] = DESC_TYPE_STRING;
   \   00000C   ........     MOVA    #abramSerialStringDescriptor, R11
   \   000010   FB4003000100 MOV.B   #0x3, 0x1(R11)
   \   000016   6A43         MOV.B   #0x2, R10
    310          
    311              // TLV access Function Call
    312              Get_TLV_Info(TLV_DIERECORD, 0, (uint8_t *)&bBytes, (uint16_t **)&pbSerNum); //The die record used for serial number
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   0E41         MOV.W   SP, R14
   \   00001E   0E53         ADD.W   #0x0, R14
   \   000020   4D43         MOV.B   #0x0, R13
   \   000022   7C42         MOV.B   #0x8, R12
   \   000024   ........     CALLA   #Get_TLV_Info
    313              if (bBytes == 0)    // no serial number available
   \   000028   C1930000     CMP.B   #0x0, 0(SP)
   \   00002C   0720         JNE     ??USB_InitSerialStringDescriptor_5
    314              {
    315                  // use 00 as serial number = no serial number available
    316                  abramSerialStringDescriptor[0] = 4;      //length
   \   00002E   EB420000     MOV.B   #0x4, 0(R11)
    317                  abramSerialStringDescriptor[j++] = 0;    // no serial number available
   \   000032   CB430200     MOV.B   #0x0, 0x2(R11)
    318                  abramSerialStringDescriptor[j++] = 0;    // no serial number available
   \   000036   CB430300     MOV.B   #0x0, 0x3(R11)
   \   00003A   353C         JMP     ??USB_InitSerialStringDescriptor_6
    319              }
    320              else
    321              {
    322                  for(i=0; (i<bBytes)&&(i<8); i++,pbSerNum++)
   \                     ??USB_InitSerialStringDescriptor_5:
   \   00003C   4E43         MOV.B   #0x0, R14
    323                  {
    324                      hexValue = (*pbSerNum & 0xF0)>> 4;
   \                     ??USB_InitSerialStringDescriptor_0:
   \   00003E   3F010200     MOVA    0x2(SP), R15
   \   000042   6D4F         MOV.B   @R15, R13
   \   000044                RPT     #0x4
   \   000044   43194D10     RRUX.B  R13
    325                      if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
   \   000048   4F4A         MOV.B   R10, R15
   \   00004A   5F53         ADD.B   #0x1, R15
   \   00004C   ........     CALLA   #?Subroutine5
    326                      else abramSerialStringDescriptor[j++] = (hexValue + 55);
   \                     ??CrossCallReturnLabel_2:
   \   000050   ....CA4D.... MOVX.B  R13, abramSerialStringDescriptor(R10)
   \   000056   4A4F         MOV.B   R15, R10
    327                      abramSerialStringDescriptor[j++] = 0x00;  // needed for UNI-Code
   \   000058   ....CF43.... MOVX.B  #0x0, abramSerialStringDescriptor(R15)
   \   00005E   5A53         ADD.B   #0x1, R10
    328          
    329                      hexValue = (*pbSerNum & 0x0F);
   \   000060   3F010200     MOVA    0x2(SP), R15
   \   000064   7D400F00     MOV.B   #0xf, R13
   \   000068   6DFF         AND.B   @R15, R13
    330                      if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
   \   00006A   4C4A         MOV.B   R10, R12
   \   00006C   5C53         ADD.B   #0x1, R12
   \   00006E   4F4A         MOV.B   R10, R15
   \   000070   ........     CALLA   #?Subroutine5
    331                      else abramSerialStringDescriptor[j++] = (hexValue + 55);
   \                     ??CrossCallReturnLabel_3:
   \   000074   ....CF4D.... MOVX.B  R13, abramSerialStringDescriptor(R15)
   \   00007A   4A4C         MOV.B   R12, R10
    332                      abramSerialStringDescriptor[j++] = 0x00;    // needed for UNI-Code
   \   00007C   4F4A         MOV.B   R10, R15
   \   00007E   ....CF43.... MOVX.B  #0x0, abramSerialStringDescriptor(R15)
   \   000084   5A53         ADD.B   #0x1, R10
    333                  }
   \   000086   5E53         ADD.B   #0x1, R14
   \   000088   3F010200     MOVA    0x2(SP), R15
   \   00008C   AF000100     ADDA    #0x1, R15
   \   000090   710F0200     MOVA    R15, 0x2(SP)
   \   000094   6E91         CMP.B   @SP, R14
   \   000096   022C         JC      ??USB_InitSerialStringDescriptor_7
   \   000098   7E92         CMP.B   #0x8, R14
   \   00009A   D12B         JNC     ??USB_InitSerialStringDescriptor_0
    334                  abramSerialStringDescriptor[0] = i*4 +2;        // calculate the length
   \                     ??USB_InitSerialStringDescriptor_7:
   \   00009C                RPT     #0x2
   \   00009C   41184E5E     RLAX.B  R14
   \   0000A0   6E53         ADD.B   #0x2, R14
   \   0000A2   CB4E0000     MOV.B   R14, 0(R11)
    335              }
    336          }
   \                     ??USB_InitSerialStringDescriptor_6:
   \   0000A6   31500600     ADD.W   #0x6, SP
   \   0000AA   1A16         POPM.A  #0x2, R11
   \   0000AC   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   7D900A00     CMP.B   #0xa, R13
   \   000004   032C         JC      ??USB_InitSerialStringDescriptor_1
   \   000006   7D503000     ADD.B   #0x30, R13
   \   00000A   1001         RETA
   \                     ??USB_InitSerialStringDescriptor_1:
   \   00000C   7D503700     ADD.B   #0x37, R13
   \   000010   1001         RETA
    337          #endif
    338          
    339          //----------------------------------------------------------------------------
    340          

   \                                 In  segment CODE, align 2
    341          BYTE USB_enable()
   \                     USB_enable:
    342          {
   \   000000   2182         SUB.W   #0x4, SP
    343              volatile unsigned int i;
    344              volatile unsigned int j = 0;
   \   000002   81430200     MOV.W   #0x0, 0x2(SP)
    345          
    346              if (!(USBPWRCTL & USBBGVBV))            // check USB Bandgap and VBUS valid
   \   000006   B2B20809     BIT.W   #0x8, &0x908
   \   00000A   2B28         JNC     ??USB_enable_3
    347              {
    348                  return kUSB_generalError;
    349              }
    350          
    351              if ((USBCNF & USB_EN) &&
    352                  (USBPLLCTL & UPLLEN))
   \   00000C   92B30209     BIT.W   #0x1, &0x902
   \   000010   0428         JNC     ??USB_enable_4
   \   000012   B2B000011009 BIT.W   #0x100, &0x910
   \   000018   2D2C         JC      ??USB_enable_5
    353              {
    354                  return kUSB_succeed;                // exit if PLL is already enalbed
    355              }
    356          
    357              USBKEYPID = 0x9628;                     // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \                     ??USB_enable_4:
   \   00001A   ........     CALLA   #?Subroutine6
    358              XT2_Start(XT2DRIVE_3);
   \                     ??CrossCallReturnLabel_4:
   \   00001E   3C4000C0     MOV.W   #0xc000, R12
   \   000022   ........     CALLA   #XT2_Start
    359              USBPLLDIVB = USB_XT_FREQ;               // Settings desired frequency
   \   000026   B24017011209 MOV.W   #0x117, &0x912
    360          
    361              if (USB_PLL_XT == 2)
    362              {
    363                  USBPLLCTL = UPCS0 + UPFDEN + UPLLEN;// Select XT2 as Ref / Select PLL for USB / Discrim. on, enable PLL
   \   00002C   B24000131009 MOV.W   #0x1300, &0x910
    364              }
    365              else
    366              {
    367                  USBPLLCTL = UPFDEN + UPLLEN;        // Select XT1 as Ref / Select PLL for USB / Discrim. on, enable PLL
    368              }
    369          
    370              //Wait some time till PLL is settled
    371              do
    372              {
    373                  USBPLLIR    =     0x0000;           // make sure no interrupts can occur on PLL-module
   \                     ??USB_enable_1:
   \   000032   82431409     MOV.W   #0x0, &0x914
    374          
    375          #ifdef __MSP430F6638
    376                  //wait 1 ms till enable USB
    377                  for (i =0; i < USB_MCLK_FREQ/1000*1/10; i++);
    378          #else
    379                  //wait 1/2 ms till enable USB
    380                  for (i =0; i < USB_MCLK_FREQ/1000* 1/2 /10; i++);
   \   000036   81430000     MOV.W   #0x0, 0(SP)
   \   00003A   043C         JMP     ??USB_enable_6
   \                     ??USB_enable_0:
   \   00003C   2F41         MOV.W   @SP, R15
   \   00003E   1F53         ADD.W   #0x1, R15
   \   000040   814F0000     MOV.W   R15, 0(SP)
   \                     ??USB_enable_6:
   \   000044   B190E2040000 CMP.W   #0x4e2, 0(SP)
   \   00004A   F82B         JNC     ??USB_enable_0
    381          #endif
    382          
    383                  if (j++ > 10)
   \   00004C   1F410200     MOV.W   0x2(SP), R15
   \   000050   0E4F         MOV.W   R15, R14
   \   000052   1E53         ADD.W   #0x1, R14
   \   000054   814E0200     MOV.W   R14, 0x2(SP)
   \   000058   3F900B00     CMP.W   #0xb, R15
   \   00005C   0428         JNC     ??USB_enable_7
    384                  {
    385                      USBKEYPID   =    0x9600;        // access to configuration registers disabled
   \   00005E   ........     CALLA   #?Subroutine7
    386                      return kUSB_generalError;
   \                     ??USB_enable_3:
   \   000062   5C43         MOV.B   #0x1, R12
   \   000064   083C         JMP     ??USB_enable_8
    387                  }
    388              }while (USBPLLIR != 0);
   \                     ??USB_enable_7:
   \   000066   82931409     CMP.W   #0x0, &0x914
   \   00006A   E323         JNE     ??USB_enable_1
    389          
    390              USBCNF     |=    USB_EN;                // enable USB module
   \   00006C   92D30209     BIS.W   #0x1, &0x902
    391              USBKEYPID   =    0x9600;                // access to configuration registers disabled
   \   000070   ........     CALLA   #?Subroutine7
    392              return kUSB_succeed;
   \                     ??USB_enable_5:
   \   000074   4C43         MOV.B   #0x0, R12
   \                     ??USB_enable_8:
   \   000076   2152         ADD.W   #0x4, SP
   \   000078   1001         RETA
   \   00007A                REQUIRE _A_USBPWRCTL_L
   \   00007A                REQUIRE _A_USBCNF_L
   \   00007A                REQUIRE _A_USBPLLCTL_L
   \   00007A                REQUIRE _A_USBKEYID_L
   \   00007A                REQUIRE _A_USBPLLDIVB_L
   \   00007A                REQUIRE _A_USBPLLIR_L
    393          }
    394          
    395          /*
    396          Disables the USB module and PLL.
    397          */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_15:
   \   000004   ....C243.... MOVX.B  #0x0, &bEnumerationStatus
   \   00000A                REQUIRE ??Subroutine9_0
   \   00000A                // Fall through to label ??Subroutine9_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine9_0:
   \   000000   ....C243.... MOVX.B  #0x0, &bFunctionSuspended
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    398          BYTE USB_disable(VOID)
   \                     USB_disable:
    399          {
    400              USBKEYPID = 0x9628;        // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   000000   ........     CALLA   #?Subroutine6
    401              USBCNF    = 0;             // disable USB module
   \                     ??CrossCallReturnLabel_9:
   \   000004   82430209     MOV.W   #0x0, &0x902
    402              USBPLLCTL &= ~UPLLEN;      // disable PLL
   \   000008   B2C000011009 BIC.W   #0x100, &0x910
    403              USBKEYPID = 0x9600;        // access to configuration registers disabled
   \   00000E   ....         JMP     ?Subroutine0
   \   000010   0343         NOP
   \   000012                REQUIRE _A_USBKEYID_L
   \   000012                REQUIRE _A_USBCNF_L
   \   000012                REQUIRE _A_USBPLLCTL_L
    404              bEnumerationStatus = 0x00; // device is not enumerated
    405              bFunctionSuspended = FALSE;// device is not suspended
    406              return kUSB_succeed;
    407          }
    408          
    409          /*
    410          Enables/disables various USB events.
    411          */

   \                                 In  segment CODE, align 2, keep-with-next
    412          BYTE USB_setEnabledEvents(WORD events)
   \                     USB_setEnabledEvents:
    413          {
    414              wUsbEventMask = events;
   \   000000   ....824C.... MOVX.W  R12, &wUsbEventMask
    415              return kUSB_succeed;
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   1001         RETA
    416          }
    417          
    418          /*
    419          Returns which events are enabled and which are disabled.
    420          */

   \                                 In  segment CODE, align 2, keep-with-next
    421          WORD USB_getEnabledEvents()
   \                     USB_getEnabledEvents:
    422          {
    423              return wUsbEventMask;
   \   000000   ....1C42.... MOVX.W  &wUsbEventMask, R12
   \   000006   1001         RETA
    424          }
    425          
    426          /*
    427          Reset USB-SIE and global variables.
    428          */

   \                                 In  segment CODE, align 2, keep-with-next
    429          BYTE USB_reset()
   \                     USB_reset:
    430          {
   \   000000   1B14         PUSHM.A #0x2, R11
    431              int i;
    432              USBKEYPID = 0x9628;                   // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   000002   ........     CALLA   #?Subroutine6
    433          
    434              //reset should be on the bus after this!
    435              bEnumerationStatus = 0x00;            // Device not enumerated yet
   \                     ??CrossCallReturnLabel_8:
   \   000006   ....C243.... MOVX.B  #0x0, &bEnumerationStatus
    436              bFunctionSuspended = FALSE;           // Device is not in suspend mode
   \   00000C   ....C243.... MOVX.B  #0x0, &bFunctionSuspended
    437          
    438              bRemoteWakeup = DISABLE;
   \   000012   ....C243.... MOVX.B  #0x0, &bRemoteWakeup
    439          
    440              bConfigurationNumber    = 0x00;       // device unconfigured
   \   000018   ....C243.... MOVX.B  #0x0, &bConfigurationNumber
    441              bInterfaceNumber        = 0x00;
   \   00001E   ....C243.... MOVX.B  #0x0, &bInterfaceNumber
    442          
    443              // FRSTE handling:
    444              // Clear FRSTE in the RESRIFG interrupt service routine before re-configuring USB control registers.
    445              // Set FRSTE at the beginning of SUSRIFG, SETUP, IEPIFG.EP0 and OEPIFG.EP0 interrupt service routines.
    446              USBCTL = 0;                           // Function Reset Connection disable (FRSTE)
   \   000024   C2433C09     MOV.B   #0x0, &0x93c
    447          
    448              wBytesRemainingOnIEP0   = NO_MORE_DATA;
   \   000028   ....B243.... MOVX.W  #0xffff, &wBytesRemainingOnIEP0
    449              wBytesRemainingOnOEP0   = NO_MORE_DATA;
   \   00002E   ....B243.... MOVX.W  #0xffff, &wBytesRemainingOnOEP0
    450              bStatusAction           = STATUS_ACTION_NOTHING;
   \   000034   ....C243.... MOVX.B  #0x0, &bStatusAction
    451          
    452              //The address reset normally will be done automatically during bus function reset
    453              USBFUNADR   =     0x00;               // reset address of USB device (unconfigured)
   \   00003A   C2433F09     MOV.B   #0x0, &0x93f
    454          
    455              /* Set settings for EP0 */
    456              // NAK both 0 endpoints and enable endpoint 0 interrupt
    457              tEndPoint0DescriptorBlock.bIEPBCNT = EPBCNT_NAK;
   \   00003E   7F408000     MOV.B   #0x80, R15
   \   000042   C24F2109     MOV.B   R15, &0x921
    458              tEndPoint0DescriptorBlock.bOEPBCNT = EPBCNT_NAK;
   \   000046   C24F2309     MOV.B   R15, &0x923
    459              tEndPoint0DescriptorBlock.bIEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
   \   00004A   F2408C002009 MOV.B   #0x8c, &0x920
    460              tEndPoint0DescriptorBlock.bOEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
   \   000050   F2408C002209 MOV.B   #0x8c, &0x922
    461          
    462              USBOEPIE = USB_OUTEP_INT_EN;
   \   000056   F2401B002F09 MOV.B   #0x1b, &0x92f
    463              USBIEPIE = USB_INEP_INT_EN;
   \   00005C   F2401F002E09 MOV.B   #0x1f, &0x92e
    464          
    465              // loop for initialization all of used enpoints
    466              for(i=0; i < (CDC_NUM_INTERFACES + HID_NUM_INTERFACES + MSC_NUM_INTERFACES); i++)
   \   000062   ........     MOVA    #stUsbHandle + 4, R13
   \   000066   7A404000     MOV.B   #0x40, R10
   \   00006A   3B4000E4     MOV.W   #0xe400, R11
    467              {
    468                  BYTE edbIndex = stUsbHandle[i].edb_Index;
   \                     ??USB_reset_0:
   \   00006E   5C4DFEFF     MOV.B   -0x2(R13), R12
    469          
    470                  /* Set settings for IEPx */
    471                  tInputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
   \   000072   5C0A         RLAM.W  #0x3, R12
   \   000074   FC409400C823 MOV.B   #0x94, 0x23c8(R12)
    472                  tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].iep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   00007A   0E4B         MOV.W   R11, R14
   \   00007C   1E5D0800     ADD.W   0x8(R13), R14
   \   000080   5E0B         RRUM.W  #0x3, R14
   \   000082   CC4EC923     MOV.B   R14, 0x23c9(R12)
    473                  tInputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].iep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   000086   0E4B         MOV.W   R11, R14
   \   000088   1E5D0A00     ADD.W   0xa(R13), R14
   \   00008C   5E0B         RRUM.W  #0x3, R14
   \   00008E   CC4ECD23     MOV.B   R14, 0x23cd(R12)
    474                  tInputEndPointDescriptorBlock[edbIndex].bEPBCTX  = EPBCNT_NAK;
   \   000092   CC4FCA23     MOV.B   R15, 0x23ca(R12)
    475                  tInputEndPointDescriptorBlock[edbIndex].bEPBCTY  = EPBCNT_NAK;
   \   000096   CC4FCE23     MOV.B   R15, 0x23ce(R12)
    476                  tInputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
   \   00009A   CC4ACF23     MOV.B   R10, 0x23cf(R12)
    477          
    478                  /* Set settings for OEPx */
    479                  tOutputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF ; //double buffering
   \   00009E   FC4094008823 MOV.B   #0x94, 0x2388(R12)
    480                  tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].oep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   0000A4   0E4B         MOV.W   R11, R14
   \   0000A6   1E5D0400     ADD.W   0x4(R13), R14
   \   0000AA   5E0B         RRUM.W  #0x3, R14
   \   0000AC   CC4E8923     MOV.B   R14, 0x2389(R12)
    481                  tOutputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].oep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   0000B0   0E4B         MOV.W   R11, R14
   \   0000B2   1E5D0600     ADD.W   0x6(R13), R14
   \   0000B6   5E0B         RRUM.W  #0x3, R14
   \   0000B8   CC4E8D23     MOV.B   R14, 0x238d(R12)
    482                  tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX  = 0x00;
   \   0000BC   CC438A23     MOV.B   #0x0, 0x238a(R12)
    483                  tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY  = 0x00;
   \   0000C0   CC438E23     MOV.B   #0x0, 0x238e(R12)
    484                  tOutputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
   \   0000C4   CC4A8F23     MOV.B   R10, 0x238f(R12)
    485          
    486          #       ifdef _CDC_
    487                  /* Additional interrupt end point for CDC */
    488                  if(stUsbHandle[i].dev_Class == CDC_CLASS)
   \   0000C8   ED93FFFF     CMP.B   #0x2, -0x1(R13)
   \   0000CC   1420         JNE     ??USB_reset_1
    489                  {
    490                      // The decriptor tool always generates the managemnet endpoint before the data endpoint
    491                      tInputEndPointDescriptorBlock[edbIndex-1].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
   \   0000CE   FC409400C023 MOV.B   #0x94, 0x23c0(R12)
    492                      tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAX  = (BYTE)(((stUsbHandle[i].intepEP_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   0000D4   0E4B         MOV.W   R11, R14
   \   0000D6   2E5D         ADD.W   @R13, R14
   \   0000D8   5E0B         RRUM.W  #0x3, R14
   \   0000DA   CC4EC123     MOV.B   R14, 0x23c1(R12)
    493                      tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAY  = (BYTE)(((stUsbHandle[i].intepEP_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
   \   0000DE   0E4B         MOV.W   R11, R14
   \   0000E0   1E5D0200     ADD.W   0x2(R13), R14
   \   0000E4   5E0B         RRUM.W  #0x3, R14
   \   0000E6   CC4EC523     MOV.B   R14, 0x23c5(R12)
    494                      tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTX  = EPBCNT_NAK;
   \   0000EA   CC4FC223     MOV.B   R15, 0x23c2(R12)
    495                      tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTY  = EPBCNT_NAK;
   \   0000EE   CC4FC623     MOV.B   R15, 0x23c6(R12)
    496                      tInputEndPointDescriptorBlock[edbIndex-1].bEPSIZXY = MAX_PACKET_SIZE;
   \   0000F2   CC4AC723     MOV.B   R10, 0x23c7(R12)
    497                  }
    498          #       endif
    499              }
   \                     ??USB_reset_1:
   \   0000F6   AD001000     ADDA    #0x10, R13
   \   0000FA   ........     CMPA    #stUsbHandle + 52, R13
   \   0000FE   B723         JNE     ??USB_reset_0
    500          
    501          #   ifdef _HID_
    502                  HidResetData();                     // reset HID specific data structures
   \   000100   ........     CALLA   #HidResetData
    503          #   endif // _HID_
    504          
    505          #   ifdef _MSC_
    506                  isMSCConfigured = FALSE;
   \   000104   ....8243.... MOVX.W  #0x0, &isMSCConfigured
    507                  MscResetData();
   \   00010A   ........     CALLA   #MscResetData
    508          #   endif
    509          
    510          #   ifdef _CDC_
    511                  CdcResetData();                     // reset CDC specific data structures
   \   00010E   ........     CALLA   #CdcResetData
    512          #   endif // _CDC_
    513          
    514              USBCTL = FEN;                       // enable function
   \   000112   C24A3C09     MOV.B   R10, &0x93c
    515              USBIFG = 0;                         // make sure no interrupts are pending
   \   000116   C2433E09     MOV.B   #0x0, &0x93e
    516          
    517              USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
   \   00011A   F240C4003D09 MOV.B   #0xc4, &0x93d
    518              USBKEYPID = 0x9600;                 // access to configuration registers disabled
   \   000120   ........     CALLA   #?Subroutine7
    519              return kUSB_succeed;
   \                     ??CrossCallReturnLabel_13:
   \   000124   4C43         MOV.B   #0x0, R12
   \   000126   1A16         POPM.A  #0x2, R11
   \   000128   1001         RETA
   \   00012A                REQUIRE _A_USBKEYID_L
   \   00012A                REQUIRE USBCTL
   \   00012A                REQUIRE USBFUNADR
   \   00012A                REQUIRE tEndPoint0DescriptorBlock
   \   00012A                REQUIRE USBOEPIE
   \   00012A                REQUIRE USBIEPIE
   \   00012A                REQUIRE tInputEndPointDescriptorBlock
   \   00012A                REQUIRE tOutputEndPointDescriptorBlock
   \   00012A                REQUIRE USBIFG
   \   00012A                REQUIRE USBIE
    520          }
    521          
    522          /*
    523          Instruct USB module to make itself available to the PC for connection, by pulling PUR high.
    524          */

   \                                 In  segment CODE, align 2, keep-with-next
    525          BYTE USB_connect()
   \                     USB_connect:
    526          {
    527              USBKEYPID = 0x9628;   // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   000000   ........     CALLA   #?Subroutine6
    528              USBCNF |= PUR_EN;     // generate rising edge on DP -> the host enumerates our device as full speed device
   \                     ??CrossCallReturnLabel_7:
   \   000004   A2D30209     BIS.W   #0x2, &0x902
    529              USBPWRCTL |= VBOFFIE; // enable interrupt VUSBoff
   \   000008   B2D000040809 BIS.W   #0x400, &0x908
    530              USBKEYPID = 0x9600;   // access to configuration registers disabled
   \   00000E   ........     CALLA   #?Subroutine7
    531          
    532              // after this the enumeration may take place
    533              __no_operation();
   \                     ??CrossCallReturnLabel_12:
   \   000012   0343         NOP
    534              __no_operation();
   \   000014   0343         NOP
    535              __no_operation();
   \   000016   0343         NOP
    536              __no_operation();
   \   000018   0343         NOP
    537              __no_operation();
   \   00001A   0343         NOP
    538              __no_operation();
   \   00001C   0343         NOP
    539              __no_operation();
   \   00001E   0343         NOP
    540          
    541              return kUSB_succeed;
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   1001         RETA
   \   000024                REQUIRE _A_USBKEYID_L
   \   000024                REQUIRE _A_USBCNF_L
   \   000024                REQUIRE _A_USBPWRCTL_L
    542          }
    543          
    544          /*
    545          Force a disconnect from the PC by pulling PUR low.
    546          */

   \                                 In  segment CODE, align 2, keep-with-next
    547          BYTE USB_disconnect()
   \                     USB_disconnect:
    548          {
    549              USBKEYPID = 0x9628;     // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   000000   ........     CALLA   #?Subroutine6
    550              USBCNF &= ~PUR_EN;      // disconnect pull up resistor - logical disconnect from HOST
   \                     ??CrossCallReturnLabel_6:
   \   000004   A2C30209     BIC.W   #0x2, &0x902
    551              USBPWRCTL &= ~VBOFFIE;  // disable interrupt VUSBoff
   \   000008   B2C000040809 BIC.W   #0x400, &0x908
    552              USBKEYPID = 0x9600;     // access to configuration registers disabled
   \   00000E                REQUIRE ?Subroutine0
   \   00000E                REQUIRE _A_USBKEYID_L
   \   00000E                REQUIRE _A_USBCNF_L
   \   00000E                REQUIRE _A_USBPWRCTL_L
   \   00000E                // Fall through to label ?Subroutine0
    553              bEnumerationStatus = 0; // not enumerated
    554              bFunctionSuspended = FALSE;     // device is not suspended
    555              return kUSB_succeed;
    556          }
    557          
    558          /*
    559          Force a remote wakeup of the USB host.
    560          */

   \                                 In  segment CODE, align 2, keep-with-next
    561          BYTE USB_forceRemoteWakeup()
   \                     USB_forceRemoteWakeup:
    562          {
    563              if (bFunctionSuspended == FALSE) // device is not suspended
   \   000000   ....C293.... CMPX.B  #0x0, &bFunctionSuspended
   \   000006   0320         JNE     ??USB_forceRemoteWakeup_0
    564              {
    565                  return kUSB_NotSuspended;
   \   000008   7C401000     MOV.B   #0x10, R12
   \   00000C   1001         RETA
    566              }
    567              if(bRemoteWakeup == ENABLE)
   \                     ??USB_forceRemoteWakeup_0:
   \   00000E   ....D293.... CMPX.B  #0x1, &bRemoteWakeup
   \   000014   0520         JNE     ??USB_forceRemoteWakeup_1
    568              {
    569              	volatile unsigned int i;
    570                  USBCTL |= RWUP;             // USB - Device Remote Wakeup Request - this bit is self-cleaned
   \   000016   F2D020003C09 BIS.B   #0x20, &0x93c
    571                  return kUSB_succeed;
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   1001         RETA
    572              }
    573              return kUSB_generalError;
   \                     ??USB_forceRemoteWakeup_1:
   \   000020   5C43         MOV.B   #0x1, R12
   \   000022   1001         RETA
   \   000024                REQUIRE USBCTL
    574          }
    575          
    576          /*
    577          Returns the status of the USB connection.
    578          */

   \                                 In  segment CODE, align 2, keep-with-next
    579          BYTE USB_connectionInfo()
   \                     USB_connectionInfo:
    580          {
    581              BYTE retVal = 0;
   \   000000   4C43         MOV.B   #0x0, R12
    582              if (USBPWRCTL & USBBGVBV)
   \   000002   B2B20809     BIT.W   #0x8, &0x908
   \   000006   0128         JNC     ??USB_connectionInfo_0
    583              {
    584                  retVal |= kUSB_vbusPresent;
   \   000008   5C43         MOV.B   #0x1, R12
    585              }
    586          
    587              if (bEnumerationStatus == ENUMERATION_COMPLETE)
   \                     ??USB_connectionInfo_0:
   \   00000A   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_20:
   \   00000E   0220         JNE     ??USB_connectionInfo_1
    588              {
    589                  retVal |= kUSB_Enumerated;
   \   000010   7CD02000     BIS.B   #0x20, R12
    590              }
    591          
    592              if (USBCNF & PUR_EN)
   \                     ??USB_connectionInfo_1:
   \   000014   A2B30209     BIT.W   #0x2, &0x902
   \   000018   0228         JNC     ??USB_connectionInfo_2
    593              {
    594                  retVal |= kUSB_purHigh;
   \   00001A   7CD04000     BIS.B   #0x40, R12
    595              }
    596          
    597              if (bFunctionSuspended == TRUE)
   \                     ??USB_connectionInfo_2:
   \   00001E   ....D293.... CMPX.B  #0x1, &bFunctionSuspended
   \   000024   0220         JNE     ??USB_connectionInfo_3
    598              {
    599                  retVal |= kUSB_suspended;
   \   000026   7CD2         BIS.B   #0x8, R12
   \   000028   1001         RETA
    600              }
    601              else
    602              {
    603                  retVal |= kUSB_NotSuspended;
   \                     ??USB_connectionInfo_3:
   \   00002A   7CD01000     BIS.B   #0x10, R12
    604              }
    605              return retVal;
   \   00002E   1001         RETA
   \   000030                REQUIRE _A_USBPWRCTL_L
   \   000030                REQUIRE _A_USBCNF_L
    606          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   ....D293.... CMPX.B  #0x1, &bEnumerationStatus
   \   000006   1001         RETA
    607          
    608          /*
    609          Returns the state of the USB connection.
    610          */

   \                                 In  segment CODE, align 2, keep-with-next
    611          BYTE USB_connectionState()
   \                     USB_connectionState:
    612          {
    613              // If no VBUS present
    614              if (!(USBPWRCTL & USBBGVBV))
   \   000000   B2B20809     BIT.W   #0x8, &0x908
   \   000004   032C         JC      ??USB_connectionState_0
    615              {
    616                  return ST_USB_DISCONNECTED;
   \   000006   7C408000     MOV.B   #0x80, R12
   \   00000A   1001         RETA
    617              }
    618          
    619              // If VBUS present, but PUR is low
    620              if ((USBPWRCTL & USBBGVBV)&&(!(USBCNF & PUR_EN)))
   \                     ??USB_connectionState_0:
   \   00000C   B2B20809     BIT.W   #0x8, &0x908
   \   000010   0628         JNC     ??USB_connectionState_1
   \   000012   A2B30209     BIT.W   #0x2, &0x902
   \   000016   032C         JC      ??USB_connectionState_1
    621              {
    622                  return ST_USB_CONNECTED_NO_ENUM;
   \   000018   7C408100     MOV.B   #0x81, R12
   \   00001C   1001         RETA
    623              }
    624          
    625              // If VBUS present, PUR is high, and enumeration is complete, and not suspended
    626              if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    627                  && (bEnumerationStatus == ENUMERATION_COMPLETE)
    628                  && (!(bFunctionSuspended == TRUE)))
   \                     ??USB_connectionState_1:
   \   00001E   B2B20809     BIT.W   #0x8, &0x908
   \   000022   0D28         JNC     ??USB_connectionState_2
   \   000024   A2B30209     BIT.W   #0x2, &0x902
   \   000028   0A28         JNC     ??USB_connectionState_2
   \   00002A   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_16:
   \   00002E   0720         JNE     ??USB_connectionState_2
   \   000030   ....D293.... CMPX.B  #0x1, &bFunctionSuspended
   \   000036   0324         JEQ     ??USB_connectionState_2
    629              {
    630                  return ST_ENUM_ACTIVE;
   \   000038   7C408300     MOV.B   #0x83, R12
   \   00003C   1001         RETA
    631              }
    632          
    633              // If VBUS present, PUR is high, and enumeration is NOT complete, and  suspended
    634              if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    635                  && (!(bEnumerationStatus == ENUMERATION_COMPLETE))
    636                  && (bFunctionSuspended == TRUE))
   \                     ??USB_connectionState_2:
   \   00003E   B2B20809     BIT.W   #0x8, &0x908
   \   000042   0D28         JNC     ??USB_connectionState_3
   \   000044   A2B30209     BIT.W   #0x2, &0x902
   \   000048   0A28         JNC     ??USB_connectionState_3
   \   00004A   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_17:
   \   00004E   0724         JEQ     ??USB_connectionState_3
   \   000050   ....D293.... CMPX.B  #0x1, &bFunctionSuspended
   \   000056   0320         JNE     ??USB_connectionState_3
    637              {
    638                  return ST_NOENUM_SUSPENDED;
   \   000058   7C408700     MOV.B   #0x87, R12
   \   00005C   1001         RETA
    639              }
    640          
    641              // If VBUS present, PUR is high, and enumeration is complete, and  suspended
    642              if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    643                  && (bEnumerationStatus == ENUMERATION_COMPLETE)
    644                  && (bFunctionSuspended == TRUE))
   \                     ??USB_connectionState_3:
   \   00005E   B2B20809     BIT.W   #0x8, &0x908
   \   000062   0D28         JNC     ??USB_connectionState_4
   \   000064   A2B30209     BIT.W   #0x2, &0x902
   \   000068   0A28         JNC     ??USB_connectionState_4
   \   00006A   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_18:
   \   00006E   0720         JNE     ??USB_connectionState_4
   \   000070   ....D293.... CMPX.B  #0x1, &bFunctionSuspended
   \   000076   0320         JNE     ??USB_connectionState_4
    645              {
    646                  return ST_ENUM_SUSPENDED;
   \   000078   7C408400     MOV.B   #0x84, R12
   \   00007C   1001         RETA
    647              }
    648          
    649              // If VBUS present, PUR is high, but no enumeration yet
    650              if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
    651                  && (!(bEnumerationStatus == ENUMERATION_COMPLETE)))
   \                     ??USB_connectionState_4:
   \   00007E   B2B20809     BIT.W   #0x8, &0x908
   \   000082   0928         JNC     ??USB_connectionState_5
   \   000084   A2B30209     BIT.W   #0x2, &0x902
   \   000088   0628         JNC     ??USB_connectionState_5
   \   00008A   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_19:
   \   00008E   0324         JEQ     ??USB_connectionState_5
    652              {
    653                  return ST_ENUM_IN_PROGRESS;
   \   000090   7C408200     MOV.B   #0x82, R12
   \   000094   1001         RETA
    654              }
    655          
    656              return ST_ERROR;
   \                     ??USB_connectionState_5:
   \   000096   7C408600     MOV.B   #0x86, R12
   \   00009A   1001         RETA
   \   00009C                REQUIRE _A_USBPWRCTL_L
   \   00009C                REQUIRE _A_USBCNF_L
    657          }
    658          
    659          //----------------------------------------------------------------------------
    660          

   \                                 In  segment CODE, align 2, keep-with-next
    661          BYTE USB_suspend(VOID)
   \                     USB_suspend:
    662          {
    663          
    664              bFunctionSuspended  = TRUE;
   \   000000   ....D243.... MOVX.B  #0x1, &bFunctionSuspended
    665              USBKEYPID = 0x9628;         // set KEY and PID to 0x9628 -> access to configuration registers enabled
   \   000006   ........     CALLA   #?Subroutine6
    666              USBCTL |= FRSTE;            // Function Reset Connection Enable
   \                     ??CrossCallReturnLabel_5:
   \   00000A   F2D010003C09 BIS.B   #0x10, &0x93c
    667              USBIFG &= ~SUSRIFG;         // clear interrupt flag
   \   000010   F2C040003E09 BIC.B   #0x40, &0x93e
    668          
    669              if(USB_DISABLE_XT_SUSPEND)
    670              {
    671                  if (USB_PLL_XT == 2)
    672                  {
    673                      USBPLLCTL &= ~UPLLEN;         // disable PLL
   \   000016   B2C000011009 BIC.W   #0x100, &0x910
    674                      UCSCTL6   |= XT2OFF;         // disable XT2
   \   00001C   B2D000016C01 BIS.W   #0x100, &0x16c
    675                  }
    676                  else
    677                  {
    678                      USBPLLCTL &= ~UPLLEN;           // disable PLL
    679                      UCSCTL6 |= XT1OFF;
    680                  }
    681              }
    682          
    683              USBIE = RESRIE;             // disable USB specific interrupts (setup, suspend, reset), enable resume.
   \   000022   F24020003D09 MOV.B   #0x20, &0x93d
    684                                          // If the reset occured during device in suspend, the resume-interrupt will come, after - reset interrupt
    685              USBKEYPID = 0x9600;         // access to configuration registers disabled
   \   000028   ........     CALLA   #?Subroutine7
    686          
    687              return kUSB_succeed;
   \                     ??CrossCallReturnLabel_11:
   \   00002C   4C43         MOV.B   #0x0, R12
   \   00002E   1001         RETA
   \   000030                REQUIRE _A_USBKEYID_L
   \   000030                REQUIRE USBCTL
   \   000030                REQUIRE USBIFG
   \   000030                REQUIRE _A_USBPLLCTL_L
   \   000030                REQUIRE _A_UCSCTL6_L
   \   000030                REQUIRE USBIE
    688          }
    689          
    690          //----------------------------------------------------------------------------
    691          

   \                                 In  segment CODE, align 2, keep-with-next
    692          BYTE USB_resume(VOID)
   \                     USB_resume:
    693          {
    694              USB_enable();                       // enable PLL
   \   000000   ........     CALLA   #USB_enable
    695          
    696              USBIFG &= ~(RESRIFG | SUSRIFG);     // clear interrupt flags
   \   000004   F2F09F003E09 AND.B   #0x9f, &0x93e
    697              USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
   \   00000A   F240C4003D09 MOV.B   #0xc4, &0x93d
    698          
    699              bFunctionSuspended  = FALSE;
   \   000010   ....         JMP     ??Subroutine9_0
   \   000012   0343         NOP
   \   000014                REQUIRE USBIFG
   \   000014                REQUIRE USBIE
    700              return kUSB_succeed;
    701          }
    702          
    703          //----------------------------------------------------------------------------
    704          

   \                                 In  segment CODE, align 2, keep-with-next
    705          VOID usbStallEndpoint0(VOID)
   \                     usbStallEndpoint0:
    706          {
    707              tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
   \   000000   F2D22009     BIS.B   #0x8, &0x920
    708              tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
   \   000004                REQUIRE ?Subroutine1
   \   000004                REQUIRE tEndPoint0DescriptorBlock
   \   000004                // Fall through to label ?Subroutine1
    709          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   F2D22209     BIS.B   #0x8, &0x922
   \   000004   1001         RETA
    710          
    711          //----------------------------------------------------------------------------
    712          

   \                                 In  segment CODE, align 2, keep-with-next
    713          VOID usbClearOEP0ByteCount(VOID)
   \                     usbClearOEP0ByteCount:
    714          {
    715              tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
   \   000000                REQUIRE ?Subroutine2
   \   000000                REQUIRE tEndPoint0DescriptorBlock
   \   000000                // Fall through to label ?Subroutine2

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   C2432309     MOV.B   #0x0, &0x923
    716          }
   \   000004   1001         RETA
    717          
    718          //----------------------------------------------------------------------------
    719          

   \                                 In  segment CODE, align 2
    720          VOID usbStallOEP0(VOID)
   \                     usbStallOEP0:
    721          {
    722              // in standard USB request, there is not control write request with data stage
    723              // control write, stall output endpoint 0
    724              // wLength should be 0 in all cases
    725              tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
   \   000000   ....         JMP     ?Subroutine1
   \   000002   0343         NOP
   \   000004                REQUIRE tEndPoint0DescriptorBlock
    726          }
    727          
    728          //----------------------------------------------------------------------------
    729          

   \                                 In  segment CODE, align 2
    730          VOID usbSendNextPacketOnIEP0(VOID)
   \                     usbSendNextPacketOnIEP0:
    731          {
    732              BYTE bPacketSize,bIndex;
    733          
    734              // First check if there are bytes remaining to be transferred
    735              if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
   \   000000   ........     MOVA    &pbIEP0Buffer, R14
   \   000004   ....1F42.... MOVX.W  &wBytesRemainingOnIEP0, R15
   \   00000A   3F93         CMP.W   #0xffff, R15
   \   00000C   2724         JEQ     ??usbSendNextPacketOnIEP0_2
    736              {
    737                  if(wBytesRemainingOnIEP0 > EP0_PACKET_SIZE)
   \   00000E   3F900900     CMP.W   #0x9, R15
   \   000012   0328         JNC     ??usbSendNextPacketOnIEP0_3
    738                  {
    739                      // More bytes are remaining than will fit in one packet
    740                      // there will be More IN Stage
    741                      bPacketSize = EP0_PACKET_SIZE;
   \   000014   7D42         MOV.B   #0x8, R13
    742                      wBytesRemainingOnIEP0 -= EP0_PACKET_SIZE;
   \   000016   3F82         SUB.W   #0x8, R15
    743                      bStatusAction = STATUS_ACTION_DATA_IN;
   \   000018   0A3C         JMP     ??usbSendNextPacketOnIEP0_4
    744                  }
    745                  else if (wBytesRemainingOnIEP0 < EP0_PACKET_SIZE)
   \                     ??usbSendNextPacketOnIEP0_3:
   \   00001A   3F92         CMP.W   #0x8, R15
   \   00001C   022C         JC      ??usbSendNextPacketOnIEP0_5
    746                  {
    747                      // The remaining data will fit in one packet.
    748                      // This case will properly handle wBytesRemainingOnIEP0 == 0
    749                      bPacketSize = (BYTE)wBytesRemainingOnIEP0;
   \   00001E   4D4F         MOV.B   R15, R13
    750                      wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
   \   000020   083C         JMP     ??usbSendNextPacketOnIEP0_1
    751                      bStatusAction = STATUS_ACTION_NOTHING;
    752                  }
    753                  else
    754                  {
    755                      bPacketSize = EP0_PACKET_SIZE;
   \                     ??usbSendNextPacketOnIEP0_5:
   \   000022   7D42         MOV.B   #0x8, R13
    756                      if(bHostAskMoreDataThanAvailable == TRUE)
   \   000024   ....D293.... CMPX.B  #0x1, &bHostAskMoreDataThanAvailable
   \   00002A   0320         JNE     ??usbSendNextPacketOnIEP0_1
    757                      {
    758                          wBytesRemainingOnIEP0 = 0;
   \   00002C   0F43         MOV.W   #0x0, R15
    759                          bStatusAction = STATUS_ACTION_DATA_IN;
   \                     ??usbSendNextPacketOnIEP0_4:
   \   00002E   5C43         MOV.B   #0x1, R12
   \   000030   023C         JMP     ??usbSendNextPacketOnIEP0_6
    760                      }
    761                      else
    762                      {
    763                          wBytesRemainingOnIEP0 = NO_MORE_DATA;
   \                     ??usbSendNextPacketOnIEP0_1:
   \   000032   3F43         MOV.W   #0xffff, R15
    764                          bStatusAction = STATUS_ACTION_NOTHING;
   \   000034   4C43         MOV.B   #0x0, R12
   \                     ??usbSendNextPacketOnIEP0_6:
   \   000036   ....C24C.... MOVX.B  R12, &bStatusAction
   \   00003C   ....824F.... MOVX.W  R15, &wBytesRemainingOnIEP0
    765                      }
    766                  }
    767          
    768                  for(bIndex=0; bIndex<bPacketSize; bIndex++)
   \   000042   4D93         CMP.B   #0x0, R13
   \   000044   0824         JEQ     ??usbSendNextPacketOnIEP0_7
   \   000046   3F407823     MOV.W   #0x2378, R15
   \   00004A   4C4D         MOV.B   R13, R12
    769                  {
    770                      abIEP0Buffer[bIndex] = *pbIEP0Buffer;
   \                     ??usbSendNextPacketOnIEP0_0:
   \   00004C   FF4E0000     MOV.B   @R14+, 0(R15)
    771                      pbIEP0Buffer++;
    772                  }
   \   000050   1F53         ADD.W   #0x1, R15
   \   000052   7C53         ADD.B   #0xff, R12
   \   000054   FB23         JNE     ??usbSendNextPacketOnIEP0_0
    773                  tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;
   \                     ??usbSendNextPacketOnIEP0_7:
   \   000056   C24D2109     MOV.B   R13, &0x921
   \   00005A   033C         JMP     ??usbSendNextPacketOnIEP0_8
    774              }
    775              else
    776              {
    777                  bStatusAction = STATUS_ACTION_NOTHING;
   \                     ??usbSendNextPacketOnIEP0_2:
   \   00005C   ....C243.... MOVX.B  #0x0, &bStatusAction
   \                     ??usbSendNextPacketOnIEP0_8:
   \   000062   ........     MOVA    R14, &pbIEP0Buffer
    778              }
    779          }
   \   000066   1001         RETA
   \   000068                REQUIRE abIEP0Buffer
   \   000068                REQUIRE tEndPoint0DescriptorBlock
    780          
    781          //----------------------------------------------------------------------------
    782          

   \                                 In  segment CODE, align 2
    783          VOID usbSendDataPacketOnEP0(PBYTE pbBuffer)
   \                     usbSendDataPacketOnEP0:
    784          {
    785              WORD wTemp;
    786          
    787              pbIEP0Buffer = pbBuffer;
   \   000000   ........     MOVA    R12, &pbIEP0Buffer
    788              wTemp = tSetupPacket.wLength;
   \   000004   1F428623     MOV.W   &0x2386, R15
    789          
    790              // Limit transfer size to wLength if needed
    791              // this prevent USB device sending 'more than require' data back to host
    792              if(wBytesRemainingOnIEP0 >= wTemp)
   \   000008   ....829F.... CMPX.W  R15, &wBytesRemainingOnIEP0
   \   00000E   0528         JNC     ??usbSendDataPacketOnEP0_0
    793              {
    794                  wBytesRemainingOnIEP0 = wTemp;
   \   000010   ....824F.... MOVX.W  R15, &wBytesRemainingOnIEP0
    795                  bHostAskMoreDataThanAvailable = FALSE;
   \   000016   4E43         MOV.B   #0x0, R14
   \   000018   013C         JMP     ??usbSendDataPacketOnEP0_1
    796              }
    797              else
    798              {
    799                  bHostAskMoreDataThanAvailable = TRUE;
   \                     ??usbSendDataPacketOnEP0_0:
   \   00001A   5E43         MOV.B   #0x1, R14
   \                     ??usbSendDataPacketOnEP0_1:
   \   00001C   ....C24E.... MOVX.B  R14, &bHostAskMoreDataThanAvailable
    800              }
    801              usbSendNextPacketOnIEP0();
   \   000022   ........     BRA     #usbSendNextPacketOnIEP0
   \   000026                REQUIRE tSetupPacket
    802          }
    803          
    804          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
    805          VOID usbReceiveNextPacketOnOEP0(VOID)
   \                     usbReceiveNextPacketOnOEP0:
    806          {
   \   000000   1B14         PUSHM.A #0x2, R11
    807              BYTE bIndex,bByte;
    808          
    809              bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCNT_BYTECNT_MASK;
   \   000002   5E422309     MOV.B   &0x923, R14
   \   000006   7EF07F00     AND.B   #0x7f, R14
    810          
    811              if(wBytesRemainingOnOEP0 >= (WORD)bByte)
   \   00000A   ........     MOVA    &pbOEP0Buffer, R15
   \   00000E   4D4E         MOV.B   R14, R13
   \   000010   ........     MOVA    #wBytesRemainingOnOEP0, R12
   \   000014   8C9D0000     CMP.W   R13, 0(R12)
   \   000018   1228         JNC     ??usbReceiveNextPacketOnOEP0_1
    812              {
    813                  for(bIndex=0;bIndex<bByte;bIndex++)
   \   00001A   4E93         CMP.B   #0x0, R14
   \   00001C   0924         JEQ     ??usbReceiveNextPacketOnOEP0_2
   \   00001E   3A407023     MOV.W   #0x2370, R10
    814                  {
    815                      *pbOEP0Buffer = abOEP0Buffer[bIndex];
   \                     ??usbReceiveNextPacketOnOEP0_0:
   \   000022   7B4A         MOV.B   @R10+, R11
   \   000024   CF4B0000     MOV.B   R11, 0(R15)
    816                      pbOEP0Buffer++;
   \   000028   AF000100     ADDA    #0x1, R15
    817                  }
   \   00002C   7E53         ADD.B   #0xff, R14
   \   00002E   F923         JNE     ??usbReceiveNextPacketOnOEP0_0
    818                  wBytesRemainingOnOEP0 -= (WORD)bByte;
   \                     ??usbReceiveNextPacketOnOEP0_2:
   \   000030   8C8D0000     SUB.W   R13, 0(R12)
    819          
    820                  // clear the NAK bit for next packet
    821                  if(wBytesRemainingOnOEP0 > 0)
   \   000034   0424         JEQ     ??usbReceiveNextPacketOnOEP0_1
    822                  {
    823                      usbClearOEP0ByteCount();
   \   000036   C2432309     MOV.B   #0x0, &0x923
    824                      bStatusAction = STATUS_ACTION_DATA_OUT;
   \   00003A   6E43         MOV.B   #0x2, R14
   \   00003C   033C         JMP     ??usbReceiveNextPacketOnOEP0_3
    825                  }
    826                  else
    827                  {
    828                      usbStallOEP0();
    829                      bStatusAction = STATUS_ACTION_NOTHING;
    830                  }
    831              }
    832              else
    833              {
    834                  usbStallOEP0();
   \                     ??usbReceiveNextPacketOnOEP0_1:
   \   00003E   ........     CALLA   #usbStallOEP0
    835                  bStatusAction = STATUS_ACTION_NOTHING;
   \   000042   4E43         MOV.B   #0x0, R14
   \                     ??usbReceiveNextPacketOnOEP0_3:
   \   000044   ....C24E.... MOVX.B  R14, &bStatusAction
   \   00004A   ........     MOVA    R15, &pbOEP0Buffer
    836              }
    837          }
   \   00004E   1A16         POPM.A  #0x2, R11
   \   000050   1001         RETA
   \   000052                REQUIRE tEndPoint0DescriptorBlock
   \   000052                REQUIRE abOEP0Buffer
    838          
    839          //----------------------------------------------------------------------------
    840          

   \                                 In  segment CODE, align 2
    841          VOID usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
   \                     usbReceiveDataPacketOnEP0:
    842          {
    843          
    844              pbOEP0Buffer = pbBuffer;
   \   000000   ........     MOVA    R12, &pbOEP0Buffer
    845          
    846              wBytesRemainingOnOEP0 = tSetupPacket.wLength;
   \   000004   ....92428623 MOVX.W  &0x2386, &wBytesRemainingOnOEP0
   \            ....        
    847              bStatusAction = STATUS_ACTION_DATA_OUT;
   \   00000C   ....E243.... MOVX.B  #0x2, &bStatusAction
    848          
    849              usbClearOEP0ByteCount();
   \   000012   ....         JMP     ?Subroutine2
   \   000014   0343         NOP
   \   000016                REQUIRE tSetupPacket
   \   000016                REQUIRE tEndPoint0DescriptorBlock
    850          }
    851          
    852          //----------------------------------------------------------------------------
    853          

   \                                 In  segment CODE, align 2, keep-with-next
    854          VOID usbSendZeroLengthPacketOnIEP0(VOID)
   \                     usbSendZeroLengthPacketOnIEP0:
    855          {
    856              wBytesRemainingOnIEP0 = NO_MORE_DATA;
   \   000000   ....B243.... MOVX.W  #0xffff, &wBytesRemainingOnIEP0
    857              bStatusAction = STATUS_ACTION_NOTHING;
   \   000006   ....C243.... MOVX.B  #0x0, &bStatusAction
    858              tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
   \   00000C   C2432109     MOV.B   #0x0, &0x921
    859          }
   \   000010   1001         RETA
   \   000012                REQUIRE tEndPoint0DescriptorBlock
    860          
    861          //----------------------------------------------------------------------------
    862          

   \                                 In  segment CODE, align 2, keep-with-next
    863          VOID usbClearEndpointFeature(VOID)
   \                     usbClearEndpointFeature:
    864          {
    865              BYTE bEndpointNumber;
    866          
    867              // EP is from EP1 to EP7 while C language start from 0
    868              bEndpointNumber = (tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM);
   \   000000   5E428423     MOV.B   &0x2384, R14
   \   000004   7EF00F00     AND.B   #0xf, R14
    869              if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();
   \   000008   2B24         JEQ     ??usbClearEndpointFeature_0
    870              else
    871              {
    872                  bEndpointNumber--;
   \   00000A   7E53         ADD.B   #0xff, R14
    873                  if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
   \   00000C   7E900700     CMP.B   #0x7, R14
   \   000010   292C         JC      ??usbClearEndpointFeature_1
    874                  {
    875                      if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
   \   000012   C2938423     CMP.B   #0x0, &0x2384
   \   000016   1134         JGE     ??usbClearEndpointFeature_2
    876                      {
    877          #ifdef _MSC_
    878                          if (!bMscResetRequired) {
   \   000018   ....C293.... CMPX.B  #0x0, &bMscResetRequired
   \   00001E   0520         JNE     ??usbClearEndpointFeature_3
    879          #endif
    880                            tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
   \   000020   4F4E         MOV.B   R14, R15
   \   000022   5F0A         RLAM.W  #0x3, R15
   \   000024   FFF0D700C823 AND.B   #0xd7, 0x23c8(R15)
    881          #ifdef _MSC_
    882                          }
    883          #endif
    884          #               ifdef _MSC_
    885                              if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
   \                     ??usbClearEndpointFeature_3:
   \   00002A   ....C29E.... CMPX.B  R14, &stUsbHandle + 2
   \   000030   1720         JNE     ??usbClearEndpointFeature_0
    886                              {
    887                                  MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
   \   000032   ....C243.... MOVX.B  #0x0, &MscReadControl + 25
    888                                  bMcsCommandSupported = TRUE;
   \   000038   103C         JMP     ??usbClearEndpointFeature_4
    889                              }
    890          #               endif
    891                      }
    892                      else
    893                      {
    894          #ifdef _MSC_
    895                          if (!bMscResetRequired) {
   \                     ??usbClearEndpointFeature_2:
   \   00003A   ....C293.... CMPX.B  #0x0, &bMscResetRequired
   \   000040   0520         JNE     ??usbClearEndpointFeature_5
    896          #endif
    897                              tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
   \   000042   4F4E         MOV.B   R14, R15
   \   000044   5F0A         RLAM.W  #0x3, R15
   \   000046   FFF0D7008823 AND.B   #0xd7, 0x2388(R15)
    898          #ifdef _MSC_
    899                          }
    900          #endif
    901          #               ifdef _MSC_
    902                              if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
   \                     ??usbClearEndpointFeature_5:
   \   00004C   ....C29E.... CMPX.B  R14, &stUsbHandle + 2
   \   000052   0620         JNE     ??usbClearEndpointFeature_0
    903                              {
    904                                  MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
   \   000054   ....C243.... MOVX.B  #0x0, &MscWriteControl + 30
    905                                  bMcsCommandSupported = TRUE;
   \                     ??usbClearEndpointFeature_4:
   \   00005A   ....9243.... MOVX.W  #0x1, &bMcsCommandSupported
    906                              }
    907          #               endif
    908                      }
    909                      usbSendZeroLengthPacketOnIEP0();
   \                     ??usbClearEndpointFeature_0:
   \   000060   ........     CALLA   #usbSendZeroLengthPacketOnIEP0
    910                  }
    911              }
    912          }
   \                     ??usbClearEndpointFeature_1:
   \   000064   1001         RETA
   \   000066                REQUIRE tSetupPacket
   \   000066                REQUIRE tInputEndPointDescriptorBlock
   \   000066                REQUIRE tOutputEndPointDescriptorBlock
    913          
    914          //----------------------------------------------------------------------------
    915          

   \                                 In  segment CODE, align 2, keep-with-next
    916          VOID usbGetConfiguration(VOID)
   \                     usbGetConfiguration:
    917          {
    918              usbClearOEP0ByteCount();                    // for status stage
   \   000000   C2432309     MOV.B   #0x0, &0x923
    919              wBytesRemainingOnIEP0 = 1;
   \   000004   ....9243.... MOVX.W  #0x1, &wBytesRemainingOnIEP0
    920              usbSendDataPacketOnEP0((PBYTE)&bConfigurationNumber);
   \   00000A   ........     MOVA    #bConfigurationNumber, R12
   \   00000E   ........     BRA     #usbSendDataPacketOnEP0
   \   000012                REQUIRE tEndPoint0DescriptorBlock
    921          }
    922          
    923          //----------------------------------------------------------------------------
    924          

   \                                 In  segment CODE, align 2, keep-with-next
    925          VOID usbGetDeviceDescriptor(VOID)
   \                     usbGetDeviceDescriptor:
    926          {
    927              usbClearOEP0ByteCount();
   \   000000   C2432309     MOV.B   #0x0, &0x923
    928              wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
   \   000004   ....B2401200 MOVX.W  #0x12, &wBytesRemainingOnIEP0
   \            ....        
    929              usbSendDataPacketOnEP0((PBYTE) &abromDeviceDescriptor);
   \   00000C   ........     MOVA    #abromDeviceDescriptor, R12
   \   000010   ........     BRA     #usbSendDataPacketOnEP0
   \   000014                REQUIRE tEndPoint0DescriptorBlock
    930          }
    931          
    932          //----------------------------------------------------------------------------
    933          

   \                                 In  segment CODE, align 2, keep-with-next
    934          VOID usbGetConfigurationDescriptor(VOID)
   \                     usbGetConfigurationDescriptor:
    935          {
    936              usbClearOEP0ByteCount();
   \   000000   C2432309     MOV.B   #0x0, &0x923
    937              wBytesRemainingOnIEP0 = sizeof(abromConfigurationDescriptorGroup);
   \   000004   ....B2408200 MOVX.W  #0x82, &wBytesRemainingOnIEP0
   \            ....        
    938              usbSendDataPacketOnEP0((PBYTE)&abromConfigurationDescriptorGroup);
   \   00000C   ........     MOVA    #abromConfigurationDescriptorGroup, R12
   \   000010   ........     BRA     #usbSendDataPacketOnEP0
   \   000014                REQUIRE tEndPoint0DescriptorBlock
    939          }
    940          
    941          //----------------------------------------------------------------------------
    942          

   \                                 In  segment CODE, align 2, keep-with-next
    943          VOID usbGetStringDescriptor(VOID)
   \                     usbGetStringDescriptor:
    944          {
    945              WORD bIndex;
    946              BYTE bVal = (BYTE)tSetupPacket.wValue;
   \   000000   5E428223     MOV.B   &0x2382, R14
    947          
    948              usbClearOEP0ByteCount();                    // for status stage
   \   000004   C2432309     MOV.B   #0x0, &0x923
    949          #if (USB_STR_INDEX_SERNUM != 0)
    950          
    951              if(bVal == 0x03)
   \   000008   7E900300     CMP.B   #0x3, R14
   \   00000C   0A20         JNE     ??usbGetStringDescriptor_1
    952              {
    953                  wBytesRemainingOnIEP0 = abramSerialStringDescriptor[0];
   \   00000E   ....5F42.... MOVX.B  &abramSerialStringDescriptor, R15
   \   000014   ....824F.... MOVX.W  R15, &wBytesRemainingOnIEP0
    954                  usbSendDataPacketOnEP0((PBYTE)&abramSerialStringDescriptor);
   \   00001A   ........     MOVA    #abramSerialStringDescriptor, R12
   \   00001E   ........     BRA     #usbSendDataPacketOnEP0
    955              }
    956              else
    957          #endif
    958              {
    959                  bIndex = 0x00;
   \                     ??usbGetStringDescriptor_1:
   \   000022   0C43         MOV.W   #0x0, R12
   \   000024   C2938223     CMP.B   #0x0, &0x2382
   \   000028   0620         JNE     ??usbGetStringDescriptor_2
   \   00002A   073C         JMP     ??usbGetStringDescriptor_3
    960                  while(bVal-- >  0x00) bIndex += abromStringDescriptor[bIndex];
   \                     ??usbGetStringDescriptor_0:
   \   00002C   7E53         ADD.B   #0xff, R14
   \   00002E   ....5F4C.... MOVX.B  abromStringDescriptor(R12), R15
   \   000034   0C5F         ADD.W   R15, R12
   \                     ??usbGetStringDescriptor_2:
   \   000036   4E93         CMP.B   #0x0, R14
   \   000038   F923         JNE     ??usbGetStringDescriptor_0
    961                  wBytesRemainingOnIEP0 = abromStringDescriptor[bIndex];
   \                     ??usbGetStringDescriptor_3:
   \   00003A   ....5F4C.... MOVX.B  abromStringDescriptor(R12), R15
   \   000040   ....824F.... MOVX.W  R15, &wBytesRemainingOnIEP0
    962                  usbSendDataPacketOnEP0((PBYTE)&abromStringDescriptor[bIndex]);
   \   000046   ........     ADDA    #abromStringDescriptor, R12
   \   00004A   ........     BRA     #usbSendDataPacketOnEP0
   \   00004E                REQUIRE tSetupPacket
   \   00004E                REQUIRE tEndPoint0DescriptorBlock
    963              }
    964          }
    965          
    966          //----------------------------------------------------------------------------
    967          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   C2432309     MOV.B   #0x0, &0x923
   \   000004   ....A243.... MOVX.W  #0x2, &wBytesRemainingOnIEP0
   \   00000A   ........     MOVA    #abUsbRequestReturnData, R12
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_1:
   \   000004   CC430000     MOV.B   #0x0, 0(R12)
   \   000008   ....DC42.... MOVX.B  &bInterfaceNumber, 0x1(R12)
   \            0100        
   \   000010   ........     BRA     #usbSendDataPacketOnEP0

   \                                 In  segment CODE, align 2, keep-with-next
    968          VOID usbGetInterface(VOID)
   \                     usbGetInterface:
    969          {
    970          
    971              // not fully supported, return one byte, zero
    972              usbClearOEP0ByteCount();                    // for status stage
   \   000000   ....         JMP     ?Subroutine3
   \   000002   0343         NOP
   \   000004                REQUIRE tEndPoint0DescriptorBlock
    973              wBytesRemainingOnIEP0 = 0x02;
    974              abUsbRequestReturnData[0] = 0x00;           // changed to report alternative setting byte
    975              abUsbRequestReturnData[1] = bInterfaceNumber;
    976              usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
    977          }
    978          
    979          //----------------------------------------------------------------------------
    980          

   \                                 In  segment CODE, align 2, keep-with-next
    981          VOID usbGetDeviceStatus(VOID)
   \                     usbGetDeviceStatus:
    982          {
    983              if((abromConfigurationDescriptorGroup.abromConfigurationDescriptorGenric.mattributes &
    984                  CFG_DESC_ATTR_SELF_POWERED) == CFG_DESC_ATTR_SELF_POWERED)
   \   000000   ........     MOVA    #abUsbRequestReturnData, R12
   \   000004   ....F2B04000 BITX.B  #0x40, &abromConfigurationDescriptorGroup + 7
   \            ....        
   \   00000C   0228         JNC     ??usbGetDeviceStatus_0
    985              {
    986                  abUsbRequestReturnData[0] = DEVICE_STATUS_SELF_POWER;
   \   00000E   DC430000     MOV.B   #0x1, 0(R12)
    987              }
    988              if(bRemoteWakeup == ENABLE)
   \                     ??usbGetDeviceStatus_0:
   \   000012   ....D293.... CMPX.B  #0x1, &bRemoteWakeup
   \   000018   0220         JNE     ??usbGetDeviceStatus_1
    989              {
    990                  abUsbRequestReturnData[0] |= DEVICE_STATUS_REMOTE_WAKEUP;
   \   00001A   ECD30000     BIS.B   #0x2, 0(R12)
    991              }
    992              usbClearOEP0ByteCount();                    // for status stage
   \                     ??usbGetDeviceStatus_1:
   \   00001E   C2432309     MOV.B   #0x0, &0x923
    993          
    994              // Return self power status and remote wakeup status
    995              wBytesRemainingOnIEP0 = 2;
   \   000022   ....A243.... MOVX.W  #0x2, &wBytesRemainingOnIEP0
    996              usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
   \   000028   ........     BRA     #usbSendDataPacketOnEP0
   \   00002C                REQUIRE tEndPoint0DescriptorBlock
    997          }
    998          
    999          //----------------------------------------------------------------------------
   1000          

   \                                 In  segment CODE, align 2, keep-with-next
   1001          VOID usbGetInterfaceStatus(VOID)
   \                     usbGetInterfaceStatus:
   1002          {
   1003              // check bIndexL for index number (not supported)
   1004              usbClearOEP0ByteCount();                    // for status stage
   \   000000                REQUIRE ?Subroutine3
   \   000000                REQUIRE tEndPoint0DescriptorBlock
   \   000000                // Fall through to label ?Subroutine3
   1005          
   1006              // Return two zero bytes
   1007              wBytesRemainingOnIEP0 = 2;
   1008              abUsbRequestReturnData[0] = 0x00;           // changed to support multiple interfaces
   1009              abUsbRequestReturnData[1] = bInterfaceNumber;
   1010              usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
   1011          }
   1012          
   1013          //----------------------------------------------------------------------------
   1014          

   \                                 In  segment CODE, align 2, keep-with-next
   1015          VOID usbGetEndpointStatus(VOID)
   \                     usbGetEndpointStatus:
   1016          {
   1017              BYTE bEndpointNumber;
   1018          
   1019              // Endpoint number is bIndexL
   1020              bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
   \   000000   5F428423     MOV.B   &0x2384, R15
   \   000004   7FF00F00     AND.B   #0xf, R15
   1021              if(bEndpointNumber == 0x00)
   \   000008   0920         JNE     ??usbGetEndpointStatus_1
   1022              {
   1023                  if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
   \   00000A   C2938423     CMP.B   #0x0, &0x2384
   \   00000E   0334         JGE     ??usbGetEndpointStatus_2
   1024                  {
   1025                      // input endpoint 0
   1026                      abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bIEPCNFG & EPCNF_STALL);
   \   000010   5E422009     MOV.B   &0x920, R14
   \   000014   103C         JMP     ??usbGetEndpointStatus_0
   1027                  }
   1028                  else
   1029                  {
   1030                      // output endpoint 0
   1031                      abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bOEPCNFG & EPCNF_STALL);
   \                     ??usbGetEndpointStatus_2:
   \   000016   5E422209     MOV.B   &0x922, R14
   \   00001A   0D3C         JMP     ??usbGetEndpointStatus_0
   1032                  }
   1033                  abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
   1034                  usbClearOEP0ByteCount();                    // for status stage
   1035                  wBytesRemainingOnIEP0 = 0x02;
   1036                  usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
   1037              }
   1038              else
   1039              {
   1040                  bEndpointNumber--;
   \                     ??usbGetEndpointStatus_1:
   \   00001C   7F53         ADD.B   #0xff, R15
   1041                  // EP is from EP1 to EP7 while C language start from 0
   1042                  // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
   1043                  if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
   \   00001E   7F900700     CMP.B   #0x7, R15
   \   000022   0D2C         JC      ??usbGetEndpointStatus_3
   1044                  {
   1045                      if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
   \   000024   5F0A         RLAM.W  #0x3, R15
   \   000026   C2938423     CMP.B   #0x0, &0x2384
   \   00002A   0334         JGE     ??usbGetEndpointStatus_4
   1046                      {
   1047                          // input endpoint
   1048                          abUsbRequestReturnData[0] = (BYTE)(tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
   \   00002C   5E4FC823     MOV.B   0x23c8(R15), R14
   \   000030   023C         JMP     ??usbGetEndpointStatus_0
   1049                      }else
   1050                      {
   1051                          // output endpoint
   1052                          abUsbRequestReturnData[0] = (BYTE)(tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
   \                     ??usbGetEndpointStatus_4:
   \   000032   5E4F8823     MOV.B   0x2388(R15), R14
   \                     ??usbGetEndpointStatus_0:
   \   000036   7EF2         AND.B   #0x8, R14
   \   000038   ....C24E.... MOVX.B  R14, &abUsbRequestReturnData
   1053                      }
   1054                  }   // no response if endpoint is not supported.
   1055                  abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
   \                     ??usbGetEndpointStatus_3:
   \   00003E   ....5E42.... MOVX.B  &abUsbRequestReturnData, R14
   \   000044                RPT     #0x3
   \   000044   42194E10     RRUX.B  R14
   \   000048   ....C24E.... MOVX.B  R14, &abUsbRequestReturnData
   1056                  usbClearOEP0ByteCount();
   \   00004E   ........     CALLA   #?Subroutine4
   1057                  wBytesRemainingOnIEP0 = 0x02;
   1058                  usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
   1059              }
   \                     ??CrossCallReturnLabel_0:
   \   000052   ........     BRA     #usbSendDataPacketOnEP0
   \   000056                REQUIRE tSetupPacket
   \   000056                REQUIRE tEndPoint0DescriptorBlock
   \   000056                REQUIRE tInputEndPointDescriptorBlock
   \   000056                REQUIRE tOutputEndPointDescriptorBlock
   1060          }
   1061          
   1062          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
   1063          VOID usbSetAddress(VOID)
   \                     usbSetAddress:
   1064          {
   1065              usbStallOEP0();                             // control write without data stage
   \   000000   ........     CALLA   #usbStallOEP0
   1066          
   1067              // bValueL contains device address
   1068              if(tSetupPacket.wValue < 128)
   \   000004   B29080008223 CMP.W   #0x80, &0x2382
   \   00000A   052C         JC      ??usbSetAddress_0
   1069              {
   1070                  // hardware will update the address after status stage
   1071                  // therefore, firmware can set the address now.
   1072                  USBFUNADR = tSetupPacket.wValue;
   \   00000C   D24282233F09 MOV.B   &0x2382, &0x93f
   1073                  usbSendZeroLengthPacketOnIEP0();
   \   000012   ........     BRA     #usbSendZeroLengthPacketOnIEP0
   1074              }
   1075              else
   1076              {
   1077                  usbStallEndpoint0();
   \                     ??usbSetAddress_0:
   \   000016   ........     BRA     #usbStallEndpoint0
   \   00001A                REQUIRE tSetupPacket
   \   00001A                REQUIRE USBFUNADR
   1078              }
   1079          }
   1080          
   1081          //----------------------------------------------------------------------------
   1082          

   \                                 In  segment CODE, align 2
   1083          VOID usbSetConfiguration(VOID)
   \                     usbSetConfiguration:
   1084          {
   1085              usbStallOEP0();                             // control write without data stage
   \   000000   ........     CALLA   #usbStallOEP0
   1086          
   1087              // configuration number is in bValueL
   1088              // change the code if more than one configuration is supported
   1089              bConfigurationNumber = tSetupPacket.wValue;
   \   000004   ....D2428223 MOVX.B  &0x2382, &bConfigurationNumber
   \            ....        
   1090              usbSendZeroLengthPacketOnIEP0();
   \   00000C   ........     CALLA   #usbSendZeroLengthPacketOnIEP0
   1091          
   1092              if (bConfigurationNumber == 1)
   \   000010   ....D293.... CMPX.B  #0x1, &bConfigurationNumber
   \   000016   0224         JEQ     ??usbSetConfiguration_0
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   013C         JMP     ??usbSetConfiguration_1
   \                     ??usbSetConfiguration_0:
   \   00001C   5E43         MOV.B   #0x1, R14
   \                     ??usbSetConfiguration_1:
   \   00001E   ....C24E.... MOVX.B  R14, &bEnumerationStatus
   1093              {
   1094                  bEnumerationStatus = ENUMERATION_COMPLETE;      // set device as enumerated
   1095              }
   1096              else
   1097              {
   1098                  bEnumerationStatus = 0; //device is not configured == config # is zero
   1099              }
   1100          }
   \   000024   1001         RETA
   \   000026                REQUIRE tSetupPacket
   1101          
   1102          //----------------------------------------------------------------------------
   1103          

   \                                 In  segment CODE, align 2
   1104          VOID usbClearDeviceFeature(VOID)
   \                     usbClearDeviceFeature:
   1105          {
   1106              // bValueL contains feature selector
   1107              if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
   \   000000   92938223     CMP.W   #0x1, &0x2382
   \   000004   0520         JNE     ??usbClearDeviceFeature_0
   1108              {
   1109                  bRemoteWakeup = DISABLE;
   \   000006   ....C243.... MOVX.B  #0x0, &bRemoteWakeup
   1110                  usbSendZeroLengthPacketOnIEP0();
   \   00000C   ........     BRA     #usbSendZeroLengthPacketOnIEP0
   1111              }
   1112              else
   1113              {
   1114                  usbStallEndpoint0();
   \                     ??usbClearDeviceFeature_0:
   \   000010   ........     BRA     #usbStallEndpoint0
   \   000014                REQUIRE tSetupPacket
   1115              }
   1116          }
   1117          
   1118          //----------------------------------------------------------------------------
   1119          

   \                                 In  segment CODE, align 2
   1120          VOID usbSetDeviceFeature(VOID)
   \                     usbSetDeviceFeature:
   1121          {
   1122              // bValueL contains feature selector
   1123              if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
   \   000000   92938223     CMP.W   #0x1, &0x2382
   \   000004   0520         JNE     ??usbSetDeviceFeature_0
   1124              {
   1125                  bRemoteWakeup = ENABLE;
   \   000006   ....D243.... MOVX.B  #0x1, &bRemoteWakeup
   1126                  usbSendZeroLengthPacketOnIEP0();
   \   00000C   ........     BRA     #usbSendZeroLengthPacketOnIEP0
   1127              }
   1128              else
   1129              {
   1130                  usbStallEndpoint0();
   \                     ??usbSetDeviceFeature_0:
   \   000010   ........     BRA     #usbStallEndpoint0
   \   000014                REQUIRE tSetupPacket
   1131              }
   1132          }
   1133          
   1134          //----------------------------------------------------------------------------
   1135          

   \                                 In  segment CODE, align 2
   1136          VOID usbSetEndpointFeature(VOID)
   \                     usbSetEndpointFeature:
   1137          {
   1138              BYTE bEndpointNumber;
   1139          
   1140              // wValue contains feature selector
   1141              // bIndexL contains endpoint number
   1142              // Endpoint number is in low byte of wIndex
   1143              if(tSetupPacket.wValue == FEATURE_ENDPOINT_STALL)
   \   000000   82938223     CMP.W   #0x0, &0x2382
   \   000004   1420         JNE     ??usbSetEndpointFeature_0
   1144              {
   1145                  bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
   \   000006   5F428423     MOV.B   &0x2384, R15
   \   00000A   7FF00F00     AND.B   #0xf, R15
   1146                  if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();  // do nothing for endpoint 0
   \   00000E   0D24         JEQ     ??usbSetEndpointFeature_1
   1147                  else
   1148                  {
   1149                      bEndpointNumber--;
   \   000010   7F53         ADD.B   #0xff, R15
   1150                      // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
   1151                      if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
   \   000012   7F900700     CMP.B   #0x7, R15
   \   000016   0D2C         JC      ??usbSetEndpointFeature_2
   1152                      {
   1153                          if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
   \   000018   5F0A         RLAM.W  #0x3, R15
   \   00001A   C2938423     CMP.B   #0x0, &0x2384
   \   00001E   0334         JGE     ??usbSetEndpointFeature_3
   1154                          {
   1155                              // input endpoint
   1156                              tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
   \   000020   FFD2C823     BIS.B   #0x8, 0x23c8(R15)
   \   000024   023C         JMP     ??usbSetEndpointFeature_1
   1157                          }
   1158                          else
   1159                          {
   1160                              // output endpoint
   1161                              tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
   \                     ??usbSetEndpointFeature_3:
   \   000026   FFD28823     BIS.B   #0x8, 0x2388(R15)
   1162                          }
   1163                          usbSendZeroLengthPacketOnIEP0();
   \                     ??usbSetEndpointFeature_1:
   \   00002A   ........     BRA     #usbSendZeroLengthPacketOnIEP0
   1164                      } // no response if endpoint is not supported.
   1165                  }
   1166              }
   1167              else
   1168              {
   1169                  usbStallEndpoint0();
   \                     ??usbSetEndpointFeature_0:
   \   00002E   ........     CALLA   #usbStallEndpoint0
   1170              }
   1171          }
   \                     ??usbSetEndpointFeature_2:
   \   000032   1001         RETA
   \   000034                REQUIRE tSetupPacket
   \   000034                REQUIRE tInputEndPointDescriptorBlock
   \   000034                REQUIRE tOutputEndPointDescriptorBlock
   1172          
   1173          //----------------------------------------------------------------------------
   1174          

   \                                 In  segment CODE, align 2
   1175          VOID usbSetInterface(VOID)
   \                     usbSetInterface:
   1176          {
   1177              // bValueL contains alternative setting
   1178              // bIndexL contains interface number
   1179              // change code if more than one interface is supported
   1180              usbStallOEP0();                             // control write without data stage
   \   000000   ........     CALLA   #usbStallOEP0
   1181              bInterfaceNumber = tSetupPacket.wIndex;
   \   000004   ....D2428423 MOVX.B  &0x2384, &bInterfaceNumber
   \            ....        
   1182          #ifdef _MSC_
   1183              tInputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
   \   00000C   ....5E42.... MOVX.B  &stUsbHandle + 2, R14
   \   000012   5E0A         RLAM.W  #0x3, R14
   \   000014   0F4E         MOV.W   R14, R15
   \   000016   FFC02000C823 BIC.B   #0x20, 0x23c8(R15)
   1184              tOutputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
   \   00001C   FEC020008823 BIC.B   #0x20, 0x2388(R14)
   1185              MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
   \   000022   ....C243.... MOVX.B  #0x0, &MscReadControl + 25
   1186              MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
   \   000028   ....C243.... MOVX.B  #0x0, &MscWriteControl + 30
   1187          #endif
   1188              usbSendZeroLengthPacketOnIEP0();
   \   00002E   ........     BRA     #usbSendZeroLengthPacketOnIEP0
   \   000032                REQUIRE tSetupPacket
   \   000032                REQUIRE tInputEndPointDescriptorBlock
   \   000032                REQUIRE tOutputEndPointDescriptorBlock
   1189          }
   1190          
   1191          //----------------------------------------------------------------------------
   1192          

   \                                 In  segment CODE, align 2, keep-with-next
   1193          VOID usbInvalidRequest(VOID)
   \                     usbInvalidRequest:
   1194          {
   1195              // check if setup overwrite is set
   1196              // if set, do nothing since we might decode it wrong
   1197              // setup packet buffer could be modified by hardware if another setup packet
   1198              // was sent while we are deocding setup packet
   1199              if ((USBIFG & STPOWIFG) == 0x00)
   \   000000   D2B33E09     BIT.B   #0x1, &0x93e
   \   000004   022C         JC      ??usbInvalidRequest_0
   1200              {
   1201                usbStallEndpoint0();
   \   000006   ........     CALLA   #usbStallEndpoint0
   1202              }
   1203          }
   \                     ??usbInvalidRequest_0:
   \   00000A   1001         RETA
   \   00000C                REQUIRE USBIFG
   1204          
   1205          typedef VOID (*tpF)(VOID);
   1206          

   \                                 In  segment CODE, align 2
   1207          BYTE usbDecodeAndProcessUsbRequest(VOID)
   \                     usbDecodeAndProcessUsbRequest:
   1208          {
   \   000000   1B14         PUSHM.A #0x2, R11
   1209              BYTE  bMask,bResult,bTemp;
   1210              const BYTE* pbUsbRequestList;
   1211              BYTE bWakeUp = FALSE;
   \   000002   4A43         MOV.B   #0x0, R10
   1212              ptDEVICE_REQUEST ptSetupPacket = &tSetupPacket;
   1213              BYTE  bRequestType,bRequest;
   1214              tpF lAddrOfFunction;
   1215          
   1216              // point to beginning of the matrix
   1217              pbUsbRequestList = (PBYTE)&tUsbRequestList[0];
   \   000004   ........     MOVA    #tUsbRequestList, R15
   \   000008   5E428023     MOV.B   &0x2380, R14
   \   00000C   023C         JMP     ??usbDecodeAndProcessUsbRequest_3
   1218          
   1219              while(1)
   1220              {
   1221                  bRequestType = *pbUsbRequestList++;
   1222                  bRequest     = *pbUsbRequestList++;
   1223          
   1224                  if(((bRequestType == 0xff) && (bRequest == 0xff)) ||
   1225                      (tSetupPacket.bmRequestType == (USB_REQ_TYPE_INPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)) ||
   1226                      (tSetupPacket.bmRequestType == (USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)))
   1227                  {
   1228                      pbUsbRequestList -= 2;
   1229                      break;
   1230                  }
   1231          
   1232                  if((bRequestType == tSetupPacket.bmRequestType) && (bRequest == tSetupPacket.bRequest))
   1233                  {
   1234                      // compare the first two
   1235                      bResult = 0xc0;
   1236                      bMask   = 0x20;
   1237                      // first two bytes matched, compare the rest
   1238                      for(bTemp = 2; bTemp < 8; bTemp++)
   1239                      {
   1240                          if (*((BYTE*)ptSetupPacket + bTemp) == *pbUsbRequestList)
   1241                          {
   1242                              bResult |= bMask;
   1243                          }
   1244                          pbUsbRequestList++;
   1245                          bMask = bMask >> 1;
   1246                      }
   1247                      // now we have the result
   1248                      if((*pbUsbRequestList & bResult) == *pbUsbRequestList)
   1249                      {
   1250                          pbUsbRequestList -= 8;
   1251                          break;
   1252                      }
   1253                      else
   1254                      {
   1255                          pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-8);
   \                     ??usbDecodeAndProcessUsbRequest_1:
   \   00000E   AF000600     ADDA    #0x6, R15
   1256                      }
   \                     ??usbDecodeAndProcessUsbRequest_3:
   \   000012   7D4F         MOV.B   @R15+, R13
   \   000014   7C4F         MOV.B   @R15+, R12
   \   000016   7D93         CMP.B   #0xff, R13
   \   000018   0220         JNE     ??usbDecodeAndProcessUsbRequest_4
   \   00001A   7C93         CMP.B   #0xff, R12
   \   00001C   0624         JEQ     ??usbDecodeAndProcessUsbRequest_5
   \                     ??usbDecodeAndProcessUsbRequest_4:
   \   00001E   7E90C000     CMP.B   #0xc0, R14
   \   000022   0324         JEQ     ??usbDecodeAndProcessUsbRequest_5
   \   000024   7E904000     CMP.B   #0x40, R14
   \   000028   0620         JNE     ??usbDecodeAndProcessUsbRequest_6
   \                     ??usbDecodeAndProcessUsbRequest_5:
   \   00002A   FF03         SUBA    #0x2, R15
   1257                  }
   1258                  else
   1259                  {
   1260                      pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-2);
   1261                  }
   1262              }
   1263          
   1264              // if another setup packet comes before we have the chance to process current
   1265              // setup request, we return here without processing the request
   1266              // this check is not necessary but still kept here to reduce response(or simulation) time
   1267          
   1268              if((USBIFG & STPOWIFG) != 0x00)
   \                     ??usbDecodeAndProcessUsbRequest_2:
   \   00002C   D2B33E09     BIT.B   #0x1, &0x93e
   \   000030   2428         JNC     ??usbDecodeAndProcessUsbRequest_7
   1269              {
   1270                  return bWakeUp;
   \   000032   4C43         MOV.B   #0x0, R12
   \   000034   2F3C         JMP     ??usbDecodeAndProcessUsbRequest_8
   1271              }
   \                     ??usbDecodeAndProcessUsbRequest_6:
   \   000036   4D9E         CMP.B   R14, R13
   \   000038   1D20         JNE     ??usbDecodeAndProcessUsbRequest_9
   \   00003A   5C928123     CMP.B   &0x2381, R12
   \   00003E   1A20         JNE     ??usbDecodeAndProcessUsbRequest_9
   \   000040   7D40C000     MOV.B   #0xc0, R13
   \   000044   7C402000     MOV.B   #0x20, R12
   \   000048   8B008223     MOVA    #0x2382, R11
   \                     ??usbDecodeAndProcessUsbRequest_0:
   \   00004C   EB9F0000     CMP.B   @R15, 0(R11)
   \   000050   0120         JNE     ??usbDecodeAndProcessUsbRequest_10
   \   000052   4DDC         BIS.B   R12, R13
   \                     ??usbDecodeAndProcessUsbRequest_10:
   \   000054   AF000100     ADDA    #0x1, R15
   \   000058   5C03         RRUM.W  #0x1, R12
   \   00005A   AB000100     ADDA    #0x1, R11
   \   00005E   9B008823     CMPA    #0x2388, R11
   \   000062   F423         JNE     ??usbDecodeAndProcessUsbRequest_0
   \   000064   6B4F         MOV.B   @R15, R11
   \   000066   4C4B         MOV.B   R11, R12
   \   000068   4CFD         AND.B   R13, R12
   \   00006A   4C9B         CMP.B   R11, R12
   \   00006C   D023         JNE     ??usbDecodeAndProcessUsbRequest_1
   \   00006E   BF000800     SUBA    #0x8, R15
   \   000072   DC3F         JMP     ??usbDecodeAndProcessUsbRequest_2
   \                     ??usbDecodeAndProcessUsbRequest_9:
   \   000074   AF000C00     ADDA    #0xc, R15
   \   000078   CC3F         JMP     ??usbDecodeAndProcessUsbRequest_3
   1272          
   1273              // now we found the match and jump to the function accordingly.
   1274              lAddrOfFunction = ((tDEVICE_REQUEST_COMPARE*)pbUsbRequestList)->pUsbFunction;
   \                     ??usbDecodeAndProcessUsbRequest_7:
   \   00007A   3B0F0A00     MOVA    0xa(R15), R11
   1275          
   1276              // call function
   1277              (*lAddrOfFunction)();
   \   00007E   4B13         CALLA   R11
   1278          
   1279              // perform enumeration complete event:
   1280              // when SetAddress was called and USBADDR is not zero
   1281              if ((lAddrOfFunction == &usbSetAddress) && (USBFUNADR != 0))
   \   000080   ........     CMPA    #usbSetAddress, R11
   \   000084   0620         JNE     ??usbDecodeAndProcessUsbRequest_11
   \   000086   C2933F09     CMP.B   #0x0, &0x93f
   \   00008A   0324         JEQ     ??usbDecodeAndProcessUsbRequest_11
   1282              {
   1283                  bWakeUp = USB_handleEnumCompleteEvent();
   \   00008C   ........     CALLA   #USB_handleEnumCompleteEvent
   \   000090   4A4C         MOV.B   R12, R10
   1284              }
   1285              return bWakeUp;
   \                     ??usbDecodeAndProcessUsbRequest_11:
   \   000092   4C4A         MOV.B   R10, R12
   \                     ??usbDecodeAndProcessUsbRequest_8:
   \   000094   1A16         POPM.A  #0x2, R11
   \   000096   1001         RETA
   \   000098                REQUIRE tSetupPacket
   \   000098                REQUIRE USBIFG
   \   000098                REQUIRE USBFUNADR
   1286          }
   1287          
   1288          /*----------------------------------------------------------------------------+
   1289          | End of source file                                                          |
   1290          +----------------------------------------------------------------------------*/
   1291          /*------------------------ Nothing Below This Line --------------------------*/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      18  USB_InitSerialStringDescriptor
            18 -> Get_TLV_Info
       4  USB_connect
       4  USB_connectionInfo
       4  USB_connectionState
       4  USB_disable
       4  USB_disconnect
       8  USB_enable
             8 -> XT2_Start
       4  USB_forceRemoteWakeup
       4  USB_getEnabledEvents
      10  USB_init
            10 -> MscResetCtrlLun
            10 -> USB_InitSerialStringDescriptor
            10 -> USB_initMemcpy
      12  USB_reset
            12 -> CdcResetData
            12 -> HidResetData
            12 -> MscResetData
       4  USB_resume
             4 -> USB_enable
       4  USB_setEnabledEvents
       4  USB_suspend
       4  usbClearDeviceFeature
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallEndpoint0
       4  usbClearEndpointFeature
             4 -> usbSendZeroLengthPacketOnIEP0
       4  usbClearOEP0ByteCount
      12  usbDecodeAndProcessUsbRequest
            12 -- Indirect call
            12 -> USB_handleEnumCompleteEvent
       4  usbGetConfiguration
             4 -> usbSendDataPacketOnEP0
       4  usbGetConfigurationDescriptor
             4 -> usbSendDataPacketOnEP0
       4  usbGetDeviceDescriptor
             4 -> usbSendDataPacketOnEP0
       4  usbGetDeviceStatus
             4 -> usbSendDataPacketOnEP0
       4  usbGetEndpointStatus
             4 -> usbSendDataPacketOnEP0
       4  usbGetInterface
             4 -> usbSendDataPacketOnEP0
       4  usbGetInterfaceStatus
             4 -> usbSendDataPacketOnEP0
       4  usbGetStringDescriptor
             4 -> usbSendDataPacketOnEP0
       4  usbInvalidRequest
             4 -> usbStallEndpoint0
       4  usbReceiveDataPacketOnEP0
      12  usbReceiveNextPacketOnOEP0
            12 -> usbStallOEP0
       4  usbSendDataPacketOnEP0
             4 -> usbSendNextPacketOnIEP0
       4  usbSendNextPacketOnIEP0
       4  usbSendZeroLengthPacketOnIEP0
       4  usbSetAddress
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallEndpoint0
             4 -> usbStallOEP0
       4  usbSetConfiguration
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallOEP0
       4  usbSetDeviceFeature
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallEndpoint0
       4  usbSetEndpointFeature
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallEndpoint0
       4  usbSetInterface
             4 -> usbSendZeroLengthPacketOnIEP0
             4 -> usbStallOEP0
       4  usbStallEndpoint0
       4  usbStallOEP0


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ??Subroutine9_0
      10  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      20  ?Subroutine3
      16  ?Subroutine4
      18  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
       1  USBCTL
       1  USBFUNADR
       1  USBIE
       1  USBIEPIE
       1  USBIFG
       1  USBOEPIE
     174  USB_InitSerialStringDescriptor
      36  USB_connect
      48  USB_connectionInfo
     156  USB_connectionState
      18  USB_disable
      14  USB_disconnect
     122  USB_enable
      36  USB_forceRemoteWakeup
       8  USB_getEnabledEvents
      88  USB_init
     298  USB_reset
      20  USB_resume
      10  USB_setEnabledEvents
      48  USB_suspend
       2  _A_UCSCTL6_L
       2  _A_USBCNF_L
       2  _A_USBKEYID_L
       2  _A_USBPHYCTL_L
       2  _A_USBPLLCTL_L
       2  _A_USBPLLDIVB_L
       2  _A_USBPLLIR_L
       2  _A_USBPWRCTL_L
       8  abIEP0Buffer
       8  abOEP0Buffer
       8  abUsbRequestIncomingData
       8  abUsbRequestReturnData
      34  abramSerialStringDescriptor
       1  bConfigurationNumber
       1  bEnumerationStatus
       1  bFunctionSuspended
       1  bHostAskMoreDataThanAvailable
       1  bInterfaceNumber
       1  bRemoteWakeup
       1  bStatusAction
       4  pbIEP0Buffer
       4  pbOEP0Buffer
       4  tEndPoint0DescriptorBlock
      56  tInputEndPointDescriptorBlock
      56  tOutputEndPointDescriptorBlock
       8  tSetupPacket
      20  usbClearDeviceFeature
     102  usbClearEndpointFeature
       0  usbClearOEP0ByteCount
     152  usbDecodeAndProcessUsbRequest
      18  usbGetConfiguration
      20  usbGetConfigurationDescriptor
      20  usbGetDeviceDescriptor
      44  usbGetDeviceStatus
      86  usbGetEndpointStatus
       4  usbGetInterface
       0  usbGetInterfaceStatus
      78  usbGetStringDescriptor
      12  usbInvalidRequest
      22  usbReceiveDataPacketOnEP0
      82  usbReceiveNextPacketOnOEP0
      38  usbSendDataPacketOnEP0
     104  usbSendNextPacketOnIEP0
      18  usbSendZeroLengthPacketOnIEP0
      26  usbSetAddress
      38  usbSetConfiguration
      20  usbSetDeviceFeature
      52  usbSetEndpointFeature
      50  usbSetInterface
       4  usbStallEndpoint0
       4  usbStallOEP0
       2  wBytesRemainingOnIEP0
       2  wBytesRemainingOnOEP0
       2  wUsbEventMask

 
 2 200 bytes in segment CODE
   162 bytes in segment DATA16_AN
    34 bytes in segment DATA20_N
    37 bytes in segment DATA20_Z
 
 2 200 bytes of CODE memory
    71 bytes of DATA memory (+ 162 bytes shared)

Errors: none
Warnings: none
