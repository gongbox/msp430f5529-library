###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:25 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ff.c                                   #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ff.c -D NDEBUG -D RAM_VECTOR -lC       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -lA C:\Users\615\Desktop\MSP430\MS #
#                     P430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -o        #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\ -D__MSP430F5529__ -e --double=32    #
#                     --dlib_config "D:\Program Files (x86)\IAR               #
#                     Systems\Embedded Workbench 6.4                          #
#                     Evaluation\430\LIB\DLIB\dl430xlfn.h" -I                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ff.lst                              #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\ff.r43                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.08b                 (C)ChaN, 2011
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2011, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path names.
     90          /---------------------------------------------------------------------------*/
     91          
     92          #include "ff.h"			/* FatFs configurations and declarations */
     93          #include "diskio.h"		/* Declarations of low level disk I/O functions */
     94          
     95          
     96          /*--------------------------------------------------------------------------
     97          
     98             Module Private Definitions
     99          
    100          ---------------------------------------------------------------------------*/
    101          
    102          #if _FATFS != 8237
    103          #error Wrong include file (ff.h).
    104          #endif
    105          
    106          
    107          /* Definitions on sector size */
    108          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    109          #error Wrong sector size.
    110          #endif
    111          #if _MAX_SS != 512
    112          #define	SS(fs)	((fs)->ssize)	/* Multiple sector size */
    113          #else
    114          #define	SS(fs)	512U			/* Fixed sector size */
    115          #endif
    116          
    117          
    118          /* Reentrancy related */
    119          #if _FS_REENTRANT
    120          #if _USE_LFN == 1
    121          #error Static LFN work area must not be used in re-entrant configuration.
    122          #endif
    123          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    124          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    125          #else
    126          #define	ENTER_FF(fs)
    127          #define LEAVE_FF(fs, res)	return res
    128          #endif
    129          
    130          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    131          
    132          
    133          /* File shareing feature */
    134          #if _FS_SHARE
    135          #if _FS_READONLY
    136          #error _FS_SHARE must be 0 on read-only cfg.
    137          #endif
    138          typedef struct {
    139          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    140          	DWORD clu;				/* File ID 2, directory */
    141          	WORD idx;				/* File ID 3, directory index */
    142          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    143          } FILESEM;
    144          #endif
    145          
    146          
    147          /* Misc definitions */
    148          #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
    149          #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
    150          
    151          
    152          /* DBCS code ranges and SBCS extend char conversion table */
    153          
    154          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    155          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    156          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    157          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    158          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    159          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    160          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    161          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    162          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    163          
    164          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    165          #define _DF1S	0x81
    166          #define _DF1E	0xFE
    167          #define _DS1S	0x40
    168          #define _DS1E	0x7E
    169          #define _DS2S	0x80
    170          #define _DS2E	0xFE
    171          
    172          #elif _CODE_PAGE == 949	/* Korean */
    173          #define _DF1S	0x81
    174          #define _DF1E	0xFE
    175          #define _DS1S	0x41
    176          #define _DS1E	0x5A
    177          #define _DS2S	0x61
    178          #define _DS2E	0x7A
    179          #define _DS3S	0x81
    180          #define _DS3E	0xFE
    181          
    182          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    183          #define _DF1S	0x81
    184          #define _DF1E	0xFE
    185          #define _DS1S	0x40
    186          #define _DS1E	0x7E
    187          #define _DS2S	0xA1
    188          #define _DS2E	0xFE
    189          
    190          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    191          #define _DF1S	0
    192          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    193          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    194          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    195          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    196          
    197          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    198          #define _DF1S	0
    199          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    200          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    201          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    202          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    203          
    204          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    205          #define _DF1S	0
    206          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    207          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    208          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    209          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    210          
    211          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    212          #define _DF1S	0
    213          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    214          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    215          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    216          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    217          
    218          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    219          #define _DF1S	0
    220          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    221          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    222          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    223          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    224          
    225          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    226          #define _DF1S	0
    227          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    228          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    229          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    230          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    231          
    232          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    233          #define _DF1S	0
    234          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    235          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    236          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    237          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    238          
    239          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    240          #define _DF1S	0
    241          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    242          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    243          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    244          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    245          
    246          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    247          #define _DF1S	0
    248          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    249          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    250          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    251          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    252          
    253          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    254          #define _DF1S	0
    255          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    256          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    257          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    258          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    259          
    260          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    261          #define _DF1S	0
    262          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    263          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    264          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    265          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    266          
    267          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    268          #define _DF1S	0
    269          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    270          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    271          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    272          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    273          
    274          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    275          #define _DF1S	0
    276          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    277          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    278          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    279          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    280          
    281          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    282          #define _DF1S	0
    283          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    284          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    285          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    286          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    287          
    288          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    289          #define _DF1S	0
    290          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    291          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    292          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    293          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    294          
    295          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    296          #define _DF1S	0
    297          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    298          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    299          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    300          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    301          
    302          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    303          #define _DF1S	0
    304          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    305          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    306          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    307          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    308          
    309          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    310          #define _DF1S	0
    311          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    312          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    313          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    314          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    315          
    316          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    317          #define _DF1S	0
    318          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    319          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    320          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    321          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    322          
    323          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    324          #define _DF1S	0
    325          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    326          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    327          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    328          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    329          
    330          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    331          #define _DF1S	0
    332          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    333          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    334          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    335          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    336          
    337          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    338          #if _USE_LFN
    339          #error Cannot use LFN feature without valid code page.
    340          #endif
    341          #define _DF1S	0
    342          
    343          #else
    344          #error Unknown code page
    345          
    346          #endif
    347          
    348          
    349          /* Character code support macros */
    350          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    351          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    352          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    353          
    354          #if _DF1S		/* Code page is DBCS */
    355          
    356          #ifdef _DF2S	/* Two 1st byte areas */
    357          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    358          #else			/* One 1st byte area */
    359          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    360          #endif
    361          
    362          #ifdef _DS3S	/* Three 2nd byte areas */
    363          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    364          #else			/* Two 2nd byte areas */
    365          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    366          #endif
    367          
    368          #else			/* Code page is SBCS */
    369          
    370          #define IsDBCS1(c)	0
    371          #define IsDBCS2(c)	0
    372          
    373          #endif /* _DF1S */
    374          
    375          
    376          /* Name status flags */
    377          #define NS			11		/* Index of name status byte in fn[] */
    378          #define NS_LOSS		0x01	/* Out of 8.3 format */
    379          #define NS_LFN		0x02	/* Force to create LFN entry */
    380          #define NS_LAST		0x04	/* Last segment */
    381          #define NS_BODY		0x08	/* Lower case flag (body) */
    382          #define NS_EXT		0x10	/* Lower case flag (ext) */
    383          #define NS_DOT		0x20	/* Dot entry */
    384          
    385          
    386          /* FAT sub-type boundaries */
    387          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    388          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    389          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    390          
    391          
    392          /* FatFs refers the members in the FAT structures as byte array instead of
    393          / structure member because the structure is not binary compatible between
    394          / different platforms */
    395          
    396          #define BS_jmpBoot			0	/* Jump instruction (3) */
    397          #define BS_OEMName			3	/* OEM name (8) */
    398          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    399          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    400          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    401          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    402          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    403          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    404          #define BPB_Media			21	/* Media descriptor (1) */
    405          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    406          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    407          #define BPB_NumHeads		26	/* Number of heads (2) */
    408          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    409          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    410          #define BS_DrvNum			36	/* Physical drive number (2) */
    411          #define BS_BootSig			38	/* Extended boot signature (1) */
    412          #define BS_VolID			39	/* Volume serial number (4) */
    413          #define BS_VolLab			43	/* Volume label (8) */
    414          #define BS_FilSysType		54	/* File system type (1) */
    415          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    416          #define BPB_ExtFlags		40	/* Extended flags (2) */
    417          #define BPB_FSVer			42	/* File system version (2) */
    418          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    419          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    420          #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
    421          #define BS_DrvNum32			64	/* Physical drive number (2) */
    422          #define BS_BootSig32		66	/* Extended boot signature (1) */
    423          #define BS_VolID32			67	/* Volume serial number (4) */
    424          #define BS_VolLab32			71	/* Volume label (8) */
    425          #define BS_FilSysType32		82	/* File system type (1) */
    426          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    427          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    428          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    429          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    430          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    431          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    432          #define BS_55AA				510	/* Boot sector signature (2) */
    433          
    434          #define	DIR_Name			0	/* Short file name (11) */
    435          #define	DIR_Attr			11	/* Attribute (1) */
    436          #define	DIR_NTres			12	/* NT flag (1) */
    437          #define	DIR_CrtTime			14	/* Created time (2) */
    438          #define	DIR_CrtDate			16	/* Created date (2) */
    439          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    440          #define	DIR_WrtTime			22	/* Modified time (2) */
    441          #define	DIR_WrtDate			24	/* Modified date (2) */
    442          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    443          #define	DIR_FileSize		28	/* File size (4) */
    444          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    445          #define	LDIR_Attr			11	/* LFN attribute (1) */
    446          #define	LDIR_Type			12	/* LFN type (1) */
    447          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    448          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    449          #define	SZ_DIR				32		/* Size of a directory entry */
    450          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    451          #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
    452          #define	NDDE				0x05	/* Replacement of a character collides with DDE */
    453          
    454          
    455          /*------------------------------------------------------------*/
    456          /* Work area                                                  */
    457          
    458          #if _VOLUMES
    459          static

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
    460          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   000000                DS8 4
    461          #else
    462          #error Number of drives must not be 0.
    463          #endif
    464          
    465          static

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
    466          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   000000                DS8 2
    467          
    468          #if _FS_RPATH
    469          static
    470          BYTE CurrVol;			/* Current drive */
    471          #endif
    472          
    473          #if _FS_SHARE
    474          static
    475          FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
    476          #endif
    477          
    478          #if _USE_LFN == 0			/* No LFN */
    479          #define	DEF_NAMEBUF			BYTE sfn[12]
    480          #define INIT_BUF(dobj)		(dobj).fn = sfn
    481          #define	FREE_BUF()
    482          
    483          #elif _USE_LFN == 1			/* LFN with static LFN working buffer */
    484          static WCHAR LfnBuf[_MAX_LFN+1];
    485          #define	DEF_NAMEBUF			BYTE sfn[12]
    486          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    487          #define	FREE_BUF()
    488          
    489          #elif _USE_LFN == 2 		/* LFN with dynamic LFN working buffer on the stack */
    490          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    491          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    492          #define	FREE_BUF()
    493          
    494          #elif _USE_LFN == 3 		/* LFN with dynamic LFN working buffer on the heap */
    495          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    496          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    497          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    498          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    499          #define	FREE_BUF()			ff_memfree(lfn)
    500          
    501          #else
    502          #error Wrong LFN configuration.
    503          #endif
    504          
    505          
    506          
    507          
    508          /*--------------------------------------------------------------------------
    509          
    510             Module Private Functions
    511          
    512          ---------------------------------------------------------------------------*/
    513          
    514          
    515          /*-----------------------------------------------------------------------*/
    516          /* String functions                                                      */
    517          /*-----------------------------------------------------------------------*/
    518          
    519          /* Copy memory to memory */

   \                                 In  segment CODE, align 2
    520          static
    521          void mem_cpy (void* dst, const void* src, UINT cnt) {
   \                     mem_cpy:
    522          	BYTE *d = (BYTE*)dst;
    523          	const BYTE *s = (const BYTE*)src;
   \   000000   0E93         CMP.W   #0x0, R14
   \   000002   0624         JEQ     ??mem_cpy_1
    524          
    525          #if _WORD_ACCESS == 1
    526          	while (cnt >= sizeof(int)) {
    527          		*(int*)d = *(int*)s;
    528          		d += sizeof(int); s += sizeof(int);
    529          		cnt -= sizeof(int);
    530          	}
    531          #endif
    532          	while (cnt--)
    533          		*d++ = *s++;
   \                     ??mem_cpy_0:
   \   000004   FC4D0000     MOV.B   @R13+, 0(R12)
   \   000008   AC000100     ADDA    #0x1, R12
   \   00000C   3E53         ADD.W   #0xffff, R14
   \   00000E   FA23         JNE     ??mem_cpy_0
    534          }
   \                     ??mem_cpy_1:
   \   000010   1001         RETA
    535          
    536          /* Fill memory */
    537          static
    538          void mem_set (void* dst, int val, UINT cnt) {
    539          	BYTE *d = (BYTE*)dst;
    540          
    541          	while (cnt--)
    542          		*d++ = (BYTE)val;
    543          }
    544          
    545          /* Compare memory to memory */

   \                                 In  segment CODE, align 2, keep-with-next
    546          static
    547          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   000000   0A14         PUSHM.A #0x1, R10
    548          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    549          	int r = 0;
   \   000002   0A43         MOV.W   #0x0, R10
    550          
    551          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   000004   0F4E         MOV.W   R14, R15
   \   000006   3E53         ADD.W   #0xffff, R14
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0424         JEQ     ??mem_cmp_1
   \   00000C   7A4C         MOV.B   @R12+, R10
   \   00000E   7F4D         MOV.B   @R13+, R15
   \   000010   0A8F         SUB.W   R15, R10
   \   000012   F827         JEQ     ??mem_cmp_0
    552          	return r;
   \                     ??mem_cmp_1:
   \   000014   0C4A         MOV.W   R10, R12
   \   000016   0A16         POPM.A  #0x1, R10
   \   000018   1001         RETA
    553          }
    554          
    555          /* Check if chr is contained in the string */
    556          static
    557          int chk_chr (const char* str, int chr) {
    558          	while (*str && *str != chr) str++;
    559          	return *str;
    560          }
    561          
    562          
    563          
    564          /*-----------------------------------------------------------------------*/
    565          /* Request/Release grant to access the volume                            */
    566          /*-----------------------------------------------------------------------*/
    567          #if _FS_REENTRANT
    568          
    569          static
    570          int lock_fs (
    571          	FATFS *fs		/* File system object */
    572          )
    573          {
    574          	return ff_req_grant(fs->sobj);
    575          }
    576          
    577          
    578          static
    579          void unlock_fs (
    580          	FATFS *fs,		/* File system object */
    581          	FRESULT res		/* Result code to be returned */
    582          )
    583          {
    584          	if (res != FR_NOT_ENABLED &&
    585          		res != FR_INVALID_DRIVE &&
    586          		res != FR_INVALID_OBJECT &&
    587          		res != FR_TIMEOUT) {
    588          		ff_rel_grant(fs->sobj);
    589          	}
    590          }
    591          #endif
    592          
    593          
    594          
    595          /*-----------------------------------------------------------------------*/
    596          /* File shareing control functions                                       */
    597          /*-----------------------------------------------------------------------*/
    598          #if _FS_SHARE
    599          
    600          static
    601          FRESULT chk_lock (	/* Check if the file can be accessed */
    602          	DIRS* dj,		/* Directory object pointing the file to be checked */
    603          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    604          )
    605          {
    606          	UINT i, be;
    607          
    608          	/* Search file semaphore table */
    609          	for (i = be = 0; i < _FS_SHARE; i++) {
    610          		if (Files[i].fs) {	/* Existing entry */
    611          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    612          				Files[i].clu == dj->sclust &&
    613          				Files[i].idx == dj->index) break;
    614          		} else {			/* Blank entry */
    615          			be++;
    616          		}
    617          	}
    618          	if (i == _FS_SHARE)	/* The file is not opened */
    619          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
    620          
    621          	/* The file has been opened. Reject any open against writing file and all write mode open */
    622          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    623          }
    624          
    625          
    626          static
    627          int enq_lock (	/* Check if an entry is available for a new file */
    628          	FATFS* fs	/* File system object */
    629          )
    630          {
    631          	UINT i;
    632          
    633          	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    634          	return (i == _FS_SHARE) ? 0 : 1;
    635          }
    636          
    637          
    638          static
    639          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    640          	DIRS* dj,	/* Directory object pointing the file to register or increment */
    641          	int acc		/* Desired access mode (0:Read, !0:Write) */
    642          )
    643          {
    644          	UINT i;
    645          
    646          
    647          	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
    648          		if (Files[i].fs == dj->fs &&
    649          			Files[i].clu == dj->sclust &&
    650          			Files[i].idx == dj->index) break;
    651          	}
    652          
    653          	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
    654          		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    655          		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
    656          		Files[i].fs = dj->fs;
    657          		Files[i].clu = dj->sclust;
    658          		Files[i].idx = dj->index;
    659          		Files[i].ctr = 0;
    660          	}
    661          
    662          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    663          
    664          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    665          
    666          	return i + 1;
    667          }
    668          
    669          
    670          static
    671          FRESULT dec_lock (	/* Decrement file open counter */
    672          	UINT i			/* Semaphore index */
    673          )
    674          {
    675          	WORD n;
    676          	FRESULT res;
    677          
    678          
    679          	if (--i < _FS_SHARE) {
    680          		n = Files[i].ctr;
    681          		if (n == 0x100) n = 0;
    682          		if (n) n--;
    683          		Files[i].ctr = n;
    684          		if (!n) Files[i].fs = 0;
    685          		res = FR_OK;
    686          	} else {
    687          		res = FR_INT_ERR;
    688          	}
    689          	return res;
    690          }
    691          
    692          
    693          static
    694          void clear_lock (	/* Clear lock entries of the volume */
    695          	FATFS *fs
    696          )
    697          {
    698          	UINT i;
    699          
    700          	for (i = 0; i < _FS_SHARE; i++) {
    701          		if (Files[i].fs == fs) Files[i].fs = 0;
    702          	}
    703          }
    704          #endif
    705          
    706          
    707          
    708          /*-----------------------------------------------------------------------*/
    709          /* Change window offset                                                  */
    710          /*-----------------------------------------------------------------------*/
    711          

   \                                 In  segment CODE, align 2
    712          static
    713          FRESULT move_window (
   \                     move_window:
    714          	FATFS *fs,		/* File system object */
    715          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    716          )					/* Move to zero only writes back dirty window */
    717          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C60C         MOVA    R12, R6
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
    718          	DWORD wsect;
    719          
    720          
    721          	wsect = fs->winsect;
   \   000008   1A4C2A00     MOV.W   0x2a(R12), R10
   \   00000C   1B4C2C00     MOV.W   0x2c(R12), R11
    722          	if (wsect != sector) {	/* Changed current window */
   \   000010   0A9E         CMP.W   R14, R10
   \   000012   0220         JNE     ??move_window_1
   \   000014   0B9F         CMP.W   R15, R11
   \   000016   4524         JEQ     ??move_window_2
    723          #if !_FS_READONLY
    724          		if (fs->wflag) {	/* Write back dirty window if needed */
   \                     ??move_window_1:
   \   000018   CC930400     CMP.B   #0x0, 0x4(R12)
   \   00001C   2B24         JEQ     ??move_window_3
    725          			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00001E   5312         PUSH.B  #0x1
   \   000020   0E4A         MOV.W   R10, R14
   \   000022   0F4B         MOV.W   R11, R15
   \   000024   CD0C         MOVA    R12, R13
   \   000026   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   00002A   2153         ADD.W   #0x2, SP
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   3320         JNE     ??move_window_4
    726          				return FR_DISK_ERR;
    727          			fs->wflag = 0;
   \   000030   C6430400     MOV.B   #0x0, 0x4(R6)
    728          			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   \   000034   1E461E00     MOV.W   0x1e(R6), R14
   \   000038   1F462000     MOV.W   0x20(R6), R15
   \   00003C   1E561A00     ADD.W   0x1a(R6), R14
   \   000040   1F661C00     ADDC.W  0x1c(R6), R15
   \   000044   0B9F         CMP.W   R15, R11
   \   000046   0328         JNC     ??move_window_5
   \   000048   1520         JNE     ??move_window_3
   \   00004A   0A9E         CMP.W   R14, R10
   \   00004C   132C         JC      ??move_window_3
    729          				BYTE nf;
    730          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   \                     ??move_window_5:
   \   00004E   57460300     MOV.B   0x3(R6), R7
   \   000052   6793         CMP.B   #0x2, R7
   \   000054   0F28         JNC     ??move_window_3
   \   000056   7753         ADD.B   #0xff, R7
    731          					wsect += fs->fsize;
   \                     ??move_window_0:
   \   000058   1A561A00     ADD.W   0x1a(R6), R10
   \   00005C   1B661C00     ADDC.W  0x1c(R6), R11
    732          					disk_write(fs->drv, fs->win, wsect, 1);
   \   000060   5312         PUSH.B  #0x1
   \   000062   0E4A         MOV.W   R10, R14
   \   000064   0F4B         MOV.W   R11, R15
   \   000066   CD06         MOVA    R6, R13
   \   000068   ........     CALLA   #?Subroutine1
    733          				}
   \                     ??CrossCallReturnLabel_0:
   \   00006C   7753         ADD.B   #0xff, R7
   \   00006E   2153         ADD.W   #0x2, SP
   \   000070   4793         CMP.B   #0x0, R7
   \   000072   F223         JNE     ??move_window_0
    734          			}
    735          		}
    736          #endif
    737          		if (sector) {
   \                     ??move_window_3:
   \   000074   0F48         MOV.W   R8, R15
   \   000076   0FD9         BIS.W   R9, R15
   \   000078   0F93         CMP.W   #0x0, R15
   \   00007A   1324         JEQ     ??move_window_2
    738          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00007C   5312         PUSH.B  #0x1
   \   00007E   0E48         MOV.W   R8, R14
   \   000080   0F49         MOV.W   R9, R15
   \   000082   CD06         MOVA    R6, R13
   \   000084   AD002E00     ADDA    #0x2e, R13
   \   000088   5C460100     MOV.B   0x1(R6), R12
   \   00008C   ........     CALLA   #disk_read
   \   000090   2153         ADD.W   #0x2, SP
   \   000092   4C93         CMP.B   #0x0, R12
   \   000094   0224         JEQ     ??move_window_6
    739          				return FR_DISK_ERR;
   \                     ??move_window_4:
   \   000096   5C43         MOV.B   #0x1, R12
   \   000098   053C         JMP     ??move_window_7
    740          			fs->winsect = sector;
   \                     ??move_window_6:
   \   00009A   86482A00     MOV.W   R8, 0x2a(R6)
   \   00009E   86492C00     MOV.W   R9, 0x2c(R6)
    741          		}
    742          	}
    743          
    744          	return FR_OK;
   \                     ??move_window_2:
   \   0000A2   4C43         MOV.B   #0x0, R12
   \                     ??move_window_7:
   \   0000A4   5616         POPM.A  #0x6, R11
   \   0000A6   1001         RETA
    745          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   AD002E00     ADDA    #0x2e, R13
   \   000004   5C460100     MOV.B   0x1(R6), R12
   \   000008   ........     BRA     #disk_write
    746          
    747          
    748          
    749          
    750          /*-----------------------------------------------------------------------*/
    751          /* Clean-up cached data                                                  */
    752          /*-----------------------------------------------------------------------*/
    753          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
    754          static
    755          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
   \                     sync:
    756          	FATFS *fs	/* File system object */
    757          )
    758          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
    759          	FRESULT res;
    760          
    761          
    762          	res = move_window(fs, 0);
   \   000004   0E43         MOV.W   #0x0, R14
   \   000006   0F43         MOV.W   #0x0, R15
   \   000008   ........     CALLA   #move_window
   \   00000C   4B4C         MOV.B   R12, R11
    763          	if (res == FR_OK) {
   \   00000E   4C93         CMP.B   #0x0, R12
   \   000010   6420         JNE     ??sync_1
    764          		/* Update FSInfo sector if needed */
    765          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   000012   FA9003000000 CMP.B   #0x3, 0(R10)
   \   000018   5720         JNE     ??sync_2
   \   00001A   CA930500     CMP.B   #0x0, 0x5(R10)
   \   00001E   5424         JEQ     ??sync_2
    766          			fs->winsect = 0;
   \   000020   8A432A00     MOV.W   #0x0, 0x2a(R10)
   \   000024   8A432C00     MOV.W   #0x0, 0x2c(R10)
    767          			/* Create FSInfo structure */
    768          			mem_set(fs->win, 0, 512);
   \   000028   CF0A         MOVA    R10, R15
   \   00002A   ........     CALLA   #?Subroutine10
    769          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \                     ??CrossCallReturnLabel_10:
   \   00002E   FA4055002C02 MOV.B   #0x55, 0x22c(R10)
   \   000034   FA40AA002D02 MOV.B   #0xaa, 0x22d(R10)
    770          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   00003A   FA4052002E00 MOV.B   #0x52, 0x2e(R10)
   \   000040   FA4052002F00 MOV.B   #0x52, 0x2f(R10)
   \   000046   FA4061003000 MOV.B   #0x61, 0x30(R10)
   \   00004C   FA4041003100 MOV.B   #0x41, 0x31(R10)
    771          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   000052   FA4072001202 MOV.B   #0x72, 0x212(R10)
   \   000058   FA4072001302 MOV.B   #0x72, 0x213(R10)
   \   00005E   FA4041001402 MOV.B   #0x41, 0x214(R10)
   \   000064   FA4061001502 MOV.B   #0x61, 0x215(R10)
    772          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   00006A   CF0A         MOVA    R10, R15
   \   00006C   AF000E00     ADDA    #0xe, R15
   \   000070   EA4F1602     MOV.B   @R15, 0x216(R10)
   \   000074   DA4F01001702 MOV.B   0x1(R15), 0x217(R10)
   \   00007A   5E4F0200     MOV.B   0x2(R15), R14
   \   00007E   CA4E1802     MOV.B   R14, 0x218(R10)
   \   000082   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_14:
   \   000086   CA4E1902     MOV.B   R14, 0x219(R10)
    773          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   00008A   CF0A         MOVA    R10, R15
   \   00008C   AF000A00     ADDA    #0xa, R15
   \   000090   EA4F1A02     MOV.B   @R15, 0x21a(R10)
   \   000094   DA4F01001B02 MOV.B   0x1(R15), 0x21b(R10)
   \   00009A   5E4F0200     MOV.B   0x2(R15), R14
   \   00009E   CA4E1C02     MOV.B   R14, 0x21c(R10)
   \   0000A2   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_15:
   \   0000A6   CA4E1D02     MOV.B   R14, 0x21d(R10)
    774          			/* Write it into the FSInfo sector */
    775          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   0000AA   5312         PUSH.B  #0x1
   \   0000AC   1E4A1200     MOV.W   0x12(R10), R14
   \   0000B0   1F4A1400     MOV.W   0x14(R10), R15
   \   0000B4   CD0A         MOVA    R10, R13
   \   0000B6   AD002E00     ADDA    #0x2e, R13
   \   0000BA   5C4A0100     MOV.B   0x1(R10), R12
   \   0000BE   ........     CALLA   #disk_write
    776          			fs->fsi_flag = 0;
   \   0000C2   CA430500     MOV.B   #0x0, 0x5(R10)
   \   0000C6   2153         ADD.W   #0x2, SP
    777          		}
    778          		/* Make sure that no pending write process in the physical drive */
    779          		if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)0) != RES_OK)
   \                     ??sync_2:
   \   0000C8   4E43         MOVA    #0x0, R14
   \   0000CA   4D43         MOV.B   #0x0, R13
   \   0000CC   5C4A0100     MOV.B   0x1(R10), R12
   \   0000D0   ........     CALLA   #disk_ioctl
   \   0000D4   4C93         CMP.B   #0x0, R12
   \   0000D6   0124         JEQ     ??sync_1
    780          			res = FR_DISK_ERR;
   \   0000D8   5B43         MOV.B   #0x1, R11
    781          	}
    782          
    783          	return res;
   \                     ??sync_1:
   \   0000DA   4C4B         MOV.B   R11, R12
   \   0000DC   1A16         POPM.A  #0x2, R11
   \   0000DE   1001         RETA
    784          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   3E4F         MOV.W   @R15+, R14
   \   000002   3F4F         MOV.W   @R15+, R15
   \   000004   8F10         SWPB    R15
   \   000006   4E4F         MOV.B   R15, R14
   \   000008   1001         RETA
    785          #endif
    786          
    787          
    788          
    789          
    790          /*-----------------------------------------------------------------------*/
    791          /* Get sector# from cluster#                                             */
    792          /*-----------------------------------------------------------------------*/
    793          
    794          

   \                                 In  segment CODE, align 2
    795          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
   \                     clust2sect:
    796          	FATFS *fs,		/* File system object */
    797          	DWORD clst		/* Cluster# to be converted */
    798          )
    799          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
    800          	clst -= 2;
   \   000004   3E50FEFF     ADD.W   #0xfffe, R14
   \   000008   3F63         ADDC.W  #0xffff, R15
    801          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000A   1C4A1600     MOV.W   0x16(R10), R12
   \   00000E   1D4A1800     MOV.W   0x18(R10), R13
   \   000012   3C50FEFF     ADD.W   #0xfffe, R12
   \   000016   3D63         ADDC.W  #0xffff, R13
   \   000018   0F9D         CMP.W   R13, R15
   \   00001A   0628         JNC     ??clust2sect_0
   \   00001C   0220         JNE     ??clust2sect_1
   \   00001E   0E9C         CMP.W   R12, R14
   \   000020   0328         JNC     ??clust2sect_0
   \                     ??clust2sect_1:
   \   000022   0C43         MOV.W   #0x0, R12
   \   000024   0D43         MOV.W   #0x0, R13
   \   000026   0B3C         JMP     ??clust2sect_2
    802          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   000028   0C4E         MOV.W   R14, R12
   \   00002A   0D4F         MOV.W   R15, R13
   \   00002C   5E4A0200     MOV.B   0x2(R10), R14
   \   000030   0F43         MOV.W   #0x0, R15
   \   000032   ........     CALLA   #?Mul32
   \   000036   1C5A2600     ADD.W   0x26(R10), R12
   \   00003A   1D6A2800     ADDC.W  0x28(R10), R13
   \                     ??clust2sect_2:
   \   00003E   0A16         POPM.A  #0x1, R10
   \   000040   1001         RETA
    803          }
    804          
    805          
    806          
    807          
    808          /*-----------------------------------------------------------------------*/
    809          /* FAT access - Read value of a FAT entry                                */
    810          /*-----------------------------------------------------------------------*/
    811          
    812          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   5F03         RRUM.W  #0x1, R15
   \   000002   0B5F         ADD.W   R15, R11
   \   000004   0E4B         MOV.W   R11, R14
   \   000006   8E10         SWPB    R14
   \   000008   7EF3         AND.B   #0xff, R14
   \   00000A   0E11         RRA.W   R14
   \   00000C   0F43         MOV.W   #0x0, R15
   \   00000E   1E5C1E00     ADD.W   0x1e(R12), R14
   \   000012   1F6C2000     ADDC.W  0x20(R12), R15
   \   000016   ....         JMP     ?Subroutine39
   \   000018   0343         NOP

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   0E4B         MOV.W   R11, R14
   \   000002   8E10         SWPB    R14
   \   000004   7EF3         AND.B   #0xff, R14
   \   000006   0E11         RRA.W   R14
   \   000008   0F43         MOV.W   #0x0, R15
   \   00000A   1E5A1E00     ADD.W   0x1e(R10), R14
   \   00000E   1F6A2000     ADDC.W  0x20(R10), R15
   \   000012   CC0A         MOVA    R10, R12
   \   000014   ....         JMP     ?Subroutine39
   \   000016   0343         NOP

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine39:
   \   000000   ........     CALLA   #move_window
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   0D4F         MOV.W   R15, R13
   \   000002   ........     CALLA   #?ShiftRight32u_7
   \   000006   0E4C         MOV.W   R12, R14
   \   000008   0F4D         MOV.W   R13, R15
   \   00000A   1E5A1E00     ADD.W   0x1e(R10), R14
   \   00000E   1F6A2000     ADDC.W  0x20(R10), R15
   \   000012   CC0A         MOVA    R10, R12
   \   000014   ........     BRA     #?Subroutine39

   \                                 In  segment CODE, align 2
    813          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
   \                     get_fat:
    814          	FATFS *fs,	/* File system object */
    815          	DWORD clst	/* Cluster# to get the link information */
    816          )
    817          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
    818          	UINT wc, bc;
    819          	BYTE *p;
    820          
    821          
    822          	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0220         JNE     ??get_fat_2
   \   00000C   2E93         CMP.W   #0x2, R14
   \   00000E   0728         JNC     ??get_fat_0
   \                     ??get_fat_2:
   \   000010   199C1800     CMP.W   0x18(R12), R9
   \   000014   0628         JNC     ??get_fat_3
   \   000016   0320         JNE     ??get_fat_0
   \   000018   189C1600     CMP.W   0x16(R12), R8
   \   00001C   0228         JNC     ??get_fat_3
    823          		return 1;
   \                     ??get_fat_0:
   \   00001E   1C43         MOV.W   #0x1, R12
   \   000020   3B3C         JMP     ??get_fat_1
    824          
    825          	switch (fs->fs_type) {
   \                     ??get_fat_3:
   \   000022   6E4C         MOV.B   @R12, R14
   \   000024   5E83         SUB.B   #0x1, R14
   \   000026   0524         JEQ     ??get_fat_4
   \   000028   5E83         SUB.B   #0x1, R14
   \   00002A   2224         JEQ     ??get_fat_5
   \   00002C   5E83         SUB.B   #0x1, R14
   \   00002E   3624         JEQ     ??get_fat_6
   \   000030   533C         JMP     ??get_fat_7
    826          	case FS_FAT12 :
    827          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_4:
   \   000032   0B48         MOV.W   R8, R11
   \   000034   0F48         MOV.W   R8, R15
   \   000036   ........     CALLA   #?Subroutine7
    828          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \                     ??CrossCallReturnLabel_86:
   \   00003A   4E20         JNE     ??get_fat_7
    829          		wc = fs->win[bc % SS(fs)]; bc++;
   \   00003C   0F4B         MOV.W   R11, R15
   \   00003E   3FF0FF01     AND.W   #0x1ff, R15
   \   000042   CE0A         MOVA    R10, R14
   \   000044   EE0F         ADDA    R15, R14
   \   000046   564E2E00     MOV.B   0x2e(R14), R6
   \   00004A   1B53         ADD.W   #0x1, R11
    830          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   00004C   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_84:
   \   000050   4320         JNE     ??get_fat_7
    831          		wc |= fs->win[bc % SS(fs)] << 8;
   \   000052   3BF0FF01     AND.W   #0x1ff, R11
   \   000056   EA0B         ADDA    R11, R10
   \   000058   5F4A2E00     MOV.B   0x2e(R10), R15
   \   00005C   8F10         SWPB    R15
   \   00005E   06DF         BIS.W   R15, R6
    832          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   \   000060   18B3         BIT.W   #0x1, R8
   \   000062   0228         JNC     ??get_fat_8
   \   000064   560F         RRUM.W  #0x4, R6
   \   000066   023C         JMP     ??get_fat_9
   \                     ??get_fat_8:
   \   000068   36F0FF0F     AND.W   #0xfff, R6
   \                     ??get_fat_9:
   \   00006C   0C46         MOV.W   R6, R12
   \   00006E   143C         JMP     ??get_fat_1
    833          
    834          	case FS_FAT16 :
    835          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   \                     ??get_fat_5:
   \   000070   0E48         MOV.W   R8, R14
   \   000072   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_19:
   \   000076   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_73:
   \   00007A   2E20         JNE     ??get_fat_7
    836          		p = &fs->win[clst * 2 % SS(fs)];
   \   00007C   0858         RLA.W   R8
   \   00007E   38F0FF01     AND.W   #0x1ff, R8
   \   000082   0943         MOV.W   #0x0, R9
   \   000084   1915         PUSHM.W #0x2, R9
   \   000086   0F16         POPM.A  #0x1, R15
   \   000088   EA0F         ADDA    R15, R10
   \   00008A   AA002E00     ADDA    #0x2e, R10
    837          		return LD_WORD(p);
   \   00008E   6F4A         MOV.B   @R10, R15
   \   000090   5C4A0100     MOV.B   0x1(R10), R12
   \   000094   8C10         SWPB    R12
   \   000096   0CDF         BIS.W   R15, R12
   \                     ??get_fat_1:
   \   000098   0D43         MOV.W   #0x0, R13
   \   00009A   203C         JMP     ??get_fat_10
    838          
    839          	case FS_FAT32 :
    840          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   \                     ??get_fat_6:
   \   00009C   0C48         MOV.W   R8, R12
   \   00009E   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_71:
   \   0000A2   1A20         JNE     ??get_fat_7
    841          		p = &fs->win[clst * 4 % SS(fs)];
   \   0000A4   0858         RLA.W   R8
   \   0000A6   0858         RLA.W   R8
   \   0000A8   38F0FF01     AND.W   #0x1ff, R8
   \   0000AC   0943         MOV.W   #0x0, R9
   \   0000AE   1915         PUSHM.W #0x2, R9
   \   0000B0   0F16         POPM.A  #0x1, R15
   \   0000B2   EA0F         ADDA    R15, R10
   \   0000B4   AA002E00     ADDA    #0x2e, R10
    842          		return LD_DWORD(p) & 0x0FFFFFFF;
   \   0000B8   684A         MOV.B   @R10, R8
   \   0000BA   5B4A0100     MOV.B   0x1(R10), R11
   \   0000BE   8B10         SWPB    R11
   \   0000C0   5E4A0200     MOV.B   0x2(R10), R14
   \   0000C4   5C4A0300     MOV.B   0x3(R10), R12
   \   0000C8   8C10         SWPB    R12
   \   0000CA   0D4C         MOV.W   R12, R13
   \   0000CC   0DDE         BIS.W   R14, R13
   \   0000CE   0C4B         MOV.W   R11, R12
   \   0000D0   0CD8         BIS.W   R8, R12
   \   0000D2   3DF0FF0F     AND.W   #0xfff, R13
   \   0000D6   023C         JMP     ??get_fat_10
    843          	}
    844          
    845          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_7:
   \   0000D8   3C43         MOV.W   #0xffff, R12
   \   0000DA   3D43         MOV.W   #0xffff, R13
   \                     ??get_fat_10:
   \   0000DC   5616         POPM.A  #0x6, R11
   \   0000DE   1001         RETA
    846          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine14:
   \   000000   8E10         SWPB    R14
   \   000002   8F10         SWPB    R15
   \   000004   4EEF         XOR.B   R15, R14
   \   000006   0EEF         XOR.W   R15, R14
   \   000008   7FF3         AND.B   #0xff, R15
   \   00000A   1E5C1E00     ADD.W   0x1e(R12), R14
   \   00000E   1F6C2000     ADDC.W  0x20(R12), R15
   \   000012   1001         RETA
    847          
    848          
    849          
    850          
    851          /*-----------------------------------------------------------------------*/
    852          /* FAT access - Change value of a FAT entry                              */
    853          /*-----------------------------------------------------------------------*/
    854          #if !_FS_READONLY
    855          

   \                                 In  segment CODE, align 2
    856          FRESULT put_fat (
   \                     put_fat:
    857          	FATFS *fs,	/* File system object */
    858          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    859          	DWORD val	/* New value to mark the cluster */
    860          )
    861          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   064E         MOV.W   R14, R6
   \   000006   074F         MOV.W   R15, R7
    862          	UINT bc;
    863          	BYTE *p;
    864          	FRESULT res;
    865          
    866          
    867          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0220         JNE     ??put_fat_1
   \   00000C   2E93         CMP.W   #0x2, R14
   \   00000E   0728         JNC     ??put_fat_0
   \                     ??put_fat_1:
   \   000010   179C1800     CMP.W   0x18(R12), R7
   \   000014   0628         JNC     ??put_fat_2
   \   000016   0320         JNE     ??put_fat_0
   \   000018   169C1600     CMP.W   0x16(R12), R6
   \   00001C   0228         JNC     ??put_fat_2
    868          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00001E   6C43         MOV.B   #0x2, R12
   \   000020   763C         JMP     ??put_fat_3
    869          
    870          	} else {
   \                     ??put_fat_2:
   \   000022   18411C00     MOV.W   0x1c(SP), R8
   \   000026   19411E00     MOV.W   0x1e(SP), R9
    871          		switch (fs->fs_type) {
   \   00002A   6E4C         MOV.B   @R12, R14
   \   00002C   5E83         SUB.B   #0x1, R14
   \   00002E   0524         JEQ     ??put_fat_4
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   3524         JEQ     ??put_fat_5
   \   000034   5E83         SUB.B   #0x1, R14
   \   000036   4724         JEQ     ??put_fat_6
   \   000038   673C         JMP     ??put_fat_7
    872          		case FS_FAT12 :
    873          			bc = clst; bc += bc / 2;
   \                     ??put_fat_4:
   \   00003A   0B46         MOV.W   R6, R11
   \   00003C   0F46         MOV.W   R6, R15
   \   00003E   ........     CALLA   #?Subroutine7
    874          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    875          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_87:
   \   000042   6320         JNE     ??put_fat_8
    876          			p = &fs->win[bc % SS(fs)];
   \   000044   0F4B         MOV.W   R11, R15
   \   000046   3FF0FF01     AND.W   #0x1ff, R15
   \   00004A   ........     CALLA   #?Subroutine18
    877          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \                     ??CrossCallReturnLabel_27:
   \   00004E   16B3         BIT.W   #0x1, R6
   \   000050   0828         JNC     ??put_fat_9
   \   000052   4F48         MOV.B   R8, R15
   \   000054                RPT     #0x4
   \   000054   43184F5F     RLAX.B  R15
   \   000058   7D400F00     MOV.B   #0xf, R13
   \   00005C   6DFE         AND.B   @R14, R13
   \   00005E   4DDF         BIS.B   R15, R13
   \   000060   013C         JMP     ??put_fat_10
   \                     ??put_fat_9:
   \   000062   4D48         MOV.B   R8, R13
   \                     ??put_fat_10:
   \   000064   CE4D0000     MOV.B   R13, 0(R14)
    878          			bc++;
   \   000068   1B53         ADD.W   #0x1, R11
    879          			fs->wflag = 1;
   \   00006A   DA430400     MOV.B   #0x1, 0x4(R10)
    880          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00006E   ........     CALLA   #?Subroutine5
    881          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_85:
   \   000072   4B20         JNE     ??put_fat_8
    882          			p = &fs->win[bc % SS(fs)];
   \   000074   3BF0FF01     AND.W   #0x1ff, R11
   \   000078   CE0A         MOVA    R10, R14
   \   00007A   EE0B         ADDA    R11, R14
   \   00007C   AE002E00     ADDA    #0x2e, R14
    883          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   000080   16B3         BIT.W   #0x1, R6
   \   000082   0328         JNC     ??put_fat_11
   \   000084   580F         RRUM.W  #0x4, R8
   \   000086   4F48         MOV.B   R8, R15
   \   000088   073C         JMP     ??put_fat_12
   \                     ??put_fat_11:
   \   00008A   8810         SWPB    R8
   \   00008C   78F00F00     AND.B   #0xf, R8
   \   000090   7F40F000     MOV.B   #0xf0, R15
   \   000094   6FFE         AND.B   @R14, R15
   \   000096   4FD8         BIS.B   R8, R15
   \                     ??put_fat_12:
   \   000098   CE4F0000     MOV.B   R15, 0(R14)
    884          			break;
   \   00009C   363C         JMP     ??put_fat_8
    885          
    886          		case FS_FAT16 :
    887          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_5:
   \   00009E   0E46         MOV.W   R6, R14
   \   0000A0   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_20:
   \   0000A4   ........     CALLA   #?Subroutine39
    888          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_75:
   \   0000A8   3020         JNE     ??put_fat_8
    889          			p = &fs->win[clst * 2 % SS(fs)];
   \   0000AA   0656         RLA.W   R6
   \   0000AC   36F0FF01     AND.W   #0x1ff, R6
   \   0000B0   0743         MOV.W   #0x0, R7
   \   0000B2   1715         PUSHM.W #0x2, R7
   \   0000B4   0F16         POPM.A  #0x1, R15
   \   0000B6   ........     CALLA   #?Subroutine18
    890          			ST_WORD(p, (WORD)val);
   \                     ??CrossCallReturnLabel_28:
   \   0000BA   CE480000     MOV.B   R8, 0(R14)
   \   0000BE   8810         SWPB    R8
   \   0000C0   CE480100     MOV.B   R8, 0x1(R14)
    891          			break;
   \   0000C4   223C         JMP     ??put_fat_8
    892          
    893          		case FS_FAT32 :
    894          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_6:
   \   0000C6   0C46         MOV.W   R6, R12
   \   0000C8   ........     CALLA   #?Subroutine11
    895          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_72:
   \   0000CC   1E20         JNE     ??put_fat_8
    896          			p = &fs->win[clst * 4 % SS(fs)];
   \   0000CE   0656         RLA.W   R6
   \   0000D0   0656         RLA.W   R6
   \   0000D2   36F0FF01     AND.W   #0x1ff, R6
   \   0000D6   0743         MOV.W   #0x0, R7
   \   0000D8   1715         PUSHM.W #0x2, R7
   \   0000DA   0F16         POPM.A  #0x1, R15
   \   0000DC   ........     CALLA   #?Subroutine18
    897          			val |= LD_DWORD(p) & 0xF0000000;
   \                     ??CrossCallReturnLabel_29:
   \   0000E0   564E0300     MOV.B   0x3(R14), R6
   \   0000E4   8610         SWPB    R6
   \   0000E6   0746         MOV.W   R6, R7
   \   0000E8   37F000F0     AND.W   #0xf000, R7
   \   0000EC   09D7         BIS.W   R7, R9
    898          			ST_DWORD(p, val);
   \   0000EE   CE480000     MOV.B   R8, 0(R14)
   \   0000F2   0F48         MOV.W   R8, R15
   \   0000F4   8F10         SWPB    R15
   \   0000F6   CE4F0100     MOV.B   R15, 0x1(R14)
   \   0000FA   CE490200     MOV.B   R9, 0x2(R14)
   \   0000FE   8910         SWPB    R9
   \   000100   4849         MOV.B   R9, R8
   \   000102   CE480300     MOV.B   R8, 0x3(R14)
    899          			break;
   \   000106   013C         JMP     ??put_fat_8
    900          
    901          		default :
    902          			res = FR_INT_ERR;
   \                     ??put_fat_7:
   \   000108   6C43         MOV.B   #0x2, R12
    903          		}
    904          		fs->wflag = 1;
   \                     ??put_fat_8:
   \   00010A   DA430400     MOV.B   #0x1, 0x4(R10)
    905          	}
    906          
    907          	return res;
   \                     ??put_fat_3:
   \   00010E   5616         POPM.A  #0x6, R11
   \   000110   1001         RETA
    908          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine18:
   \   000000   CE0A         MOVA    R10, R14
   \   000002   EE0F         ADDA    R15, R14
   \   000004   AE002E00     ADDA    #0x2e, R14
   \   000008   1001         RETA
    909          #endif /* !_FS_READONLY */
    910          
    911          
    912          
    913          
    914          /*-----------------------------------------------------------------------*/
    915          /* FAT handling - Remove a cluster chain                                 */
    916          /*-----------------------------------------------------------------------*/
    917          #if !_FS_READONLY

   \                                 In  segment CODE, align 2, keep-with-next
    918          static
    919          FRESULT remove_chain (
   \                     remove_chain:
    920          	FATFS *fs,			/* File system object */
    921          	DWORD clst			/* Cluster# to remove a chain from */
    922          )
    923          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
    924          	FRESULT res;
    925          	DWORD nxt;
    926          #if _USE_ERASE
    927          	DWORD scl = clst, ecl = clst, resion[2];
    928          #endif
    929          
    930          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0220         JNE     ??remove_chain_3
   \   00000C   2E93         CMP.W   #0x2, R14
   \   00000E   1328         JNC     ??remove_chain_1
   \                     ??remove_chain_3:
   \   000010   1B9C1800     CMP.W   0x18(R12), R11
   \   000014   0428         JNC     ??remove_chain_4
   \   000016   0F20         JNE     ??remove_chain_1
   \   000018   1A9C1600     CMP.W   0x16(R12), R10
   \   00001C   0C2C         JC      ??remove_chain_1
    931          		res = FR_INT_ERR;
    932          
    933          	} else {
    934          		res = FR_OK;
   \                     ??remove_chain_4:
   \   00001E   4943         MOV.B   #0x0, R9
    935          		while (clst < fs->n_fatent) {			/* Not a last link? */
    936          			nxt = get_fat(fs, clst);			/* Get cluster status */
   \                     ??remove_chain_0:
   \   000020   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_2:
   \   000024   064C         MOV.W   R12, R6
   \   000026   074D         MOV.W   R13, R7
    937          			if (nxt == 0) break;				/* Empty cluster? */
   \   000028   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_66:
   \   00002C   2924         JEQ     ??remove_chain_2
    938          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   \   00002E   1C93         CMP.W   #0x1, R12
   \   000030   0420         JNE     ??remove_chain_5
   \   000032   0D93         CMP.W   #0x0, R13
   \   000034   0220         JNE     ??remove_chain_5
   \                     ??remove_chain_1:
   \   000036   6943         MOV.B   #0x2, R9
   \   000038   233C         JMP     ??remove_chain_2
    939          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   \                     ??remove_chain_5:
   \   00003A   3C93         CMP.W   #0xffff, R12
   \   00003C   0420         JNE     ??remove_chain_6
   \   00003E   3D93         CMP.W   #0xffff, R13
   \   000040   0220         JNE     ??remove_chain_6
   \   000042   5943         MOV.B   #0x1, R9
   \   000044   1D3C         JMP     ??remove_chain_2
    940          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   \                     ??remove_chain_6:
   \   000046   0312         PUSH.W  #0x0
   \   000048   0312         PUSH.W  #0x0
   \   00004A   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   00004E   494C         MOV.B   R12, R9
    941          			if (res != FR_OK) break;
   \   000050   2152         ADD.W   #0x4, SP
   \   000052   4C93         CMP.B   #0x0, R12
   \   000054   1520         JNE     ??remove_chain_2
    942          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \   000056   B8930E00     CMP.W   #0xffff, 0xe(R8)
   \   00005A   0320         JNE     ??remove_chain_7
   \   00005C   B8931000     CMP.W   #0xffff, 0x10(R8)
   \   000060   0624         JEQ     ??remove_chain_8
    943          				fs->free_clust++;
   \                     ??remove_chain_7:
   \   000062   98530E00     ADD.W   #0x1, 0xe(R8)
   \   000066   88631000     ADDC.W  #0x0, 0x10(R8)
    944          				fs->fsi_flag = 1;
   \   00006A   D8430500     MOV.B   #0x1, 0x5(R8)
    945          			}
    946          #if _USE_ERASE
    947          			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
    948          				ecl = nxt;
    949          			} else {				/* End of contiguous clusters */
    950          				resion[0] = clust2sect(fs, scl);					/* Start sector */
    951          				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    952          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
    953          				scl = ecl = nxt;
    954          			}
    955          #endif
    956          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_8:
   \   00006E   0A46         MOV.W   R6, R10
   \   000070   0B47         MOV.W   R7, R11
    957          		}
   \   000072   1B981800     CMP.W   0x18(R8), R11
   \   000076   D42B         JNC     ??remove_chain_0
   \   000078   0320         JNE     ??remove_chain_2
   \   00007A   1A981600     CMP.W   0x16(R8), R10
   \   00007E   D02B         JNC     ??remove_chain_0
    958          	}
    959          
    960          	return res;
   \                     ??remove_chain_2:
   \   000080   4C49         MOV.B   R9, R12
   \   000082   5616         POPM.A  #0x6, R11
   \   000084   1001         RETA
    961          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   0E4A         MOV.W   R10, R14
   \   000002   0F4B         MOV.W   R11, R15
   \   000004   CC08         MOVA    R8, R12
   \   000006   ........     BRA     #put_fat

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   0E4A         MOV.W   R10, R14
   \   000002   0F4B         MOV.W   R11, R15
   \   000004   CC08         MOVA    R8, R12
   \   000006   ........     BRA     #get_fat

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine38:
   \   000000   0F4C         MOV.W   R12, R15
   \   000002   0FDD         BIS.W   R13, R15
   \   000004   0F93         CMP.W   #0x0, R15
   \   000006   1001         RETA
    962          #endif
    963          
    964          
    965          
    966          
    967          /*-----------------------------------------------------------------------*/
    968          /* FAT handling - Stretch or Create a cluster chain                      */
    969          /*-----------------------------------------------------------------------*/
    970          #if !_FS_READONLY

   \                                 In  segment CODE, align 2, keep-with-next
    971          static
    972          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   \                     create_chain:
    973          	FATFS *fs,			/* File system object */
    974          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    975          )
    976          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   044E         MOV.W   R14, R4
   \   000006   054F         MOV.W   R15, R5
    977          	DWORD cs, ncl, scl;
    978          	FRESULT res;
    979          
    980          
    981          	if (clst == 0) {		/* Create a new chain */
   \   000008   0F4E         MOV.W   R14, R15
   \   00000A   0FD5         BIS.W   R5, R15
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   1220         JNE     ??create_chain_8
    982          		scl = fs->last_clust;			/* Get suggested start point */
   \   000010   164C0A00     MOV.W   0xa(R12), R6
   \   000014   174C0C00     MOV.W   0xc(R12), R7
    983          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   000018   0F46         MOV.W   R6, R15
   \   00001A   0FD7         BIS.W   R7, R15
   \   00001C   0F93         CMP.W   #0x0, R15
   \   00001E   0724         JEQ     ??create_chain_1
   \   000020   179C1800     CMP.W   0x18(R12), R7
   \   000024   1928         JNC     ??create_chain_9
   \   000026   0320         JNE     ??create_chain_1
   \   000028   169C1600     CMP.W   0x16(R12), R6
   \   00002C   1528         JNC     ??create_chain_9
   \                     ??create_chain_1:
   \   00002E   1643         MOV.W   #0x1, R6
   \   000030   0743         MOV.W   #0x0, R7
   \   000032   123C         JMP     ??create_chain_9
    984          	}
    985          	else {					/* Stretch the current chain */
    986          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_8:
   \   000034   0F45         MOV.W   R5, R15
   \   000036   ........     CALLA   #get_fat
    987          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   00003A   0D93         CMP.W   #0x0, R13
   \   00003C   0420         JNE     ??create_chain_10
   \   00003E   2C93         CMP.W   #0x2, R12
   \   000040   022C         JC      ??create_chain_10
   \   000042   1C43         MOV.W   #0x1, R12
   \   000044   533C         JMP     ??create_chain_11
    988          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_10:
   \   000046   1D981800     CMP.W   0x18(R8), R13
   \   00004A   5B28         JNC     ??create_chain_6
   \   00004C   0320         JNE     ??create_chain_12
   \   00004E   1C981600     CMP.W   0x16(R8), R12
   \   000052   5728         JNC     ??create_chain_6
    989          		scl = clst;
   \                     ??create_chain_12:
   \   000054   0644         MOV.W   R4, R6
   \   000056   0745         MOV.W   R5, R7
    990          	}
    991          
    992          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_9:
   \   000058   0A46         MOV.W   R6, R10
   \   00005A   0B47         MOV.W   R7, R11
    993          	for (;;) {
    994          		ncl++;							/* Next cluster */
   \                     ??create_chain_0:
   \   00005C   1A53         ADD.W   #0x1, R10
   \   00005E   0B63         ADDC.W  #0x0, R11
    995          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   000060   1B981800     CMP.W   0x18(R8), R11
   \   000064   0A28         JNC     ??create_chain_2
   \   000066   0320         JNE     ??create_chain_13
   \   000068   1A981600     CMP.W   0x16(R8), R10
   \   00006C   0628         JNC     ??create_chain_2
    996          			ncl = 2;
   \                     ??create_chain_13:
   \   00006E   2A43         MOV.W   #0x2, R10
   \   000070   0B43         MOV.W   #0x0, R11
    997          			if (ncl > scl) return 0;	/* No free cluster */
   \   000072   0793         CMP.W   #0x0, R7
   \   000074   0220         JNE     ??create_chain_2
   \   000076   2693         CMP.W   #0x2, R6
   \   000078   3828         JNC     ??create_chain_4
    998          		}
    999          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_2:
   \   00007A   ........     CALLA   #?Subroutine2
   1000          		if (cs == 0) break;				/* Found a free cluster */
   \                     ??CrossCallReturnLabel_3:
   \   00007E   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_63:
   \   000082   2720         JNE     ??create_chain_14
   1001          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1002          			return cs;
   1003          		if (ncl == scl) return 0;		/* No free cluster */
   1004          	}
   1005          
   1006          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   000084   3012FF0F     PUSH.W  #0xfff
   \   000088   3312         PUSH.W  #0xffff
   \   00008A   ........     CALLA   #?Subroutine3
   1007          	if (res == FR_OK && clst != 0) {
   \                     ??CrossCallReturnLabel_5:
   \   00008E   2152         ADD.W   #0x4, SP
   \   000090   4C93         CMP.B   #0x0, R12
   \   000092   0C20         JNE     ??create_chain_15
   \   000094   0F44         MOV.W   R4, R15
   \   000096   0FD5         BIS.W   R5, R15
   \   000098   0F93         CMP.W   #0x0, R15
   \   00009A   0A24         JEQ     ??create_chain_16
   1008          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00009C   0B12         PUSH.W  R11
   \   00009E   0A12         PUSH.W  R10
   \   0000A0   0E44         MOV.W   R4, R14
   \   0000A2   0F45         MOV.W   R5, R15
   \   0000A4   CC08         MOVA    R8, R12
   \   0000A6   ........     CALLA   #put_fat
   \   0000AA   2152         ADD.W   #0x4, SP
   1009          	}
   1010          	if (res == FR_OK) {
   \                     ??create_chain_15:
   \   0000AC   4C93         CMP.B   #0x0, R12
   \   0000AE   2020         JNE     ??create_chain_17
   1011          		fs->last_clust = ncl;			/* Update FSINFO */
   \                     ??create_chain_16:
   \   0000B0   884A0A00     MOV.W   R10, 0xa(R8)
   \   0000B4   884B0C00     MOV.W   R11, 0xc(R8)
   1012          		if (fs->free_clust != 0xFFFFFFFF) {
   \   0000B8   B8930E00     CMP.W   #0xffff, 0xe(R8)
   \   0000BC   0320         JNE     ??create_chain_18
   \   0000BE   B8931000     CMP.W   #0xffff, 0x10(R8)
   \   0000C2   1D24         JEQ     ??create_chain_5
   1013          			fs->free_clust--;
   \                     ??create_chain_18:
   \   0000C4   B8530E00     ADD.W   #0xffff, 0xe(R8)
   \   0000C8   B8631000     ADDC.W  #0xffff, 0x10(R8)
   1014          			fs->fsi_flag = 1;
   \   0000CC   D8430500     MOV.B   #0x1, 0x5(R8)
   \   0000D0   163C         JMP     ??create_chain_5
   1015          		}
   1016          	} else {
   \                     ??create_chain_14:
   \   0000D2   3C93         CMP.W   #0xffff, R12
   \   0000D4   0220         JNE     ??create_chain_19
   \   0000D6   3D93         CMP.W   #0xffff, R13
   \   0000D8   1424         JEQ     ??create_chain_6
   \                     ??create_chain_19:
   \   0000DA   1C93         CMP.W   #0x1, R12
   \   0000DC   0220         JNE     ??create_chain_7
   \   0000DE   0D93         CMP.W   #0x0, R13
   \   0000E0   1024         JEQ     ??create_chain_6
   \                     ??create_chain_7:
   \   0000E2   0A96         CMP.W   R6, R10
   \   0000E4   BB23         JNE     ??create_chain_0
   \   0000E6   0B97         CMP.W   R7, R11
   \   0000E8   B923         JNE     ??create_chain_0
   \                     ??create_chain_4:
   \   0000EA   0C43         MOV.W   #0x0, R12
   \                     ??create_chain_11:
   \   0000EC   0D43         MOV.W   #0x0, R13
   \   0000EE   093C         JMP     ??create_chain_6
   1017          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_17:
   \   0000F0   5C93         CMP.B   #0x1, R12
   \   0000F2   0324         JEQ     ??create_chain_20
   \   0000F4   1A43         MOV.W   #0x1, R10
   \   0000F6   0B43         MOV.W   #0x0, R11
   \   0000F8   023C         JMP     ??create_chain_5
   \                     ??create_chain_20:
   \   0000FA   3A43         MOV.W   #0xffff, R10
   \   0000FC   3B43         MOV.W   #0xffff, R11
   1018          	}
   1019          
   1020          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_5:
   \   0000FE   0C4A         MOV.W   R10, R12
   \   000100   0D4B         MOV.W   R11, R13
   \                     ??create_chain_6:
   \   000102   7416         POPM.A  #0x8, R11
   \   000104   1001         RETA
   1021          }
   1022          #endif /* !_FS_READONLY */
   1023          
   1024          
   1025          
   1026          /*-----------------------------------------------------------------------*/
   1027          /* FAT handling - Convert offset into cluster with link map table        */
   1028          /*-----------------------------------------------------------------------*/
   1029          
   1030          #if _USE_FASTSEEK
   1031          static
   1032          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1033          	FIL* fp,		/* Pointer to the file object */
   1034          	DWORD ofs		/* File offset to be converted to cluster# */
   1035          )
   1036          {
   1037          	DWORD cl, ncl, *tbl;
   1038          
   1039          
   1040          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1041          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1042          	for (;;) {
   1043          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1044          		if (!ncl) return 0;		/* End of table? (error) */
   1045          		if (cl < ncl) break;	/* In this fragment? */
   1046          		cl -= ncl; tbl++;		/* Next fragment */
   1047          	}
   1048          	return cl + *tbl;	/* Return the cluster number */
   1049          }
   1050          #endif	/* _USE_FASTSEEK */
   1051          
   1052          
   1053          
   1054          /*-----------------------------------------------------------------------*/
   1055          /* Directory handling - Set directory index                              */
   1056          /*-----------------------------------------------------------------------*/
   1057          

   \                                 In  segment CODE, align 2
   1058          static
   1059          FRESULT dir_sdi (
   \                     dir_sdi:
   1060          	DIRS *dj,		/* Pointer to directory object */
   1061          	WORD idx		/* Directory index number */
   1062          )
   1063          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   1064          	DWORD clst;
   1065          	WORD ic;
   1066          
   1067          
   1068          	dj->index = idx;
   \   000006   8C4B0600     MOV.W   R11, 0x6(R12)
   1069          	clst = dj->sclust;
   \   00000A   1E4C0800     MOV.W   0x8(R12), R14
   \   00000E   1F4C0A00     MOV.W   0xa(R12), R15
   1070          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   000012   1E93         CMP.W   #0x1, R14
   \   000014   0220         JNE     ??dir_sdi_2
   \   000016   0F93         CMP.W   #0x0, R15
   \   000018   4324         JEQ     ??dir_sdi_1
   \                     ??dir_sdi_2:
   \   00001A   080C         MOVA    @R12, R8
   \   00001C   1F981800     CMP.W   0x18(R8), R15
   \   000020   0428         JNC     ??dir_sdi_3
   \   000022   3E20         JNE     ??dir_sdi_1
   \   000024   1E981600     CMP.W   0x16(R8), R14
   \   000028   3B2C         JC      ??dir_sdi_1
   1071          		return FR_INT_ERR;
   1072          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_3:
   \   00002A   ........     CALLA   #??Subroutine19_0
   \                     ??CrossCallReturnLabel_103:
   \   00002E   0820         JNE     ??dir_sdi_4
   \   000030   F89003000000 CMP.B   #0x3, 0(R8)
   \   000036   0720         JNE     ??dir_sdi_5
   1073          		clst = dj->fs->dirbase;
   \   000038   1E482200     MOV.W   0x22(R8), R14
   \   00003C   1F482400     MOV.W   0x24(R8), R15
   1074          
   1075          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_4:
   \   000040   ........     CALLA   #??Subroutine19_0
   \                     ??CrossCallReturnLabel_104:
   \   000044   0F20         JNE     ??dir_sdi_6
   1076          		dj->clust = clst;
   \                     ??dir_sdi_5:
   \   000046   8C430C00     MOV.W   #0x0, 0xc(R12)
   \   00004A   8C430E00     MOV.W   #0x0, 0xe(R12)
   1077          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00004E   1B980800     CMP.W   0x8(R8), R11
   \   000052   262C         JC      ??dir_sdi_1
   1078          			return FR_INT_ERR;
   1079          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   000054   0C4B         MOV.W   R11, R12
   \   000056   5C0F         RRUM.W  #0x4, R12
   \   000058   0D43         MOV.W   #0x0, R13
   \   00005A   1C582200     ADD.W   0x22(R8), R12
   \   00005E   1D682400     ADDC.W  0x24(R8), R13
   \   000062   2A3C         JMP     ??dir_sdi_7
   1080          	}
   1081          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1082          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_6:
   \   000064   58480200     MOV.B   0x2(R8), R8
   \   000068   580E         RLAM.W  #0x4, R8
   \   00006A   013C         JMP     ??dir_sdi_8
   1083          		while (idx >= ic) {	/* Follow cluster chain */
   1084          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1085          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1086          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1087          				return FR_INT_ERR;
   1088          			idx -= ic;
   \                     ??dir_sdi_0:
   \   00006C   0B88         SUB.W   R8, R11
   \                     ??dir_sdi_8:
   \   00006E   0C0A         MOVA    @R10, R12
   \   000070   0B98         CMP.W   R8, R11
   \   000072   1828         JNC     ??dir_sdi_9
   \   000074   ........     CALLA   #get_fat
   \   000078   0E4C         MOV.W   R12, R14
   \   00007A   0F4D         MOV.W   R13, R15
   \   00007C   3C93         CMP.W   #0xffff, R12
   \   00007E   0420         JNE     ??dir_sdi_10
   \   000080   3D93         CMP.W   #0xffff, R13
   \   000082   0220         JNE     ??dir_sdi_10
   \   000084   5C43         MOV.B   #0x1, R12
   \   000086   273C         JMP     ??dir_sdi_11
   \                     ??dir_sdi_10:
   \   000088   0D93         CMP.W   #0x0, R13
   \   00008A   0220         JNE     ??dir_sdi_12
   \   00008C   2C93         CMP.W   #0x2, R12
   \   00008E   0828         JNC     ??dir_sdi_1
   \                     ??dir_sdi_12:
   \   000090   0D0A         MOVA    @R10, R13
   \   000092   1F9D1800     CMP.W   0x18(R13), R15
   \   000096   EA2B         JNC     ??dir_sdi_0
   \   000098   0320         JNE     ??dir_sdi_1
   \   00009A   1E9D1600     CMP.W   0x16(R13), R14
   \   00009E   E62B         JNC     ??dir_sdi_0
   \                     ??dir_sdi_1:
   \   0000A0   6C43         MOV.B   #0x2, R12
   \   0000A2   193C         JMP     ??dir_sdi_11
   1089          		}
   1090          		dj->clust = clst;
   \                     ??dir_sdi_9:
   \   0000A4   8A4E0C00     MOV.W   R14, 0xc(R10)
   \   0000A8   8A4F0E00     MOV.W   R15, 0xe(R10)
   1091          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   0000AC   ........     CALLA   #clust2sect
   \   0000B0   0E4B         MOV.W   R11, R14
   \   0000B2   5E0F         RRUM.W  #0x4, R14
   \   0000B4   0C5E         ADD.W   R14, R12
   \   0000B6   0D63         ADDC.W  #0x0, R13
   \                     ??dir_sdi_7:
   \   0000B8   8A4C1000     MOV.W   R12, 0x10(R10)
   \   0000BC   8A4D1200     MOV.W   R13, 0x12(R10)
   1092          	}
   1093          
   1094          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \   0000C0   0F0A         MOVA    @R10, R15
   \   0000C2   3BF00F00     AND.W   #0xf, R11
   \   0000C6                RPT     #0x5
   \   0000C6   44180B5B     RLAX.W  R11
   \   0000CA   EF0B         ADDA    R11, R15
   \   0000CC   AF002E00     ADDA    #0x2e, R15
   \   0000D0   7A0F1400     MOVA    R15, 0x14(R10)
   1095          
   1096          	return FR_OK;	/* Seek succeeded */
   \   0000D4   4C43         MOV.B   #0x0, R12
   \                     ??dir_sdi_11:
   \   0000D6   3816         POPM.A  #0x4, R11
   \   0000D8   1001         RETA
   1097          }

   \                                 In  segment CODE, align 2
   \                     ??Subroutine19_0:
   \   000000   0D4E         MOV.W   R14, R13
   \   000002   0DDF         BIS.W   R15, R13
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1001         RETA
   1098          
   1099          
   1100          
   1101          
   1102          /*-----------------------------------------------------------------------*/
   1103          /* Directory handling - Move directory index next                        */
   1104          /*-----------------------------------------------------------------------*/
   1105          

   \                                 In  segment CODE, align 2, keep-with-next
   1106          static
   1107          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   \                     dir_next:
   1108          	DIRS *dj,		/* Pointer to directory object */
   1109          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1110          )
   1111          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   064D         MOV.W   R13, R6
   1112          	DWORD clst;
   1113          	WORD i;
   1114          
   1115          
   1116          	i = dj->index + 1;
   \   000006   194C0600     MOV.W   0x6(R12), R9
   \   00000A   1953         ADD.W   #0x1, R9
   1117          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   00000C   3724         JEQ     ??dir_next_3
   \   00000E   1F4C1000     MOV.W   0x10(R12), R15
   \   000012   1FDC1200     BIS.W   0x12(R12), R15
   \   000016   0F93         CMP.W   #0x0, R15
   \   000018   3124         JEQ     ??dir_next_3
   1118          		return FR_NO_FILE;
   1119          
   1120          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \   00001A   79B00F00     BIT.B   #0xf, R9
   \   00001E   7320         JNE     ??dir_next_4
   1121          		dj->sect++;					/* Next sector */
   \   000020   9C531000     ADD.W   #0x1, 0x10(R12)
   \   000024   8C631200     ADDC.W  #0x0, 0x12(R12)
   1122          
   1123          		if (dj->clust == 0) {	/* Static table */
   \   000028   1E4C0C00     MOV.W   0xc(R12), R14
   \   00002C   1F4C0E00     MOV.W   0xe(R12), R15
   \   000030   0C08         MOVA    @R8, R12
   \   000032   0B4E         MOV.W   R14, R11
   \   000034   0BDF         BIS.W   R15, R11
   \   000036   0B93         CMP.W   #0x0, R11
   \   000038   0420         JNE     ??dir_next_5
   1124          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00003A   199C0800     CMP.W   0x8(R12), R9
   \   00003E   6328         JNC     ??dir_next_4
   \   000040   1D3C         JMP     ??dir_next_3
   1125          				return FR_NO_FILE;
   1126          		}
   1127          		else {					/* Dynamic table */
   1128          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_5:
   \   000042   0D49         MOV.W   R9, R13
   \   000044   5D0F         RRUM.W  #0x4, R13
   \   000046   5B4C0200     MOV.B   0x2(R12), R11
   \   00004A   3B53         ADD.W   #0xffff, R11
   \   00004C   0DBB         BIT.W   R11, R13
   \   00004E   5B20         JNE     ??dir_next_4
   1129          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   000050   ........     CALLA   #get_fat
   \   000054   0A4C         MOV.W   R12, R10
   \   000056   0B4D         MOV.W   R13, R11
   1130          				if (clst <= 1) return FR_INT_ERR;
   \   000058   0D93         CMP.W   #0x0, R13
   \   00005A   0220         JNE     ??dir_next_6
   \   00005C   2C93         CMP.W   #0x2, R12
   \   00005E   1E28         JNC     ??dir_next_2
   1131          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_6:
   \   000060   3C93         CMP.W   #0xffff, R12
   \   000062   0220         JNE     ??dir_next_7
   \   000064   3D93         CMP.W   #0xffff, R13
   \   000066   3E24         JEQ     ??dir_next_8
   1132          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \                     ??dir_next_7:
   \   000068   0C08         MOVA    @R8, R12
   \   00006A   1B9C1800     CMP.W   0x18(R12), R11
   \   00006E   4128         JNC     ??dir_next_9
   \   000070   0320         JNE     ??dir_next_10
   \   000072   1A9C1600     CMP.W   0x16(R12), R10
   \   000076   3D28         JNC     ??dir_next_9
   1133          #if !_FS_READONLY
   1134          					BYTE c;
   1135          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \                     ??dir_next_10:
   \   000078   0693         CMP.W   #0x0, R6
   \   00007A   0220         JNE     ??dir_next_11
   \                     ??dir_next_3:
   \   00007C   6C42         MOV.B   #0x4, R12
   \   00007E   503C         JMP     ??dir_next_12
   1136          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_11:
   \   000080   1E480C00     MOV.W   0xc(R8), R14
   \   000084   1F480E00     MOV.W   0xe(R8), R15
   \   000088   ........     CALLA   #?Subroutine24
   1137          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \                     ??CrossCallReturnLabel_61:
   \   00008C   0320         JNE     ??dir_next_13
   \   00008E   7C400700     MOV.B   #0x7, R12
   \   000092   463C         JMP     ??dir_next_12
   1138          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_13:
   \   000094   1C93         CMP.W   #0x1, R12
   \   000096   0420         JNE     ??dir_next_14
   \   000098   0D93         CMP.W   #0x0, R13
   \   00009A   0220         JNE     ??dir_next_14
   \                     ??dir_next_2:
   \   00009C   6C43         MOV.B   #0x2, R12
   \   00009E   403C         JMP     ??dir_next_12
   1139          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_14:
   \   0000A0   3C93         CMP.W   #0xffff, R12
   \   0000A2   0220         JNE     ??dir_next_15
   \   0000A4   3D93         CMP.W   #0xffff, R13
   \   0000A6   1E24         JEQ     ??dir_next_8
   1140          					/* Clean-up stretched table */
   1141          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_15:
   \   0000A8   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_82:
   \   0000AC   1B20         JNE     ??dir_next_8
   1142          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \   0000AE   0F08         MOVA    @R8, R15
   \   0000B0   ........     CALLA   #?Subroutine10
   1143          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \                     ??CrossCallReturnLabel_11:
   \   0000B4   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_7:
   \   0000B8   0F08         MOVA    @R8, R15
   \   0000BA   8F4C2A00     MOV.W   R12, 0x2a(R15)
   \   0000BE   8F4D2C00     MOV.W   R13, 0x2c(R15)
   1144          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   0000C2   4643         MOV.B   #0x0, R6
   \   0000C4   063C         JMP     ??dir_next_16
   1145          						dj->fs->wflag = 1;
   1146          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1147          						dj->fs->winsect++;
   \                     ??dir_next_1:
   \   0000C6   0F08         MOVA    @R8, R15
   \   0000C8   9F532A00     ADD.W   #0x1, 0x2a(R15)
   \   0000CC   8F632C00     ADDC.W  #0x0, 0x2c(R15)
   \   0000D0   5653         ADD.B   #0x1, R6
   \                     ??dir_next_16:
   \   0000D2   0D08         MOVA    @R8, R13
   \   0000D4   569D0200     CMP.B   0x2(R13), R6
   \   0000D8   072C         JC      ??dir_next_17
   \   0000DA   DD430400     MOV.B   #0x1, 0x4(R13)
   \   0000DE   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_83:
   \   0000E2   F127         JEQ     ??dir_next_1
   \                     ??dir_next_8:
   \   0000E4   5C43         MOV.B   #0x1, R12
   \   0000E6   1C3C         JMP     ??dir_next_12
   1148          					}
   1149          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_17:
   \   0000E8   0E46         MOV.W   R6, R14
   \   0000EA   8D8E2A00     SUB.W   R14, 0x2a(R13)
   \   0000EE   8D732C00     SUBC.W  #0x0, 0x2c(R13)
   1150          #else
   1151          					return FR_NO_FILE;			/* Report EOT */
   1152          #endif
   1153          				}
   1154          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_9:
   \   0000F2   884A0C00     MOV.W   R10, 0xc(R8)
   \   0000F6   884B0E00     MOV.W   R11, 0xe(R8)
   1155          				dj->sect = clust2sect(dj->fs, clst);
   \   0000FA   ........     CALLA   #?Subroutine4
   1156          			}
   1157          		}
   1158          	}
   \                     ??CrossCallReturnLabel_6:
   \   0000FE   884C1000     MOV.W   R12, 0x10(R8)
   \   000102   884D1200     MOV.W   R13, 0x12(R8)
   1159          
   1160          	dj->index = i;
   \                     ??dir_next_4:
   \   000106   88490600     MOV.W   R9, 0x6(R8)
   1161          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   00010A   0F08         MOVA    @R8, R15
   \   00010C   39F00F00     AND.W   #0xf, R9
   \   000110                RPT     #0x5
   \   000110   44180959     RLAX.W  R9
   \   000114   EF09         ADDA    R9, R15
   \   000116   AF002E00     ADDA    #0x2e, R15
   \   00011A   780F1400     MOVA    R15, 0x14(R8)
   1162          
   1163          	return FR_OK;
   \   00011E   4C43         MOV.B   #0x0, R12
   \                     ??dir_next_12:
   \   000120   5616         POPM.A  #0x6, R11
   \   000122   1001         RETA
   1164          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   0E43         MOV.W   #0x0, R14
   \   000002   0F43         MOV.W   #0x0, R15
   \   000004   0C08         MOVA    @R8, R12
   \   000006                REQUIRE ?Subroutine39
   \   000006                // Fall through to label ?Subroutine39

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   0E4A         MOV.W   R10, R14
   \   000002   0F4B         MOV.W   R11, R15
   \   000004   0C08         MOVA    @R8, R12
   \   000006   ........     BRA     #clust2sect

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine24:
   \   000000   ........     CALLA   #create_chain
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   \   000008                REQUIRE ?Subroutine38
   \   000008                // Fall through to label ?Subroutine38
   1165          
   1166          
   1167          
   1168          
   1169          /*-----------------------------------------------------------------------*/
   1170          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1171          /*-----------------------------------------------------------------------*/
   1172          #if _USE_LFN
   1173          static
   1174          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   1175          
   1176          
   1177          static
   1178          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1179          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1180          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1181          )
   1182          {
   1183          	UINT i, s;
   1184          	WCHAR wc, uc;
   1185          
   1186          
   1187          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   1188          	s = 0; wc = 1;
   1189          	do {
   1190          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   1191          		if (wc) {	/* Last char has not been processed */
   1192          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   1193          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1194          				return 0;				/* Not matched */
   1195          		} else {
   1196          			if (uc != 0xFFFF) return 0;	/* Check filler */
   1197          		}
   1198          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   1199          
   1200          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1201          		return 0;
   1202          
   1203          	return 1;						/* The part of LFN matched */
   1204          }
   1205          
   1206          
   1207          
   1208          static
   1209          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1210          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1211          	BYTE *dir			/* Pointer to the directory entry */
   1212          )
   1213          {
   1214          	UINT i, s;
   1215          	WCHAR wc, uc;
   1216          
   1217          
   1218          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1219          
   1220          	s = 0; wc = 1;
   1221          	do {
   1222          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   1223          		if (wc) {	/* Last char has not been processed */
   1224          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1225          			lfnbuf[i++] = wc = uc;			/* Store it */
   1226          		} else {
   1227          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1228          		}
   1229          	} while (++s < 13);						/* Read all character in the entry */
   1230          
   1231          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   1232          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1233          		lfnbuf[i] = 0;
   1234          	}
   1235          
   1236          	return 1;
   1237          }
   1238          
   1239          
   1240          #if !_FS_READONLY
   1241          static
   1242          void fit_lfn (
   1243          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1244          	BYTE *dir,				/* Pointer to the directory entry */
   1245          	BYTE ord,				/* LFN order (1-20) */
   1246          	BYTE sum				/* SFN sum */
   1247          )
   1248          {
   1249          	UINT i, s;
   1250          	WCHAR wc;
   1251          
   1252          
   1253          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1254          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1255          	dir[LDIR_Type] = 0;
   1256          	ST_WORD(dir+LDIR_FstClusLO, 0);
   1257          
   1258          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   1259          	s = wc = 0;
   1260          	do {
   1261          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   1262          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1263          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   1264          	} while (++s < 13);
   1265          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   1266          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1267          }
   1268          
   1269          #endif
   1270          #endif
   1271          
   1272          
   1273          
   1274          /*-----------------------------------------------------------------------*/
   1275          /* Create numbered name                                                  */
   1276          /*-----------------------------------------------------------------------*/
   1277          #if _USE_LFN
   1278          void gen_numname (
   1279          	BYTE *dst,			/* Pointer to generated SFN */
   1280          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1281          	const WCHAR *lfn,	/* Pointer to LFN */
   1282          	WORD seq			/* Sequence number */
   1283          )
   1284          {
   1285          	BYTE ns[8], c;
   1286          	UINT i, j;
   1287          
   1288          
   1289          	mem_cpy(dst, src, 11);
   1290          
   1291          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   1292          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   1293          	}
   1294          
   1295          	/* itoa (hexdecimal) */
   1296          	i = 7;
   1297          	do {
   1298          		c = (seq % 16) + '0';
   1299          		if (c > '9') c += 7;
   1300          		ns[i--] = c;
   1301          		seq /= 16;
   1302          	} while (seq);
   1303          	ns[i] = '~';
   1304          
   1305          	/* Append the number */
   1306          	for (j = 0; j < i && dst[j] != ' '; j++) {
   1307          		if (IsDBCS1(dst[j])) {
   1308          			if (j == i - 1) break;
   1309          			j++;
   1310          		}
   1311          	}
   1312          	do {
   1313          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1314          	} while (j < 8);
   1315          }
   1316          #endif
   1317          
   1318          
   1319          
   1320          
   1321          /*-----------------------------------------------------------------------*/
   1322          /* Calculate sum of an SFN                                               */
   1323          /*-----------------------------------------------------------------------*/
   1324          #if _USE_LFN
   1325          static
   1326          BYTE sum_sfn (
   1327          	const BYTE *dir		/* Ptr to directory entry */
   1328          )
   1329          {
   1330          	BYTE sum = 0;
   1331          	UINT n = 11;
   1332          
   1333          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1334          	return sum;
   1335          }
   1336          #endif
   1337          
   1338          
   1339          
   1340          
   1341          /*-----------------------------------------------------------------------*/
   1342          /* Directory handling - Find an object in the directory                  */
   1343          /*-----------------------------------------------------------------------*/
   1344          

   \                                 In  segment CODE, align 2, keep-with-next
   1345          static
   1346          FRESULT dir_find (
   \                     dir_find:
   1347          	DIRS *dj			/* Pointer to the directory object linked to the file name */
   1348          )
   1349          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CB0C         MOVA    R12, R11
   1350          	FRESULT res;
   1351          	BYTE c, *dir;
   1352          #if _USE_LFN
   1353          	BYTE a, ord, sum;
   1354          #endif
   1355          
   1356          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   ........     CALLA   #dir_sdi
   \   00000A   4A4C         MOV.B   R12, R10
   1357          	if (res != FR_OK) return res;
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   2320         JNE     ??dir_find_1
   1358          
   1359          #if _USE_LFN
   1360          	ord = sum = 0xFF;
   1361          #endif
   1362          	do {
   1363          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_0:
   \   000010   1E4B1000     MOV.W   0x10(R11), R14
   \   000014   1F4B1200     MOV.W   0x12(R11), R15
   \   000018   0C0B         MOVA    @R11, R12
   \   00001A   ........     CALLA   #move_window
   \   00001E   4A4C         MOV.B   R12, R10
   1364          		if (res != FR_OK) break;
   \   000020   4C93         CMP.B   #0x0, R12
   \   000022   1920         JNE     ??dir_find_1
   1365          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   000024   3C0B1400     MOVA    0x14(R11), R12
   1366          		c = dir[DIR_Name];
   1367          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   000028   CC930000     CMP.B   #0x0, 0(R12)
   \   00002C   0220         JNE     ??dir_find_2
   \   00002E   6A42         MOV.B   #0x4, R10
   \   000030   123C         JMP     ??dir_find_1
   1368          #if _USE_LFN	/* LFN configuration */
   1369          		a = dir[DIR_Attr] & AM_MASK;
   1370          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1371          			ord = 0xFF;
   1372          		} else {
   1373          			if (a == AM_LFN) {			/* An LFN entry is found */
   1374          				if (dj->lfn) {
   1375          					if (c & LLE) {		/* Is it start of LFN sequence? */
   1376          						sum = dir[LDIR_Chksum];
   1377          						c &= ~LLE; ord = c;	/* LFN start order */
   1378          						dj->lfn_idx = dj->index;
   1379          					}
   1380          					/* Check validity of the LFN entry and compare it with given name */
   1381          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1382          				}
   1383          			} else {					/* An SFN entry is found */
   1384          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1385          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1386          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1387          			}
   1388          		}
   1389          #else		/* Non LFN configuration */
   1390          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   \                     ??dir_find_2:
   \   000032   FCB20B00     BIT.B   #0x8, 0xb(R12)
   \   000036   082C         JC      ??dir_find_3
   \   000038   3E400B00     MOV.W   #0xb, R14
   \   00003C   3D0B1800     MOVA    0x18(R11), R13
   \   000040   ........     CALLA   #mem_cmp
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   0724         JEQ     ??dir_find_1
   1391          			break;
   1392          #endif
   1393          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_3:
   \   000048   0D43         MOV.W   #0x0, R13
   \   00004A   CC0B         MOVA    R11, R12
   \   00004C   ........     CALLA   #dir_next
   \   000050   4A4C         MOV.B   R12, R10
   1394          	} while (res == FR_OK);
   \   000052   4C93         CMP.B   #0x0, R12
   \   000054   DD27         JEQ     ??dir_find_0
   1395          
   1396          	return res;
   \                     ??dir_find_1:
   \   000056   4C4A         MOV.B   R10, R12
   \   000058   1A16         POPM.A  #0x2, R11
   \   00005A   1001         RETA
   1397          }
   1398          
   1399          
   1400          
   1401          
   1402          /*-----------------------------------------------------------------------*/
   1403          /* Read an object from the directory                                     */
   1404          /*-----------------------------------------------------------------------*/
   1405          #if _FS_MINIMIZE <= 1

   \                                 In  segment CODE, align 2, keep-with-next
   1406          static
   1407          FRESULT dir_read (
   \                     dir_read:
   1408          	DIRS *dj			/* Pointer to the directory object that pointing the entry to be read */
   1409          )
   1410          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
   1411          	FRESULT res;
   1412          	BYTE c, *dir;
   1413          #if _USE_LFN
   1414          	BYTE a, ord = 0xFF, sum = 0xFF;
   1415          #endif
   1416          
   1417          	res = FR_NO_FILE;
   \   000004   6C42         MOV.B   #0x4, R12
   1418          	while (dj->sect) {
   \                     ??dir_read_0:
   \   000006   ........     CALLA   #?Subroutine19
   \                     ??CrossCallReturnLabel_107:
   \   00000A   1824         JEQ     ??dir_read_1
   1419          		res = move_window(dj->fs, dj->sect);
   \   00000C   0C0A         MOVA    @R10, R12
   \   00000E   ........     CALLA   #?Subroutine39
   1420          		if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_76:
   \   000012   1420         JNE     ??dir_read_1
   1421          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   000014   3F0A1400     MOVA    0x14(R10), R15
   1422          		c = dir[DIR_Name];
   \   000018   6E4F         MOV.B   @R15, R14
   1423          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00001A   4E93         CMP.B   #0x0, R14
   \   00001C   0220         JNE     ??dir_read_2
   \   00001E   6C42         MOV.B   #0x4, R12
   \   000020   0F3C         JMP     ??dir_read_3
   1424          #if _USE_LFN	/* LFN configuration */
   1425          		a = dir[DIR_Attr] & AM_MASK;
   1426          		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1427          			ord = 0xFF;
   1428          		} else {
   1429          			if (a == AM_LFN) {			/* An LFN entry is found */
   1430          				if (c & LLE) {			/* Is it start of LFN sequence? */
   1431          					sum = dir[LDIR_Chksum];
   1432          					c &= ~LLE; ord = c;
   1433          					dj->lfn_idx = dj->index;
   1434          				}
   1435          				/* Check LFN validity and capture it */
   1436          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1437          			} else {					/* An SFN entry is found */
   1438          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1439          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1440          				break;
   1441          			}
   1442          		}
   1443          #else		/* Non LFN configuration */
   1444          		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
   \                     ??dir_read_2:
   \   000022   7E90E500     CMP.B   #0xe5, R14
   \   000026   0624         JEQ     ??dir_read_4
   \   000028   7E902E00     CMP.B   #0x2e, R14
   \   00002C   0324         JEQ     ??dir_read_4
   \   00002E   FFB20B00     BIT.B   #0x8, 0xb(R15)
   \   000032   0828         JNC     ??dir_read_5
   1445          			break;
   1446          #endif
   1447          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_4:
   \   000034   ........     CALLA   #?Subroutine25
   1448          		if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_90:
   \   000038   4C93         CMP.B   #0x0, R12
   \   00003A   E527         JEQ     ??dir_read_0
   1449          	}
   1450          
   1451          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   00003C   4C93         CMP.B   #0x0, R12
   \   00003E   0224         JEQ     ??dir_read_5
   \                     ??dir_read_3:
   \   000040   ........     CALLA   #?Subroutine32
   1452          
   1453          	return res;
   \                     ??dir_read_5:
   \   000044   0A16         POPM.A  #0x1, R10
   \   000046   1001         RETA
   1454          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine25:
   \   000000   0D43         MOV.W   #0x0, R13
   \   000002                REQUIRE ??Subroutine40_0
   \   000002                // Fall through to label ??Subroutine40_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   CC0A         MOVA    R10, R12
   \   000002   ........     BRA     #dir_next

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_56:
   \   000004                REQUIRE ??Subroutine19_0
   \   000004                // Fall through to label ??Subroutine19_0

   \                                 In  segment CODE, align 2
   \                     ?Subroutine34:
   \   000000   1E4A1000     MOV.W   0x10(R10), R14
   \   000004   1F4A1200     MOV.W   0x12(R10), R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine32:
   \   000000   8A431000     MOV.W   #0x0, 0x10(R10)
   \   000004   8A431200     MOV.W   #0x0, 0x12(R10)
   \   000008   1001         RETA
   1455          #endif
   1456          
   1457          
   1458          
   1459          /*-----------------------------------------------------------------------*/
   1460          /* Register an object to the directory                                   */
   1461          /*-----------------------------------------------------------------------*/
   1462          #if !_FS_READONLY

   \                                 In  segment CODE, align 2, keep-with-next
   1463          static
   1464          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   \                     dir_register:
   1465          	DIRS *dj				/* Target directory with object name to be created */
   1466          )
   1467          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
   1468          	FRESULT res;
   1469          	BYTE c, *dir;
   1470          #if _USE_LFN	/* LFN configuration */
   1471          	WORD n, ne, is;
   1472          	BYTE sn[12], *fn, sum;
   1473          	WCHAR *lfn;
   1474          
   1475          
   1476          	fn = dj->fn; lfn = dj->lfn;
   1477          	mem_cpy(sn, fn, 12);
   1478          
   1479          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   1480          		return FR_INVALID_NAME;
   1481          
   1482          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   1483          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   1484          		for (n = 1; n < 100; n++) {
   1485          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   1486          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   1487          			if (res != FR_OK) break;
   1488          		}
   1489          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   1490          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   1491          		fn[NS] = sn[NS]; dj->lfn = lfn;
   1492          	}
   1493          
   1494          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   1495          		for (ne = 0; lfn[ne]; ne++) ;
   1496          		ne = (ne + 25) / 13;
   1497          	} else {						/* Otherwise reserve only an SFN entry. */
   1498          		ne = 1;
   1499          	}
   1500          
   1501          	/* Reserve contiguous entries */
   1502          	res = dir_sdi(dj, 0);
   1503          	if (res != FR_OK) return res;
   1504          	n = is = 0;
   1505          	do {
   1506          		res = move_window(dj->fs, dj->sect);
   1507          		if (res != FR_OK) break;
   1508          		c = *dj->dir;				/* Check the entry status */
   1509          		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   1510          			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   1511          			if (++n == ne) break;	/* A contiguous entry that required count is found */
   1512          		} else {
   1513          			n = 0;					/* Not a blank entry. Restart to search */
   1514          		}
   1515          		res = dir_next(dj, 1);		/* Next entry with table stretch */
   1516          	} while (res == FR_OK);
   1517          
   1518          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   1519          		res = dir_sdi(dj, is);
   1520          		if (res == FR_OK) {
   1521          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   1522          			ne--;
   1523          			do {					/* Store LFN entries in bottom first */
   1524          				res = move_window(dj->fs, dj->sect);
   1525          				if (res != FR_OK) break;
   1526          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1527          				dj->fs->wflag = 1;
   1528          				res = dir_next(dj, 0);	/* Next entry */
   1529          			} while (res == FR_OK && --ne);
   1530          		}
   1531          	}
   1532          
   1533          #else	/* Non LFN configuration */
   1534          	res = dir_sdi(dj, 0);
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   ........     CALLA   #dir_sdi
   \   00000A   4F4C         MOV.B   R12, R15
   1535          	if (res == FR_OK) {
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   1320         JNE     ??dir_register_2
   1536          		do {	/* Find a blank entry for the SFN */
   1537          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_0:
   \   000010   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_18:
   \   000014   4F4C         MOV.B   R12, R15
   1538          			if (res != FR_OK) break;
   \   000016   4C93         CMP.B   #0x0, R12
   \   000018   0E20         JNE     ??dir_register_2
   1539          			c = *dj->dir;
   \   00001A   3F0A1400     MOVA    0x14(R10), R15
   \   00001E   6E4F         MOV.B   @R15, R14
   1540          			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   \   000020   7E90E500     CMP.B   #0xe5, R14
   \   000024   0A24         JEQ     ??dir_register_3
   \   000026   4E93         CMP.B   #0x0, R14
   \   000028   0824         JEQ     ??dir_register_3
   1541          			res = dir_next(dj, 1);			/* Next entry with table stretch */
   \   00002A   1D43         MOV.W   #0x1, R13
   \   00002C   ........     CALLA   #??Subroutine40_0
   1542          		} while (res == FR_OK);
   \                     ??CrossCallReturnLabel_88:
   \   000030   4F4C         MOV.B   R12, R15
   \   000032   4C93         CMP.B   #0x0, R12
   \   000034   ED27         JEQ     ??dir_register_0
   1543          	}
   1544          #endif
   1545          
   1546          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_2:
   \   000036   4F93         CMP.B   #0x0, R15
   \   000038   1D20         JNE     ??dir_register_4
   1547          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_3:
   \   00003A   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_17:
   \   00003E   4F4C         MOV.B   R12, R15
   1548          		if (res == FR_OK) {
   \   000040   4C93         CMP.B   #0x0, R12
   \   000042   1820         JNE     ??dir_register_4
   1549          			dir = dj->dir;
   \   000044   3C0A1400     MOVA    0x14(R10), R12
   1550          			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   \   000048   CE0C         MOVA    R12, R14
   \   00004A   7D401000     MOV.B   #0x10, R13
   \                     ??dir_register_1:
   \   00004E   CE430000     MOV.B   #0x0, 0(R14)
   \   000052   AE000100     ADDA    #0x1, R14
   \   000056   CE430000     MOV.B   #0x0, 0(R14)
   \   00005A   AE000100     ADDA    #0x1, R14
   \   00005E   7D53         ADD.B   #0xff, R13
   \   000060   F623         JNE     ??dir_register_1
   1551          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \   000062   3E400B00     MOV.W   #0xb, R14
   \   000066   3D0A1800     MOVA    0x18(R10), R13
   \   00006A   ........     CALLA   #mem_cpy
   1552          #if _USE_LFN
   1553          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   1554          #endif
   1555          			dj->fs->wflag = 1;
   \   00006E   0E0A         MOVA    @R10, R14
   \   000070   DE430400     MOV.B   #0x1, 0x4(R14)
   1556          		}
   1557          	}
   1558          
   1559          	return res;
   \                     ??dir_register_4:
   \   000074   4C4F         MOV.B   R15, R12
   \   000076   0A16         POPM.A  #0x1, R10
   \   000078   1001         RETA
   1560          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_55:
   \   000004   0C0A         MOVA    @R10, R12
   \   000006   ........     BRA     #move_window
   1561          #endif /* !_FS_READONLY */
   1562          
   1563          
   1564          
   1565          
   1566          /*-----------------------------------------------------------------------*/
   1567          /* Remove an object from the directory                                   */
   1568          /*-----------------------------------------------------------------------*/
   1569          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In  segment CODE, align 2
   1570          static
   1571          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   \                     dir_remove:
   1572          	DIRS *dj				/* Directory object pointing the entry to be removed */
   1573          )
   1574          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
   1575          	FRESULT res;
   1576          #if _USE_LFN	/* LFN configuration */
   1577          	WORD i;
   1578          
   1579          	i = dj->index;	/* SFN index */
   1580          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   1581          	if (res == FR_OK) {
   1582          		do {
   1583          			res = move_window(dj->fs, dj->sect);
   1584          			if (res != FR_OK) break;
   1585          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1586          			dj->fs->wflag = 1;
   1587          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   1588          			res = dir_next(dj, 0);		/* Next entry */
   1589          		} while (res == FR_OK);
   1590          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   1591          	}
   1592          
   1593          #else			/* Non LFN configuration */
   1594          	res = dir_sdi(dj, dj->index);
   \   000004   1D4C0600     MOV.W   0x6(R12), R13
   \   000008   ........     CALLA   #dir_sdi
   1595          	if (res == FR_OK) {
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   0E20         JNE     ??dir_remove_0
   1596          		res = move_window(dj->fs, dj->sect);
   \   000010   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_53:
   \   000014   0C0A         MOVA    @R10, R12
   \   000016   ........     CALLA   #?Subroutine39
   1597          		if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_74:
   \   00001A   0820         JNE     ??dir_remove_0
   1598          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \   00001C   3F0A1400     MOVA    0x14(R10), R15
   \   000020   FF40E5000000 MOV.B   #0xe5, 0(R15)
   1599          			dj->fs->wflag = 1;
   \   000026   0F0A         MOVA    @R10, R15
   \   000028   DF430400     MOV.B   #0x1, 0x4(R15)
   1600          		}
   1601          	}
   1602          #endif
   1603          
   1604          	return res;
   \                     ??dir_remove_0:
   \   00002C   0A16         POPM.A  #0x1, R10
   \   00002E   1001         RETA
   1605          }
   1606          #endif /* !_FS_READONLY */
   1607          
   1608          
   1609          
   1610          
   1611          /*-----------------------------------------------------------------------*/
   1612          /* Pick a segment and create the object name in directory form           */
   1613          /*-----------------------------------------------------------------------*/
   1614          

   \                                 In  segment CODE, align 2, keep-with-next
   1615          static
   1616          FRESULT create_name (
   \                     create_name:
   1617          	DIRS *dj,			/* Pointer to the directory object */
   1618          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1619          )
   1620          {
   \   000000   7B14         PUSHM.A #0x8, R11
   1621          #ifdef _EXCVT
   1622          	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   1623          #endif
   1624          
   1625          #if _USE_LFN	/* LFN configuration */
   1626          	BYTE b, cf;
   1627          	WCHAR w, *lfn;
   1628          	UINT i, ni, si, di;
   1629          	const TCHAR *p;
   1630          
   1631          	/* Create LFN in Unicode */
   1632          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1633          	lfn = dj->lfn;
   1634          	si = di = 0;
   1635          	for (;;) {
   1636          		w = p[si++];					/* Get a character */
   1637          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1638          		if (di >= _MAX_LFN)				/* Reject too long name */
   1639          			return FR_INVALID_NAME;
   1640          #if !_LFN_UNICODE
   1641          		w &= 0xFF;
   1642          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1643          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1644          			if (!IsDBCS2(b))
   1645          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1646          			w = (w << 8) + b;			/* Create a DBC */
   1647          		}
   1648          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1649          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1650          #endif
   1651          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1652          			return FR_INVALID_NAME;
   1653          		lfn[di++] = w;					/* Store the Unicode char */
   1654          	}
   1655          	*path = &p[si];						/* Return pointer to the next segment */
   1656          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1657          #if _FS_RPATH
   1658          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1659          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   1660          		lfn[di] = 0;
   1661          		for (i = 0; i < 11; i++)
   1662          			dj->fn[i] = (i < di) ? '.' : ' ';
   1663          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   1664          		return FR_OK;
   1665          	}
   1666          #endif
   1667          	while (di) {						/* Strip trailing spaces and dots */
   1668          		w = lfn[di-1];
   1669          		if (w != ' ' && w != '.') break;
   1670          		di--;
   1671          	}
   1672          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   1673          
   1674          	lfn[di] = 0;						/* LFN is created */
   1675          
   1676          	/* Create SFN in directory form */
   1677          	mem_set(dj->fn, ' ', 11);
   1678          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   1679          	if (si) cf |= NS_LOSS | NS_LFN;
   1680          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   1681          
   1682          	b = i = 0; ni = 8;
   1683          	for (;;) {
   1684          		w = lfn[si++];					/* Get an LFN char */
   1685          		if (!w) break;					/* Break on end of the LFN */
   1686          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1687          			cf |= NS_LOSS | NS_LFN; continue;
   1688          		}
   1689          
   1690          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1691          			if (ni == 11) {				/* Long extension */
   1692          				cf |= NS_LOSS | NS_LFN; break;
   1693          			}
   1694          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1695          			if (si > di) break;			/* No extension */
   1696          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1697          			b <<= 2; continue;
   1698          		}
   1699          
   1700          		if (w >= 0x80) {				/* Non ASCII char */
   1701          #ifdef _EXCVT
   1702          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1703          			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1704          #else
   1705          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1706          #endif
   1707          			cf |= NS_LFN;				/* Force create LFN entry */
   1708          		}
   1709          
   1710          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1711          			if (i >= ni - 1) {
   1712          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1713          			}
   1714          			dj->fn[i++] = (BYTE)(w >> 8);
   1715          		} else {						/* Single byte char */
   1716          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   1717          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1718          			} else {
   1719          				if (IsUpper(w)) {		/* ASCII large capital */
   1720          					b |= 2;
   1721          				} else {
   1722          					if (IsLower(w)) {	/* ASCII small capital */
   1723          						b |= 1; w -= 0x20;
   1724          					}
   1725          				}
   1726          			}
   1727          		}
   1728          		dj->fn[i++] = (BYTE)w;
   1729          	}
   1730          
   1731          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   1732          
   1733          	if (ni == 8) b <<= 2;
   1734          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   1735          		cf |= NS_LFN;
   1736          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   1737          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1738          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1739          	}
   1740          
   1741          	dj->fn[NS] = cf;	/* SFN is created */
   1742          
   1743          	return FR_OK;
   1744          
   1745          
   1746          #else	/* Non-LFN configuration */
   1747          	BYTE b, c, d, *sfn;
   1748          	UINT ni, si, i;
   1749          	const char *p;
   1750          
   1751          	/* Create file name in directory form */
   1752          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   000002   0F0D         MOVA    @R13, R15
   \   000004   023C         JMP     ??create_name_6
   \                     ??create_name_0:
   \   000006   AF000100     ADDA    #0x1, R15
   \                     ??create_name_6:
   \   00000A   6E4F         MOV.B   @R15, R14
   \   00000C   7E902F00     CMP.B   #0x2f, R14
   \   000010   FA27         JEQ     ??create_name_0
   \   000012   7E905C00     CMP.B   #0x5c, R14
   \   000016   F727         JEQ     ??create_name_0
   1753          	sfn = dj->fn;
   \   000018   3C0C1800     MOVA    0x18(R12), R12
   1754          	mem_set(sfn, ' ', 11);
   \   00001C   CB0C         MOVA    R12, R11
   \   00001E   7A402000     MOV.B   #0x20, R10
   \   000022   CC4A0000     MOV.B   R10, 0(R12)
   \   000026   AB000100     ADDA    #0x1, R11
   \   00002A   7E400500     MOV.B   #0x5, R14
   \                     ??create_name_1:
   \   00002E   CB4A0000     MOV.B   R10, 0(R11)
   \   000032   AB000100     ADDA    #0x1, R11
   \   000036   CB4A0000     MOV.B   R10, 0(R11)
   \   00003A   AB000100     ADDA    #0x1, R11
   \   00003E   7E53         ADD.B   #0xff, R14
   \   000040   F623         JNE     ??create_name_1
   1755          	si = i = b = 0; ni = 8;
   \   000042   4843         MOV.B   #0x0, R8
   \   000044   0643         MOV.W   #0x0, R6
   \   000046   0943         MOV.W   #0x0, R9
   \   000048   3B42         MOV.W   #0x8, R11
   \   00004A   073C         JMP     ??create_name_4
   1756          #if _FS_RPATH
   1757          	if (p[si] == '.') { /* Is this a dot entry? */
   1758          		for (;;) {
   1759          			c = (BYTE)p[si++];
   1760          			if (c != '.' || si >= 3) break;
   1761          			sfn[i++] = c;
   1762          		}
   1763          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1764          		*path = &p[si];									/* Return pointer to the next segment */
   1765          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1766          		return FR_OK;
   1767          	}
   1768          #endif
   1769          	for (;;) {
   1770          		c = (BYTE)p[si++];
   1771          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1772          		if (c == '.' || i >= ni) {
   1773          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   \                     ??create_name_2:
   \   00004C   3B92         CMP.W   #0x8, R11
   \   00004E   1D20         JNE     ??create_name_3
   1774          			i = 8; ni = 11;
   \   000050   3642         MOV.W   #0x8, R6
   \   000052   3B400B00     MOV.W   #0xb, R11
   1775          			b <<= 2; continue;
   \   000056                RPT     #0x2
   \   000056   41184858     RLAX.B  R8
   1776          		}
   \                     ??create_name_4:
   \   00005A   C70F         MOVA    R15, R7
   \   00005C   E709         ADDA    R9, R7
   \   00005E   6E47         MOV.B   @R7, R14
   \   000060   1953         ADD.W   #0x1, R9
   \   000062   7E902100     CMP.B   #0x21, R14
   \   000066   0628         JNC     ??create_name_7
   \   000068   7E902F00     CMP.B   #0x2f, R14
   \   00006C   0324         JEQ     ??create_name_7
   \   00006E   7E905C00     CMP.B   #0x5c, R14
   \   000072   0E20         JNE     ??create_name_8
   1777          		if (c >= 0x80) {				/* Extended char? */
   1778          			b |= 3;						/* Eliminate NT flag */
   1779          #ifdef _EXCVT
   1780          			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
   1781          #else
   1782          #if !_DF1S	/* ASCII only cfg */
   1783          			return FR_INVALID_NAME;
   1784          #endif
   1785          #endif
   1786          		}
   1787          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1788          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1789          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1790          				return FR_INVALID_NAME;
   1791          			sfn[i++] = c;
   1792          			sfn[i++] = d;
   1793          		} else {						/* Single byte code */
   1794          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1795          				return FR_INVALID_NAME;
   1796          			if (IsUpper(c)) {			/* ASCII large capital? */
   1797          				b |= 2;
   1798          			} else {
   1799          				if (IsLower(c)) {		/* ASCII small capital? */
   1800          					b |= 1; c -= 0x20;
   1801          				}
   1802          			}
   1803          			sfn[i++] = c;
   1804          		}
   1805          	}
   1806          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_7:
   \   000074   EF09         ADDA    R9, R15
   \   000076   7D0F0000     MOVA    R15, 0(R13)
   1807          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   00007A   7E902100     CMP.B   #0x21, R14
   \   00007E   0228         JNC     ??create_name_9
   \   000080   4E43         MOV.B   #0x0, R14
   \   000082   013C         JMP     ??create_name_10
   \                     ??create_name_9:
   \   000084   6E42         MOV.B   #0x4, R14
   1808          
   1809          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   \                     ??create_name_10:
   \   000086   0693         CMP.W   #0x0, R6
   \   000088   5920         JNE     ??create_name_11
   \                     ??create_name_3:
   \   00008A   7C400600     MOV.B   #0x6, R12
   \   00008E   703C         JMP     ??create_name_12
   \                     ??create_name_8:
   \   000090   7E902E00     CMP.B   #0x2e, R14
   \   000094   DB27         JEQ     ??create_name_2
   \   000096   069B         CMP.W   R11, R6
   \   000098   F82F         JC      ??create_name_3
   \   00009A   7E908000     CMP.B   #0x80, R14
   \   00009E   0228         JNC     ??create_name_13
   \   0000A0   78D00300     BIS.B   #0x3, R8
   \                     ??create_name_13:
   \   0000A4   474E         MOV.B   R14, R7
   \   0000A6   77507F00     ADD.B   #0x7f, R7
   \   0000AA   77901F00     CMP.B   #0x1f, R7
   \   0000AE   0528         JNC     ??create_name_14
   \   0000B0   474E         MOV.B   R14, R7
   \   0000B2   475A         ADD.B   R10, R7
   \   0000B4   77901D00     CMP.B   #0x1d, R7
   \   0000B8   1F2C         JC      ??create_name_15
   \                     ??create_name_14:
   \   0000BA   C70F         MOVA    R15, R7
   \   0000BC   E709         ADDA    R9, R7
   \   0000BE   6747         MOV.B   @R7, R7
   \   0000C0   1953         ADD.W   #0x1, R9
   \   0000C2   4447         MOV.B   R7, R4
   \   0000C4   7450C000     ADD.B   #0xc0, R4
   \   0000C8   74903F00     CMP.B   #0x3f, R4
   \   0000CC   0628         JNC     ??create_name_16
   \   0000CE   4447         MOV.B   R7, R4
   \   0000D0   74508000     ADD.B   #0x80, R4
   \   0000D4   74907D00     CMP.B   #0x7d, R4
   \   0000D8   D82F         JC      ??create_name_3
   \                     ??create_name_16:
   \   0000DA   044B         MOV.W   R11, R4
   \   0000DC   3453         ADD.W   #0xffff, R4
   \   0000DE   0694         CMP.W   R4, R6
   \   0000E0   D42F         JC      ??create_name_3
   \   0000E2   C40C         MOVA    R12, R4
   \   0000E4   E406         ADDA    R6, R4
   \   0000E6   C44E0000     MOV.B   R14, 0(R4)
   \   0000EA   1653         ADD.W   #0x1, R6
   \   0000EC   CE0C         MOVA    R12, R14
   \   0000EE   EE06         ADDA    R6, R14
   \   0000F0   CE470000     MOV.B   R7, 0(R14)
   \                     ??create_name_21:
   \   0000F4   1653         ADD.W   #0x1, R6
   \   0000F6   B13F         JMP     ??create_name_4
   \                     ??create_name_15:
   \   0000F8   ........     MOVA    #`?<Constant "\\"*+,:;<=>?[]|\\177">`, R7
   \   0000FC   023C         JMP     ??create_name_17
   \                     ??create_name_5:
   \   0000FE   A7000100     ADDA    #0x1, R7
   \                     ??create_name_17:
   \   000102   6447         MOV.B   @R7, R4
   \   000104   4493         CMP.B   #0x0, R4
   \   000106   0224         JEQ     ??create_name_18
   \   000108   449E         CMP.B   R14, R4
   \   00010A   F923         JNE     ??create_name_5
   \                     ??create_name_18:
   \   00010C   4493         CMP.B   #0x0, R4
   \   00010E   BD23         JNE     ??create_name_3
   \   000110   474E         MOV.B   R14, R7
   \   000112   7750BF00     ADD.B   #0xbf, R7
   \   000116   77901A00     CMP.B   #0x1a, R7
   \   00011A   022C         JC      ??create_name_19
   \   00011C   68D3         BIS.B   #0x2, R8
   \   00011E   093C         JMP     ??create_name_20
   \                     ??create_name_19:
   \   000120   474E         MOV.B   R14, R7
   \   000122   77509F00     ADD.B   #0x9f, R7
   \   000126   77901A00     CMP.B   #0x1a, R7
   \   00012A   032C         JC      ??create_name_20
   \   00012C   58D3         BIS.B   #0x1, R8
   \   00012E   7E50E000     ADD.B   #0xe0, R14
   \                     ??create_name_20:
   \   000132   C70C         MOVA    R12, R7
   \   000134   E706         ADDA    R6, R7
   \   000136   C74E0000     MOV.B   R14, 0(R7)
   \   00013A   DC3F         JMP     ??create_name_21
   1810          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   \                     ??create_name_11:
   \   00013C   FC90E5000000 CMP.B   #0xe5, 0(R12)
   \   000142   0320         JNE     ??create_name_22
   \   000144   FC4005000000 MOV.B   #0x5, 0(R12)
   1811          
   1812          	if (ni == 8) b <<= 2;
   \                     ??create_name_22:
   \   00014A   3B92         CMP.W   #0x8, R11
   \   00014C   0220         JNE     ??create_name_23
   \   00014E                RPT     #0x2
   \   00014E   41184858     RLAX.B  R8
   1813          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   \                     ??create_name_23:
   \   000152   4F48         MOV.B   R8, R15
   \   000154   7FF00300     AND.B   #0x3, R15
   \   000158   5F93         CMP.B   #0x1, R15
   \   00015A   0220         JNE     ??create_name_24
   \   00015C   7ED01000     BIS.B   #0x10, R14
   1814          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   \                     ??create_name_24:
   \   000160   78F00C00     AND.B   #0xc, R8
   \   000164   6892         CMP.B   #0x4, R8
   \   000166   0120         JNE     ??create_name_25
   \   000168   7ED2         BIS.B   #0x8, R14
   1815          
   1816          	sfn[NS] = c;		/* Store NT flag, File name is created */
   \                     ??create_name_25:
   \   00016A   CC4E0B00     MOV.B   R14, 0xb(R12)
   1817          
   1818          	return FR_OK;
   \   00016E   4C43         MOV.B   #0x0, R12
   \                     ??create_name_12:
   \   000170   7416         POPM.A  #0x8, R11
   \   000172   1001         RETA
   1819          #endif
   1820          }
   1821          
   1822          
   1823          
   1824          
   1825          /*-----------------------------------------------------------------------*/
   1826          /* Get file information from directory entry                             */
   1827          /*-----------------------------------------------------------------------*/
   1828          #if _FS_MINIMIZE <= 1

   \                                 In  segment CODE, align 2, keep-with-next
   1829          static
   1830          void get_fileinfo (		/* No return code */
   \                     get_fileinfo:
   1831          	DIRS *dj,			/* Pointer to the directory object */
   1832          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1833          )
   1834          {
   \   000000   5B14         PUSHM.A #0x6, R11
   1835          	UINT i;
   1836          	BYTE nt, *dir;
   1837          	TCHAR *p, c;
   1838          
   1839          
   1840          	p = fno->fname;
   \   000002   C80D         MOVA    R13, R8
   \   000004   A8000900     ADDA    #0x9, R8
   1841          	if (dj->sect) {
   \   000008   1F4C1000     MOV.W   0x10(R12), R15
   \   00000C   1FDC1200     BIS.W   0x12(R12), R15
   \   000010   0F93         CMP.W   #0x0, R15
   \   000012   5D24         JEQ     ??get_fileinfo_1
   1842          		dir = dj->dir;
   \   000014   3C0C1400     MOVA    0x14(R12), R12
   1843          		nt = dir[DIR_NTres];		/* NT flag */
   1844          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   000018   CF0C         MOVA    R12, R15
   \   00001A   CB0C         MOVA    R12, R11
   \   00001C   AB000800     ADDA    #0x8, R11
   \   000020   7E402000     MOV.B   #0x20, R14
   1845          			c = dir[i];
   \                     ??get_fileinfo_0:
   \   000024   6A4F         MOV.B   @R15, R10
   1846          			if (c == ' ') break;
   \   000026   4A9E         CMP.B   R14, R10
   \   000028   0D24         JEQ     ??get_fileinfo_2
   1847          			if (c == NDDE) c = (TCHAR)DDE;
   \   00002A   7A900500     CMP.B   #0x5, R10
   \   00002E   0220         JNE     ??get_fileinfo_3
   \   000030   7A40E500     MOV.B   #0xe5, R10
   1848          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   1849          #if _LFN_UNICODE
   1850          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1851          				c = (c << 8) | dir[++i];
   1852          			c = ff_convert(c, 1);
   1853          			if (!c) c = '?';
   1854          #endif
   1855          			*p++ = c;
   \                     ??get_fileinfo_3:
   \   000034   C84A0000     MOV.B   R10, 0(R8)
   \   000038   A8000100     ADDA    #0x1, R8
   1856          		}
   \   00003C   AF000100     ADDA    #0x1, R15
   \   000040   DF0B         CMPA    R11, R15
   \   000042   F023         JNE     ??get_fileinfo_0
   1857          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_2:
   \   000044   CC9E0800     CMP.B   R14, 0x8(R12)
   \   000048   1D24         JEQ     ??get_fileinfo_4
   1858          			*p++ = '.';
   \   00004A   F8402E000000 MOV.B   #0x2e, 0(R8)
   \   000050   A8000100     ADDA    #0x1, R8
   1859          			for (i = 8; i < 11; i++) {
   1860          				c = dir[i];
   \   000054   5A4C0800     MOV.B   0x8(R12), R10
   1861          				if (c == ' ') break;
   \   000058   4A9E         CMP.B   R14, R10
   \   00005A   1424         JEQ     ??get_fileinfo_4
   1862          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   1863          #if _LFN_UNICODE
   1864          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1865          					c = (c << 8) | dir[++i];
   1866          				c = ff_convert(c, 1);
   1867          				if (!c) c = '?';
   1868          #endif
   1869          				*p++ = c;
   \   00005C   C84A0000     MOV.B   R10, 0(R8)
   \   000060   A8000100     ADDA    #0x1, R8
   \   000064   5F4C0900     MOV.B   0x9(R12), R15
   \   000068   4F9E         CMP.B   R14, R15
   \   00006A   0C24         JEQ     ??get_fileinfo_4
   \   00006C   C84F0000     MOV.B   R15, 0(R8)
   \   000070   A8000100     ADDA    #0x1, R8
   \   000074   5F4C0A00     MOV.B   0xa(R12), R15
   \   000078   4F9E         CMP.B   R14, R15
   \   00007A   0424         JEQ     ??get_fileinfo_4
   \   00007C   C84F0000     MOV.B   R15, 0(R8)
   \   000080   A8000100     ADDA    #0x1, R8
   1870          			}
   1871          		}
   1872          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_4:
   \   000084   DD4C0B000800 MOV.B   0xb(R12), 0x8(R13)
   1873          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   00008A   564C1C00     MOV.B   0x1c(R12), R6
   \   00008E   594C1D00     MOV.B   0x1d(R12), R9
   \   000092   8910         SWPB    R9
   \   000094   5A4C1E00     MOV.B   0x1e(R12), R10
   \   000098   5E4C1F00     MOV.B   0x1f(R12), R14
   \   00009C   8E10         SWPB    R14
   \   00009E   0F4E         MOV.W   R14, R15
   \   0000A0   0FDA         BIS.W   R10, R15
   \   0000A2   0E49         MOV.W   R9, R14
   \   0000A4   0ED6         BIS.W   R6, R14
   \   0000A6   8D4E0000     MOV.W   R14, 0(R13)
   \   0000AA   8D4F0200     MOV.W   R15, 0x2(R13)
   1874          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   0000AE   5B4C1800     MOV.B   0x18(R12), R11
   \   0000B2   5F4C1900     MOV.B   0x19(R12), R15
   \   0000B6   8F10         SWPB    R15
   \   0000B8   0FDB         BIS.W   R11, R15
   \   0000BA   8D4F0400     MOV.W   R15, 0x4(R13)
   1875          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   0000BE   5B4C1600     MOV.B   0x16(R12), R11
   \   0000C2   5F4C1700     MOV.B   0x17(R12), R15
   \   0000C6   8F10         SWPB    R15
   \   0000C8   0FDB         BIS.W   R11, R15
   \   0000CA   8D4F0600     MOV.W   R15, 0x6(R13)
   1876          	}
   1877          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_1:
   \   0000CE   C8430000     MOV.B   #0x0, 0(R8)
   1878          
   1879          #if _USE_LFN
   1880          	if (fno->lfname && fno->lfsize) {
   1881          		TCHAR *tp = fno->lfname;
   1882          		WCHAR w, *lfn;
   1883          
   1884          		i = 0;
   1885          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   1886          			lfn = dj->lfn;
   1887          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1888          #if !_LFN_UNICODE
   1889          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1890          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1891          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1892          					tp[i++] = (TCHAR)(w >> 8);
   1893          #endif
   1894          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   1895          				tp[i++] = (TCHAR)w;
   1896          			}
   1897          		}
   1898          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   1899          	}
   1900          #endif
   1901          }
   \   0000D2   5616         POPM.A  #0x6, R11
   \   0000D4   1001         RETA
   1902          #endif /* _FS_MINIMIZE <= 1 */
   1903          
   1904          
   1905          
   1906          
   1907          /*-----------------------------------------------------------------------*/
   1908          /* Follow a file path                                                    */
   1909          /*-----------------------------------------------------------------------*/
   1910          

   \                                 In  segment CODE, align 2, keep-with-next
   1911          static
   1912          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   \                     follow_path:
   1913          	DIRS *dj,			/* Directory object to return last directory and found object */
   1914          	const TCHAR *path	/* Full-path string to find a file or directory */
   1915          )
   1916          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   CA0C         MOVA    R12, R10
   1917          	FRESULT res;
   1918          	BYTE *dir, ns;
   1919          
   1920          
   1921          #if _FS_RPATH
   1922          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   1923          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   1924          	} else {							/* No heading separator */
   1925          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   1926          	}
   1927          #else
   1928          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   \   000006   0F01         MOVA    @SP, R15
   \   000008   6E4F         MOV.B   @R15, R14
   \   00000A   7E902F00     CMP.B   #0x2f, R14
   \   00000E   0324         JEQ     ??follow_path_1
   \   000010   7E905C00     CMP.B   #0x5c, R14
   \   000014   0420         JNE     ??follow_path_2
   1929          		path++;
   \                     ??follow_path_1:
   \   000016   AF000100     ADDA    #0x1, R15
   \   00001A   710F0000     MOVA    R15, 0(SP)
   1930          	dj->sclust = 0;						/* Start from the root dir */
   \                     ??follow_path_2:
   \   00001E   8C430800     MOV.W   #0x0, 0x8(R12)
   \   000022   8C430A00     MOV.W   #0x0, 0xa(R12)
   1931          #endif
   1932          
   1933          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \   000026   0F01         MOVA    @SP, R15
   \   000028   FF9020000000 CMP.B   #0x20, 0(R15)
   \   00002E   092C         JC      ??follow_path_3
   1934          		res = dir_sdi(dj, 0);
   \   000030   0D43         MOV.W   #0x0, R13
   \   000032   ........     CALLA   #dir_sdi
   1935          		dj->dir = 0;
   \   000036   0018CA431400 MOVX.A  #0x0, 0x14(R10)
   \   00003C   213C         JMP     ??follow_path_4
   1936          
   1937          	} else {							/* Follow path */
   1938          		for (;;) {
   1939          			res = create_name(dj, &path);	/* Get a segment */
   1940          			if (res != FR_OK) break;
   1941          			res = dir_find(dj);				/* Find it */
   1942          			ns = *(dj->fn+NS);
   1943          			if (res != FR_OK) {				/* Failed to find the object */
   1944          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
   1945          				/* Object not found */
   1946          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   1947          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   1948          					res = FR_OK;
   1949          					if (!(ns & NS_LAST)) continue;
   1950          				} else {							/* Could not find the object */
   1951          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   1952          				}
   1953          				break;
   1954          			}
   1955          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   1956          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   1957          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   1958          				res = FR_NO_PATH; break;
   1959          			}
   1960          			dj->sclust = LD_CLUST(dir);
   \                     ??follow_path_0:
   \   00003E   ........     CALLA   #?Subroutine15
   \                     ??follow_path_3:
   \   000042   0D41         MOV.W   SP, R13
   \   000044   0D53         ADD.W   #0x0, R13
   \   000046   CC0A         MOVA    R10, R12
   \   000048   ........     CALLA   #create_name
   \   00004C   4C93         CMP.B   #0x0, R12
   \   00004E   1820         JNE     ??follow_path_4
   \   000050   CC0A         MOVA    R10, R12
   \   000052   ........     CALLA   #dir_find
   \   000056   3F0A1800     MOVA    0x18(R10), R15
   \   00005A   5E4F0B00     MOV.B   0xb(R15), R14
   \   00005E   4C93         CMP.B   #0x0, R12
   \   000060   0524         JEQ     ??follow_path_5
   \   000062   6C92         CMP.B   #0x4, R12
   \   000064   0D20         JNE     ??follow_path_4
   \   000066   6EB2         BIT.B   #0x4, R14
   \   000068   0B2C         JC      ??follow_path_4
   \   00006A   083C         JMP     ??follow_path_6
   \                     ??follow_path_5:
   \   00006C   6EB2         BIT.B   #0x4, R14
   \   00006E   082C         JC      ??follow_path_4
   \   000070   3C0A1400     MOVA    0x14(R10), R12
   \   000074   FCB010000B00 BIT.B   #0x10, 0xb(R12)
   \   00007A   E12F         JC      ??follow_path_0
   \                     ??follow_path_6:
   \   00007C   7C400500     MOV.B   #0x5, R12
   1961          		}
   1962          	}
   1963          
   1964          	return res;
   \                     ??follow_path_4:
   \   000080   2152         ADD.W   #0x4, SP
   \   000082   0A16         POPM.A  #0x1, R10
   \   000084   1001         RETA
   1965          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   5F4C1A00     MOV.B   0x1a(R12), R15
   \   000004   5E4C1B00     MOV.B   0x1b(R12), R14
   \   000008   8E10         SWPB    R14
   \   00000A   0EDF         BIS.W   R15, R14
   \   00000C   5D4C1400     MOV.B   0x14(R12), R13
   \   000010   5F4C1500     MOV.B   0x15(R12), R15
   \   000014   8F10         SWPB    R15
   \   000016   0FDD         BIS.W   R13, R15
   \   000018   8A4E0800     MOV.W   R14, 0x8(R10)
   \   00001C   8A4F0A00     MOV.W   R15, 0xa(R10)
   \   000020   1001         RETA
   1966          
   1967          
   1968          
   1969          
   1970          /*-----------------------------------------------------------------------*/
   1971          /* Load boot record and check if it is an FAT boot record                */
   1972          /*-----------------------------------------------------------------------*/
   1973          

   \                                 In  segment CODE, align 2, keep-with-next
   1974          static
   1975          BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
   \                     check_fs:
   1976          	FATFS *fs,	/* File system object */
   1977          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   1978          )
   1979          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
   1980          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   000004   5312         PUSH.B  #0x1
   \   000006   CD0C         MOVA    R12, R13
   \   000008   AD002E00     ADDA    #0x2e, R13
   \   00000C   5C4A0100     MOV.B   0x1(R10), R12
   \   000010   ........     CALLA   #disk_read
   \   000014   2153         ADD.W   #0x2, SP
   \   000016   4C93         CMP.B   #0x0, R12
   \   000018   0324         JEQ     ??check_fs_1
   1981          		return 3;
   \   00001A   7C400300     MOV.B   #0x3, R12
   \   00001E   2A3C         JMP     ??check_fs_2
   1982          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_1:
   \   000020   5E4A2C02     MOV.B   0x22c(R10), R14
   \   000024   5F4A2D02     MOV.B   0x22d(R10), R15
   \   000028   8F10         SWPB    R15
   \   00002A   0FDE         BIS.W   R14, R15
   \   00002C   3F9055AA     CMP.W   #0xaa55, R15
   \   000030   0224         JEQ     ??check_fs_3
   1983          		return 2;
   \   000032   6C43         MOV.B   #0x2, R12
   \   000034   1F3C         JMP     ??check_fs_2
   1984          
   1985          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_3:
   \   000036   5D4A6400     MOV.B   0x64(R10), R13
   \   00003A   5E4A6500     MOV.B   0x65(R10), R14
   \   00003E   8E10         SWPB    R14
   \   000040   5F4A6600     MOV.B   0x66(R10), R15
   \   000044   0EDD         BIS.W   R13, R14
   \   000046   3E904641     CMP.W   #0x4146, R14
   \   00004A   0320         JNE     ??check_fs_4
   \   00004C   3F905400     CMP.W   #0x54, R15
   \   000050   0E24         JEQ     ??check_fs_0
   1986          		return 0;
   1987          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_4:
   \   000052   5D4A8000     MOV.B   0x80(R10), R13
   \   000056   5E4A8100     MOV.B   0x81(R10), R14
   \   00005A   8E10         SWPB    R14
   \   00005C   5F4A8200     MOV.B   0x82(R10), R15
   \   000060   0EDD         BIS.W   R13, R14
   \   000062   3E904641     CMP.W   #0x4146, R14
   \   000066   0520         JNE     ??check_fs_5
   \   000068   3F905400     CMP.W   #0x54, R15
   \   00006C   0220         JNE     ??check_fs_5
   1988          		return 0;
   \                     ??check_fs_0:
   \   00006E   4C43         MOV.B   #0x0, R12
   \   000070   013C         JMP     ??check_fs_2
   1989          
   1990          	return 1;
   \                     ??check_fs_5:
   \   000072   5C43         MOV.B   #0x1, R12
   \                     ??check_fs_2:
   \   000074   0A16         POPM.A  #0x1, R10
   \   000076   1001         RETA
   1991          }
   1992          
   1993          
   1994          
   1995          
   1996          /*-----------------------------------------------------------------------*/
   1997          /* Check if the file system object is valid or not                       */
   1998          /*-----------------------------------------------------------------------*/
   1999          

   \                                 In  segment CODE, align 2, keep-with-next
   2000          static
   2001          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   \                     chk_mounted:
   2002          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2003          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2004          	BYTE chk_wp			/* !=0: Check media write protection for write access */
   2005          )
   2006          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4A4E         MOV.B   R14, R10
   2007          	BYTE fmt, b, *tbl;
   2008          	UINT vol;
   2009          	DSTATUS stat;
   2010          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2011          	WORD nrsv;
   2012          	const TCHAR *p = *path;
   \   000006   0F0C         MOVA    @R12, R15
   2013          	FATFS *fs;
   2014          
   2015          	/* Get logical drive number from the path name */
   2016          	vol = p[0] - '0';					/* Is there a drive number? */
   \   000008   6E4F         MOV.B   @R15, R14
   \   00000A   3E50D0FF     ADD.W   #0xffd0, R14
   2017          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   00000E   3E900A00     CMP.W   #0xa, R14
   \   000012   0C2C         JC      ??chk_mounted_3
   \   000014   FF903A000100 CMP.B   #0x3a, 0x1(R15)
   \   00001A   0820         JNE     ??chk_mounted_3
   2018          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00001C   EF03         ADDA    #0x2, R15
   \   00001E   7C0F0000     MOVA    R15, 0(R12)
   2019          	} else {							/* No drive number is given */
   2020          #if _FS_RPATH
   2021          		vol = CurrVol;					/* Use current drive */
   2022          #else
   2023          		vol = 0;						/* Use drive 0 */
   2024          #endif
   2025          	}
   2026          
   2027          	/* Check if the logical drive is valid or not */
   2028          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \   000022   0E93         CMP.W   #0x0, R14
   \   000024   0324         JEQ     ??chk_mounted_3
   2029          		return FR_INVALID_DRIVE;
   \   000026   7C400B00     MOV.B   #0xb, R12
   \   00002A   C23D         JMP     ??chk_mounted_4
   2030          	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_3:
   \   00002C   ........     MOVA    &FatFs, R8
   \   000030   7D080000     MOVA    R8, 0(R13)
   2031          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   000034   D803         CMPA    #0x0, R8
   \   000036   0320         JNE     ??chk_mounted_5
   \   000038   7C400C00     MOV.B   #0xc, R12
   \   00003C   B93D         JMP     ??chk_mounted_4
   2032          
   2033          	ENTER_FF(fs);						/* Lock file system */
   2034          
   2035          	if (fs->fs_type) {					/* If the logical drive has been mounted */
   \                     ??chk_mounted_5:
   \   00003E   C8930000     CMP.B   #0x0, 0(R8)
   \   000042   0B24         JEQ     ??chk_mounted_6
   2036          		stat = disk_status(fs->drv);
   \   000044   5C480100     MOV.B   0x1(R8), R12
   \   000048   ........     CALLA   #disk_status
   2037          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   00004C   5CB3         BIT.B   #0x1, R12
   \   00004E   052C         JC      ??chk_mounted_6
   2038          #if !_FS_READONLY
   2039          			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   000050   4A93         CMP.B   #0x0, R10
   \   000052   AD25         JEQ     ??chk_mounted_2
   \   000054   6CB2         BIT.B   #0x4, R12
   \   000056   112C         JC      ??chk_mounted_7
   2040          				return FR_WRITE_PROTECTED;
   2041          #endif
   2042          			return FR_OK;				/* The file system object is valid */
   \   000058   AA3D         JMP     ??chk_mounted_2
   2043          		}
   2044          	}
   2045          
   2046          	/* The logical drive must be mounted. */
   2047          	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */
   2048          
   2049          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_6:
   \   00005A   C8430000     MOV.B   #0x0, 0(R8)
   2050          	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
   \   00005E   C8430100     MOV.B   #0x0, 0x1(R8)
   2051          	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
   \   000062   4C43         MOV.B   #0x0, R12
   \   000064   ........     CALLA   #disk_initialize
   2052          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   000068   5CB3         BIT.B   #0x1, R12
   \   00006A   0328         JNC     ??chk_mounted_8
   2053          		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
   \   00006C   7C400300     MOV.B   #0x3, R12
   \   000070   9F3D         JMP     ??chk_mounted_4
   2054          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2055          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2056          		return FR_DISK_ERR;
   2057          #endif
   2058          #if !_FS_READONLY
   2059          	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_8:
   \   000072   4A93         CMP.B   #0x0, R10
   \   000074   0524         JEQ     ??chk_mounted_9
   \   000076   6CB2         BIT.B   #0x4, R12
   \   000078   0328         JNC     ??chk_mounted_9
   2060          		return FR_WRITE_PROTECTED;
   \                     ??chk_mounted_7:
   \   00007A   7C400A00     MOV.B   #0xa, R12
   \   00007E   983D         JMP     ??chk_mounted_4
   2061          #endif
   2062          	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
   2063          	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
   \                     ??chk_mounted_9:
   \   000080   0A43         MOV.W   #0x0, R10
   \   000082   0B43         MOV.W   #0x0, R11
   \   000084   0E43         MOV.W   #0x0, R14
   \   000086   0F43         MOV.W   #0x0, R15
   \   000088   CC08         MOVA    R8, R12
   \   00008A   ........     CALLA   #check_fs
   \   00008E   494C         MOV.B   R12, R9
   2064          	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
   \   000090   5C93         CMP.B   #0x1, R12
   \   000092   1A20         JNE     ??chk_mounted_10
   2065          		/* Check the partition listed in top of the partition table */
   2066          		tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
   \   000094   CB08         MOVA    R8, R11
   \   000096   AB00EC01     ADDA    #0x1ec, R11
   2067          		if (tbl[4]) {									/* Is the partition existing? */
   \   00009A   CB930400     CMP.B   #0x0, 0x4(R11)
   \   00009E   0625         JEQ     ??chk_mounted_0
   2068          			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
   \   0000A0   5D4B0800     MOV.B   0x8(R11), R13
   \   0000A4   574B0900     MOV.B   0x9(R11), R7
   \   0000A8   8710         SWPB    R7
   \   0000AA   5E4B0A00     MOV.B   0xa(R11), R14
   \   0000AE   5A4B0B00     MOV.B   0xb(R11), R10
   \   0000B2   8A10         SWPB    R10
   \   0000B4   0B4A         MOV.W   R10, R11
   \   0000B6   0BDE         BIS.W   R14, R11
   \   0000B8   0A47         MOV.W   R7, R10
   \   0000BA   0ADD         BIS.W   R13, R10
   2069          			fmt = check_fs(fs, bsect);					/* Check the partition */
   \   0000BC   0E4A         MOV.W   R10, R14
   \   0000BE   0F4B         MOV.W   R11, R15
   \   0000C0   CC08         MOVA    R8, R12
   \   0000C2   ........     CALLA   #check_fs
   \   0000C6   494C         MOV.B   R12, R9
   \                     ??chk_mounted_10:
   \   0000C8   79900300     CMP.B   #0x3, R9
   \   0000CC   0220         JNE     ??chk_mounted_11
   2070          		}
   2071          	}
   2072          	if (fmt == 3) return FR_DISK_ERR;
   \   0000CE   5C43         MOV.B   #0x1, R12
   \   0000D0   6F3D         JMP     ??chk_mounted_4
   2073          	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
   \                     ??chk_mounted_11:
   \   0000D2   4993         CMP.B   #0x0, R9
   \   0000D4   EB20         JNE     ??chk_mounted_0
   2074          
   2075          	/* Following code initializes the file system object */
   2076          
   2077          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \   0000D6   57483900     MOV.B   0x39(R8), R7
   \   0000DA   5F483A00     MOV.B   0x3a(R8), R15
   \   0000DE   8F10         SWPB    R15
   \   0000E0   0FD7         BIS.W   R7, R15
   \   0000E2   3F900002     CMP.W   #0x200, R15
   \   0000E6   E220         JNE     ??chk_mounted_0
   2078          		return FR_NO_FILESYSTEM;
   2079          
   2080          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \   0000E8   5F484400     MOV.B   0x44(R8), R15
   \   0000EC   56484500     MOV.B   0x45(R8), R6
   \   0000F0   8610         SWPB    R6
   \   0000F2   06DF         BIS.W   R15, R6
   \   0000F4   0743         MOV.W   #0x0, R7
   2081          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   0000F6   0693         CMP.W   #0x0, R6
   \   0000F8   0E20         JNE     ??chk_mounted_12
   \   0000FA   5D485200     MOV.B   0x52(R8), R13
   \   0000FE   59485300     MOV.B   0x53(R8), R9
   \   000102   8910         SWPB    R9
   \   000104   5E485400     MOV.B   0x54(R8), R14
   \   000108   56485500     MOV.B   0x55(R8), R6
   \   00010C   8610         SWPB    R6
   \   00010E   0746         MOV.W   R6, R7
   \   000110   07DE         BIS.W   R14, R7
   \   000112   0649         MOV.W   R9, R6
   \   000114   06DD         BIS.W   R13, R6
   2082          	fs->fsize = fasize;
   \                     ??chk_mounted_12:
   \   000116   88461A00     MOV.W   R6, 0x1a(R8)
   \   00011A   88471C00     MOV.W   R7, 0x1c(R8)
   2083          
   2084          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   00011E   5E483E00     MOV.B   0x3e(R8), R14
   \   000122   C84E0300     MOV.B   R14, 0x3(R8)
   2085          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   000126   5E93         CMP.B   #0x1, R14
   \   000128   0224         JEQ     ??chk_mounted_13
   \   00012A   6E93         CMP.B   #0x2, R14
   \   00012C   BF20         JNE     ??chk_mounted_0
   2086          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_13:
   \   00012E   0C46         MOV.W   R6, R12
   \   000130   0D47         MOV.W   R7, R13
   \   000132   0F43         MOV.W   #0x0, R15
   \   000134   ........     CALLA   #?Mul32
   \   000138   064C         MOV.W   R12, R6
   \   00013A   074D         MOV.W   R13, R7
   2087          
   2088          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   00013C   59483B00     MOV.B   0x3b(R8), R9
   \   000140   4E49         MOV.B   R9, R14
   \   000142   C84E0200     MOV.B   R14, 0x2(R8)
   2089          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   000146   4993         CMP.B   #0x0, R9
   \   000148   B124         JEQ     ??chk_mounted_0
   \   00014A   4F49         MOV.B   R9, R15
   \   00014C   7F53         ADD.B   #0xff, R15
   \   00014E   49BF         BIT.B   R15, R9
   \   000150   AD20         JNE     ??chk_mounted_0
   \   000152   5E483F00     MOV.B   0x3f(R8), R14
   \   000156   5F484000     MOV.B   0x40(R8), R15
   \   00015A   8F10         SWPB    R15
   \   00015C   0FDE         BIS.W   R14, R15
   \   00015E   884F0800     MOV.W   R15, 0x8(R8)
   2090          
   2091          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   2092          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   000162   7EB00F00     BIT.B   #0xf, R14
   \   000166   A220         JNE     ??chk_mounted_0
   2093          
   2094          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \   000168   5F484100     MOV.B   0x41(R8), R15
   \   00016C   5C484200     MOV.B   0x42(R8), R12
   \   000170   8C10         SWPB    R12
   \   000172   0CDF         BIS.W   R15, R12
   \   000174   0D43         MOV.W   #0x0, R13
   2095          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   000176   0C93         CMP.W   #0x0, R12
   \   000178   0E20         JNE     ??chk_mounted_14
   \   00017A   55484E00     MOV.B   0x4e(R8), R5
   \   00017E   54484F00     MOV.B   0x4f(R8), R4
   \   000182   8410         SWPB    R4
   \   000184   5E485000     MOV.B   0x50(R8), R14
   \   000188   5C485100     MOV.B   0x51(R8), R12
   \   00018C   8C10         SWPB    R12
   \   00018E   0D4C         MOV.W   R12, R13
   \   000190   0DDE         BIS.W   R14, R13
   \   000192   0C44         MOV.W   R4, R12
   \   000194   0CD5         BIS.W   R5, R12
   2096          
   2097          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_14:
   \   000196   5E483C00     MOV.B   0x3c(R8), R14
   \   00019A   5F483D00     MOV.B   0x3d(R8), R15
   \   00019E   8F10         SWPB    R15
   \   0001A0   0FDE         BIS.W   R14, R15
   \   0001A2   814F0000     MOV.W   R15, 0(SP)
   2098          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   0001A6   0F93         CMP.W   #0x0, R15
   \   0001A8   8124         JEQ     ??chk_mounted_0
   2099          
   2100          	/* Determine the FAT sub type */
   2101          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIRS */
   \   0001AA   044F         MOV.W   R15, R4
   \   0001AC   0543         MOV.W   #0x0, R5
   \   0001AE   0456         ADD.W   R6, R4
   \   0001B0   0567         ADDC.W  R7, R5
   \   0001B2   1E480800     MOV.W   0x8(R8), R14
   \   0001B6   5E0F         RRUM.W  #0x4, R14
   \   0001B8   0F43         MOV.W   #0x0, R15
   \   0001BA   045E         ADD.W   R14, R4
   \   0001BC   0563         ADDC.W  #0x0, R5
   2102          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   0001BE   0D95         CMP.W   R5, R13
   \   0001C0   7528         JNC     ??chk_mounted_0
   \   0001C2   0220         JNE     ??chk_mounted_15
   \   0001C4   0C94         CMP.W   R4, R12
   \   0001C6   7228         JNC     ??chk_mounted_0
   2103          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_15:
   \   0001C8   0C84         SUB.W   R4, R12
   \   0001CA   0D75         SUBC.W  R5, R13
   \   0001CC   4E49         MOV.B   R9, R14
   \   0001CE   ........     CALLA   #?DivMod32u
   2104          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   0001D2   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_64:
   \   0001D6   6A24         JEQ     ??chk_mounted_0
   2105          	fmt = FS_FAT12;
   \   0001D8   5943         MOV.B   #0x1, R9
   2106          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   0001DA   0D93         CMP.W   #0x0, R13
   \   0001DC   0320         JNE     ??chk_mounted_16
   \   0001DE   3C90F60F     CMP.W   #0xff6, R12
   \   0001E2   0128         JNC     ??chk_mounted_17
   \                     ??chk_mounted_16:
   \   0001E4   6943         MOV.B   #0x2, R9
   2107          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_17:
   \   0001E6   0D93         CMP.W   #0x0, R13
   \   0001E8   0320         JNE     ??chk_mounted_18
   \   0001EA   3C90F6FF     CMP.W   #0xfff6, R12
   \   0001EE   0228         JNC     ??chk_mounted_19
   \                     ??chk_mounted_18:
   \   0001F0   79400300     MOV.B   #0x3, R9
   2108          
   2109          	/* Boundaries and Limits */
   2110          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_19:
   \   0001F4   2C53         ADD.W   #0x2, R12
   \   0001F6   0D63         ADDC.W  #0x0, R13
   \   0001F8   884C1600     MOV.W   R12, 0x16(R8)
   \   0001FC   884D1800     MOV.W   R13, 0x18(R8)
   2111          	fs->database = bsect + sysect;						/* Data start sector */
   \   000200   0E4A         MOV.W   R10, R14
   \   000202   0F4B         MOV.W   R11, R15
   \   000204   0E54         ADD.W   R4, R14
   \   000206   0F65         ADDC.W  R5, R15
   \   000208   884E2600     MOV.W   R14, 0x26(R8)
   \   00020C   884F2800     MOV.W   R15, 0x28(R8)
   2112          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   000210   2E41         MOV.W   @SP, R14
   \   000212   0F43         MOV.W   #0x0, R15
   \   000214   044A         MOV.W   R10, R4
   \   000216   054B         MOV.W   R11, R5
   \   000218   045E         ADD.W   R14, R4
   \   00021A   0563         ADDC.W  #0x0, R5
   \   00021C   88441E00     MOV.W   R4, 0x1e(R8)
   \   000220   88452000     MOV.W   R5, 0x20(R8)
   2113          	if (fmt == FS_FAT32) {
   \   000224   79900300     CMP.B   #0x3, R9
   \   000228   1820         JNE     ??chk_mounted_20
   2114          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   00022A   88930800     CMP.W   #0x0, 0x8(R8)
   \   00022E   3E20         JNE     ??chk_mounted_0
   2115          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \   000230   5D485A00     MOV.B   0x5a(R8), R13
   \   000234   57485B00     MOV.B   0x5b(R8), R7
   \   000238   8710         SWPB    R7
   \   00023A   5E485C00     MOV.B   0x5c(R8), R14
   \   00023E   54485D00     MOV.B   0x5d(R8), R4
   \   000242   8410         SWPB    R4
   \   000244   0544         MOV.W   R4, R5
   \   000246   05DE         BIS.W   R14, R5
   \   000248   0447         MOV.W   R7, R4
   \   00024A   04DD         BIS.W   R13, R4
   2116          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   00024C   1C481600     MOV.W   0x16(R8), R12
   \   000250   1D481800     MOV.W   0x18(R8), R13
   \   000254   0C5C         RLA.W   R12
   \   000256   0D6D         RLC.W   R13
   \   000258   0D3C         JMP     ??chk_mounted_21
   2117          	} else {
   2118          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_20:
   \   00025A   88930800     CMP.W   #0x0, 0x8(R8)
   \   00025E   2624         JEQ     ??chk_mounted_0
   2119          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \   000260   0456         ADD.W   R6, R4
   \   000262   0567         ADDC.W  R7, R5
   2120          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2121          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   000264   16481600     MOV.W   0x16(R8), R6
   \   000268   17481800     MOV.W   0x18(R8), R7
   \   00026C   6993         CMP.B   #0x2, R9
   \   00026E   0C46         MOV.W   R6, R12
   \   000270   0D47         MOV.W   R7, R13
   \   000272   0320         JNE     ??chk_mounted_22
   \                     ??chk_mounted_21:
   \   000274   0C5C         RLA.W   R12
   \   000276   0D6D         RLC.W   R13
   \   000278   093C         JMP     ??chk_mounted_23
   \                     ??chk_mounted_22:
   \   00027A   3E400300     MOV.W   #0x3, R14
   \   00027E   ........     CALLA   #?Mul32
   \   000282   5D03         RRUM.W  #0x1, R13
   \   000284   0C10         RRC.W   R12
   \   000286   16F3         AND.W   #0x1, R6
   \   000288   0C56         ADD.W   R6, R12
   \   00028A   0D63         ADDC.W  #0x0, R13
   \                     ??chk_mounted_23:
   \   00028C   88442200     MOV.W   R4, 0x22(R8)
   \   000290   88452400     MOV.W   R5, 0x24(R8)
   2122          	}
   2123          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \   000294   3C50FF01     ADD.W   #0x1ff, R12
   \   000298   0D63         ADDC.W  #0x0, R13
   \   00029A   ........     CALLA   #?ShiftRight32u_9
   \   00029E   889D1C00     CMP.W   R13, 0x1c(R8)
   \   0002A2   0428         JNC     ??chk_mounted_0
   \   0002A4   0620         JNE     ??chk_mounted_24
   \   0002A6   889C1A00     CMP.W   R12, 0x1a(R8)
   \   0002AA   032C         JC      ??chk_mounted_24
   2124          		return FR_NO_FILESYSTEM;
   \                     ??chk_mounted_0:
   \   0002AC   7C400D00     MOV.B   #0xd, R12
   \   0002B0   7F3C         JMP     ??chk_mounted_4
   2125          
   2126          #if !_FS_READONLY
   2127          	/* Initialize cluster allocation information */
   2128          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_24:
   \   0002B2   B8430E00     MOV.W   #0xffff, 0xe(R8)
   \   0002B6   B8431000     MOV.W   #0xffff, 0x10(R8)
   2129          	fs->last_clust = 0;
   \   0002BA   88430A00     MOV.W   #0x0, 0xa(R8)
   \   0002BE   88430C00     MOV.W   #0x0, 0xc(R8)
   2130          
   2131          	/* Get fsinfo if available */
   2132          	if (fmt == FS_FAT32) {
   \   0002C2   79900300     CMP.B   #0x3, R9
   \   0002C6   6420         JNE     ??chk_mounted_25
   2133          	 	fs->fsi_flag = 0;
   \   0002C8   C8430500     MOV.B   #0x0, 0x5(R8)
   2134          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   0002CC   5F485E00     MOV.B   0x5e(R8), R15
   \   0002D0   5E485F00     MOV.B   0x5f(R8), R14
   \   0002D4   8E10         SWPB    R14
   \   0002D6   0EDF         BIS.W   R15, R14
   \   0002D8   0F43         MOV.W   #0x0, R15
   \   0002DA   0A5E         ADD.W   R14, R10
   \   0002DC   0E4A         MOV.W   R10, R14
   \   0002DE   0F6B         ADDC.W  R11, R15
   \   0002E0   884E1200     MOV.W   R14, 0x12(R8)
   \   0002E4   884F1400     MOV.W   R15, 0x14(R8)
   2135          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2136          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2137          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2138          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   0002E8   5312         PUSH.B  #0x1
   \   0002EA   CD08         MOVA    R8, R13
   \   0002EC   AD002E00     ADDA    #0x2e, R13
   \   0002F0   5C480100     MOV.B   0x1(R8), R12
   \   0002F4   ........     CALLA   #disk_read
   \   0002F8   2153         ADD.W   #0x2, SP
   \   0002FA   4C93         CMP.B   #0x0, R12
   \   0002FC   4920         JNE     ??chk_mounted_25
   \   0002FE   5B482C02     MOV.B   0x22c(R8), R11
   \   000302   5F482D02     MOV.B   0x22d(R8), R15
   \   000306   8F10         SWPB    R15
   \   000308   0FDB         BIS.W   R11, R15
   \   00030A   3F9055AA     CMP.W   #0xaa55, R15
   \   00030E   4020         JNE     ??chk_mounted_25
   \   000310   57482E00     MOV.B   0x2e(R8), R7
   \   000314   5D482F00     MOV.B   0x2f(R8), R13
   \   000318   8D10         SWPB    R13
   \   00031A   5A483000     MOV.B   0x30(R8), R10
   \   00031E   5E483100     MOV.B   0x31(R8), R14
   \   000322   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_23:
   \   000326   3E905252     CMP.W   #0x5252, R14
   \   00032A   3220         JNE     ??chk_mounted_25
   \   00032C   3F906141     CMP.W   #0x4161, R15
   \   000330   2F20         JNE     ??chk_mounted_25
   \   000332   57481202     MOV.B   0x212(R8), R7
   \   000336   5D481302     MOV.B   0x213(R8), R13
   \   00033A   8D10         SWPB    R13
   \   00033C   5A481402     MOV.B   0x214(R8), R10
   \   000340   5E481502     MOV.B   0x215(R8), R14
   \   000344   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_24:
   \   000348   3E907272     CMP.W   #0x7272, R14
   \   00034C   2120         JNE     ??chk_mounted_25
   \   00034E   3F904161     CMP.W   #0x6141, R15
   \   000352   1E20         JNE     ??chk_mounted_25
   2139          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   000354   57481A02     MOV.B   0x21a(R8), R7
   \   000358   5D481B02     MOV.B   0x21b(R8), R13
   \   00035C   8D10         SWPB    R13
   \   00035E   5A481C02     MOV.B   0x21c(R8), R10
   \   000362   5E481D02     MOV.B   0x21d(R8), R14
   \   000366   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_25:
   \   00036A   884E0A00     MOV.W   R14, 0xa(R8)
   \   00036E   884F0C00     MOV.W   R15, 0xc(R8)
   2140          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   000372   57481602     MOV.B   0x216(R8), R7
   \   000376   5D481702     MOV.B   0x217(R8), R13
   \   00037A   8D10         SWPB    R13
   \   00037C   5A481802     MOV.B   0x218(R8), R10
   \   000380   5E481902     MOV.B   0x219(R8), R14
   \   000384   ........     CALLA   #?Subroutine17
   2141          		}
   2142          	}
   \                     ??CrossCallReturnLabel_26:
   \   000388   884E0E00     MOV.W   R14, 0xe(R8)
   \   00038C   884F1000     MOV.W   R15, 0x10(R8)
   2143          #endif
   2144          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_25:
   \   000390   C8490000     MOV.B   R9, 0(R8)
   2145          	fs->id = ++Fsid;		/* File system mount ID */
   \   000394   ....9253.... ADDX.W  #0x1, &Fsid
   \   00039A   ....9842.... MOVX.W  &Fsid, 0x6(R8)
   \            0600        
   2146          	fs->winsect = 0;		/* Invalidate sector cache */
   \   0003A2   88432A00     MOV.W   #0x0, 0x2a(R8)
   \   0003A6   88432C00     MOV.W   #0x0, 0x2c(R8)
   2147          	fs->wflag = 0;
   \   0003AA   C8430400     MOV.B   #0x0, 0x4(R8)
   2148          #if _FS_RPATH
   2149          	fs->cdir = 0;			/* Current directory (root dir) */
   2150          #endif
   2151          #if _FS_SHARE				/* Clear file lock semaphores */
   2152          	clear_lock(fs);
   2153          #endif
   2154          
   2155          	return FR_OK;
   \                     ??chk_mounted_2:
   \   0003AE   4C43         MOV.B   #0x0, R12
   \                     ??chk_mounted_4:
   \   0003B0   2153         ADD.W   #0x2, SP
   \   0003B2   7416         POPM.A  #0x8, R11
   \   0003B4   1001         RETA
   2156          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   8E10         SWPB    R14
   \   000002   0F4E         MOV.W   R14, R15
   \   000004   0FDA         BIS.W   R10, R15
   \   000006   0E4D         MOV.W   R13, R14
   \   000008   0ED7         BIS.W   R7, R14
   \   00000A   1001         RETA
   2157          
   2158          
   2159          
   2160          
   2161          /*-----------------------------------------------------------------------*/
   2162          /* Check if the file/dir object is valid or not                          */
   2163          /*-----------------------------------------------------------------------*/
   2164          

   \                                 In  segment CODE, align 2
   2165          static
   2166          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   \                     validate:
   2167          	FATFS *fs,		/* Pointer to the file system object */
   2168          	WORD id			/* Member id of the target object to be checked */
   2169          )
   2170          {
   2171          	if (!fs || !fs->fs_type || fs->id != id)
   \   000000   DC03         CMPA    #0x0, R12
   \   000002   0624         JEQ     ??validate_1
   \   000004   CC930000     CMP.B   #0x0, 0(R12)
   \   000008   0324         JEQ     ??validate_1
   \   00000A   8C9D0600     CMP.W   R13, 0x6(R12)
   \   00000E   0324         JEQ     ??validate_2
   2172          		return FR_INVALID_OBJECT;
   \                     ??validate_1:
   \   000010   7C400900     MOV.B   #0x9, R12
   \   000014   1001         RETA
   2173          
   2174          	ENTER_FF(fs);		/* Lock file system */
   2175          
   2176          	if (disk_status(fs->drv) & STA_NOINIT)
   \                     ??validate_2:
   \   000016   5C4C0100     MOV.B   0x1(R12), R12
   \   00001A   ........     CALLA   #disk_status
   \   00001E   5CB3         BIT.B   #0x1, R12
   \   000020   022C         JC      ??validate_3
   \   000022   4C43         MOV.B   #0x0, R12
   \   000024   1001         RETA
   \                     ??validate_3:
   \   000026   7C400300     MOV.B   #0x3, R12
   2177          		return FR_NOT_READY;
   2178          
   2179          	return FR_OK;
   \   00002A   1001         RETA
   2180          }
   2181          
   2182          
   2183          
   2184          
   2185          /*--------------------------------------------------------------------------
   2186          
   2187             Public Functions
   2188          
   2189          --------------------------------------------------------------------------*/
   2190          
   2191          
   2192          
   2193          /*-----------------------------------------------------------------------*/
   2194          /* Mount/Unmount a Logical Drive                                         */
   2195          /*-----------------------------------------------------------------------*/
   2196          

   \                                 In  segment CODE, align 2
   2197          FRESULT f_mount (
   \                     f_mount:
   2198          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2199          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2200          )
   2201          {
   2202          	FATFS *rfs;
   2203          
   2204          
   2205          	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
   \   000000   4C93         CMP.B   #0x0, R12
   \   000002   0324         JEQ     ??f_mount_0
   2206          		return FR_INVALID_DRIVE;
   \   000004   7C400B00     MOV.B   #0xb, R12
   \   000008   1001         RETA
   2207          	rfs = FatFs[vol];				/* Get current fs object */
   \                     ??f_mount_0:
   \   00000A   ........     MOVA    &FatFs, R15
   2208          
   2209          	if (rfs) {
   \   00000E   DF03         CMPA    #0x0, R15
   \   000010   0224         JEQ     ??f_mount_1
   2210          #if _FS_SHARE
   2211          		clear_lock(rfs);
   2212          #endif
   2213          #if _FS_REENTRANT					/* Discard sync object of the current volume */
   2214          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2215          #endif
   2216          		rfs->fs_type = 0;			/* Clear old fs object */
   \   000012   CF430000     MOV.B   #0x0, 0(R15)
   2217          	}
   2218          
   2219          	if (fs) {
   \                     ??f_mount_1:
   \   000016   DD03         CMPA    #0x0, R13
   \   000018   0224         JEQ     ??f_mount_2
   2220          		fs->fs_type = 0;			/* Clear new fs object */
   \   00001A   CD430000     MOV.B   #0x0, 0(R13)
   2221          #if _FS_REENTRANT					/* Create sync object for the new volume */
   2222          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2223          #endif
   2224          	}
   2225          	FatFs[vol] = fs;				/* Register new fs object */
   \                     ??f_mount_2:
   \   00001E   ........     MOVA    R13, &FatFs
   2226          
   2227          	return FR_OK;
   \   000022   4C43         MOV.B   #0x0, R12
   \   000024   1001         RETA
   2228          }
   2229          
   2230          
   2231          
   2232          
   2233          /*-----------------------------------------------------------------------*/
   2234          /* Open or Create a File                                                 */
   2235          /*-----------------------------------------------------------------------*/
   2236          

   \                                 In  segment CODE, align 2
   2237          FRESULT f_open (
   \                     f_open:
   2238          	FIL *fp,			/* Pointer to the blank file object */
   2239          	const TCHAR *path,	/* Pointer to the file name */
   2240          	BYTE mode			/* Access mode and file open mode flags */
   2241          )
   2242          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   31802800     SUB.W   #0x28, SP
   \   000008   CA0C         MOVA    R12, R10
   \   00000A   4B4E         MOV.B   R14, R11
   2243          	FRESULT res;
   2244          	DIRS dj;
   2245          	BYTE *dir;
   2246          	DEF_NAMEBUF;
   2247          
   2248          
   2249          	fp->fs = 0;			/* Clear file object */
   \   00000C   0018CC430000 MOVX.A  #0x0, 0(R12)
   2250          
   2251          #if !_FS_READONLY
   2252          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   000012   7BF01F00     AND.B   #0x1f, R11
   2253          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   000016   0741         MOV.W   SP, R7
   \   000018   0753         ADD.W   #0x0, R7
   \   00001A   4E4B         MOV.B   R11, R14
   \   00001C   5EC3         BIC.B   #0x1, R14
   \   00001E   0D47         MOV.W   R7, R13
   \   000020   ........     CALLA   #?Subroutine29
   \                     ??CrossCallReturnLabel_38:
   \   000024   494C         MOV.B   R12, R9
   2254          #else
   2255          	mode &= FA_READ;
   2256          	res = chk_mounted(&path, &dj.fs, 0);
   2257          #endif
   2258          	INIT_BUF(dj);
   \   000026   0F41         MOV.W   SP, R15
   \   000028   3F501C00     ADD.W   #0x1c, R15
   \   00002C   710F1800     MOVA    R15, 0x18(SP)
   2259          	if (res == FR_OK)
   \   000030   4C93         CMP.B   #0x0, R12
   \   000032   0620         JNE     ??f_open_4
   2260          		res = follow_path(&dj, path);	/* Follow the file path */
   \   000034   3D012800     MOVA    0x28(SP), R13
   \   000038   0C47         MOV.W   R7, R12
   \   00003A   ........     CALLA   #follow_path
   \   00003E   494C         MOV.B   R12, R9
   2261          	dir = dj.dir;
   \                     ??f_open_4:
   \   000040   38011400     MOVA    0x14(SP), R8
   2262          
   2263          #if !_FS_READONLY	/* R/W configuration */
   2264          	if (res == FR_OK) {
   \   000044   4993         CMP.B   #0x0, R9
   \   000046   0420         JNE     ??f_open_5
   2265          		if (!dir)	/* Current dir itself */
   \   000048   D803         CMPA    #0x0, R8
   \   00004A   0220         JNE     ??f_open_5
   2266          			res = FR_INVALID_NAME;
   \   00004C   79400600     MOV.B   #0x6, R9
   2267          #if _FS_SHARE
   2268          		else
   2269          			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2270          #endif
   2271          	}
   2272          	/* Create or Open a file */
   2273          	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_5:
   \   000050   7BB01C00     BIT.B   #0x1c, R11
   \   000054   AD24         JEQ     ??f_open_6
   2274          		DWORD dw, cl;
   2275          
   2276          		if (res != FR_OK) {					/* No file, create new */
   \   000056   4993         CMP.B   #0x0, R9
   \   000058   A324         JEQ     ??f_open_7
   2277          			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   00005A   6992         CMP.B   #0x4, R9
   \   00005C   0420         JNE     ??f_open_8
   2278          #if _FS_SHARE
   2279          				res = enq_lock(dj.fs) ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2280          #else
   2281          				res = dir_register(&dj);
   \   00005E   0C47         MOV.W   R7, R12
   \   000060   ........     CALLA   #dir_register
   \   000064   494C         MOV.B   R12, R9
   2282          #endif
   2283          			mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_8:
   \   000066   7BD2         BIS.B   #0x8, R11
   2284          			dir = dj.dir;					/* New entry */
   \   000068   38011400     MOVA    0x14(SP), R8
   2285          		}
   2286          		else {								/* Any object is already existing */
   2287          			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIRS) */
   2288          				res = FR_DENIED;
   2289          			} else {
   2290          				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   2291          					res = FR_EXIST;
   2292          			}
   2293          		}
   2294          		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \   00006C   4993         CMP.B   #0x0, R9
   \   00006E   5120         JNE     ??f_open_2
   \                     ??f_open_0:
   \   000070   7BB2         BIT.B   #0x8, R11
   \   000072   5528         JNC     ??f_open_9
   2295          			dw = get_fattime();					/* Created time */
   \   000074   ........     CALLA   #get_fattime
   \   000078   464C         MOV.B   R12, R6
   \   00007A   074D         MOV.W   R13, R7
   2296          			ST_DWORD(dir+DIR_CrtTime, dw);
   \   00007C   C8460E00     MOV.B   R6, 0xe(R8)
   \   000080   0F4C         MOV.W   R12, R15
   \   000082   8F10         SWPB    R15
   \   000084   C84F0F00     MOV.B   R15, 0xf(R8)
   \   000088   C8471000     MOV.B   R7, 0x10(R8)
   \   00008C   8710         SWPB    R7
   \   00008E   4647         MOV.B   R7, R6
   \   000090   C8461100     MOV.B   R6, 0x11(R8)
   2297          			dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000094   C8430B00     MOV.B   #0x0, 0xb(R8)
   2298          			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000098   C8431C00     MOV.B   #0x0, 0x1c(R8)
   \   00009C   C8431D00     MOV.B   #0x0, 0x1d(R8)
   \   0000A0   C8431E00     MOV.B   #0x0, 0x1e(R8)
   \   0000A4   C8431F00     MOV.B   #0x0, 0x1f(R8)
   2299          			cl = LD_CLUST(dir);					/* Get start cluster */
   \   0000A8   5F481A00     MOV.B   0x1a(R8), R15
   \   0000AC   54481B00     MOV.B   0x1b(R8), R4
   \   0000B0   8410         SWPB    R4
   \   0000B2   04DF         BIS.W   R15, R4
   \   0000B4   5F481400     MOV.B   0x14(R8), R15
   \   0000B8   55481500     MOV.B   0x15(R8), R5
   \   0000BC   8510         SWPB    R5
   \   0000BE   05DF         BIS.W   R15, R5
   2300          			ST_CLUST(dir, 0);					/* cluster = 0 */
   \   0000C0   C8431A00     MOV.B   #0x0, 0x1a(R8)
   \   0000C4   C8431B00     MOV.B   #0x0, 0x1b(R8)
   \   0000C8   C8431400     MOV.B   #0x0, 0x14(R8)
   \   0000CC   C8431500     MOV.B   #0x0, 0x15(R8)
   2301          			dj.fs->wflag = 1;
   \   0000D0   0F01         MOVA    @SP, R15
   \   0000D2   DF430400     MOV.B   #0x1, 0x4(R15)
   2302          			if (cl) {							/* Remove the cluster chain if exist */
   \   0000D6   0F44         MOV.W   R4, R15
   \   0000D8   0FD5         BIS.W   R5, R15
   \   0000DA   0F93         CMP.W   #0x0, R15
   \   0000DC   1C24         JEQ     ??f_open_3
   2303          				dw = dj.fs->winsect;
   \   0000DE   0F01         MOVA    @SP, R15
   \   0000E0   164F2A00     MOV.W   0x2a(R15), R6
   \   0000E4   174F2C00     MOV.W   0x2c(R15), R7
   2304          				res = remove_chain(dj.fs, cl);
   \   0000E8   0E44         MOV.W   R4, R14
   \   0000EA   0F45         MOV.W   R5, R15
   \   0000EC   0C01         MOVA    @SP, R12
   \   0000EE   ........     CALLA   #remove_chain
   \   0000F2   494C         MOV.B   R12, R9
   2305          				if (res == FR_OK) {
   \   0000F4   4C93         CMP.B   #0x0, R12
   \   0000F6   0D20         JNE     ??f_open_2
   2306          					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   0000F8   3453         ADD.W   #0xffff, R4
   \   0000FA   3563         ADDC.W  #0xffff, R5
   \   0000FC   0F01         MOVA    @SP, R15
   \   0000FE   8F440A00     MOV.W   R4, 0xa(R15)
   \   000102   8F450C00     MOV.W   R5, 0xc(R15)
   2307          					res = move_window(dj.fs, dw);
   \   000106   0E46         MOV.W   R6, R14
   \   000108   0F47         MOV.W   R7, R15
   \   00010A   0C01         MOVA    @SP, R12
   \   00010C   ........     CALLA   #move_window
   \   000110   494C         MOV.B   R12, R9
   2308          				}
   2309          			}
   2310          		}
   2311          	}
   2312          	else {	/* Open an existing file */
   2313          		if (res == FR_OK) {						/* Follow succeeded */
   2314          			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   2315          				res = FR_NO_FILE;
   2316          			} else {
   2317          				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   2318          					res = FR_DENIED;
   2319          			}
   2320          		}
   2321          	}
   2322          	if (res == FR_OK) {
   \                     ??f_open_2:
   \   000112   4993         CMP.B   #0x0, R9
   \   000114   4020         JNE     ??f_open_1
   2323          		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \                     ??f_open_3:
   \   000116   7BB2         BIT.B   #0x8, R11
   \   000118   0228         JNC     ??f_open_9
   2324          			mode |= FA__WRITTEN;
   \   00011A   7BD02000     BIS.B   #0x20, R11
   2325          		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_9:
   \   00011E   0F01         MOVA    @SP, R15
   \   000120   9A4F2A001C00 MOV.W   0x2a(R15), 0x1c(R10)
   \   000126   9A4F2C001E00 MOV.W   0x2c(R15), 0x1e(R10)
   2326          		fp->dir_ptr = dir;
   \   00012C   7A082000     MOVA    R8, 0x20(R10)
   2327          #if _FS_SHARE
   2328          		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2329          		if (!fp->lockid) res = FR_INT_ERR;
   2330          #endif
   2331          	}
   2332          
   2333          #else				/* R/O configuration */
   2334          	if (res == FR_OK) {					/* Follow succeeded */
   2335          		if (!dir) {						/* Current dir itself */
   2336          			res = FR_INVALID_NAME;
   2337          		} else {
   2338          			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2339          				res = FR_NO_FILE;
   2340          		}
   2341          	}
   2342          #endif
   2343          	FREE_BUF();
   2344          
   2345          	if (res == FR_OK) {
   2346          		fp->flag = mode;					/* File access mode */
   \   000130   CA4B0600     MOV.B   R11, 0x6(R10)
   2347          		fp->sclust = LD_CLUST(dir);			/* File start cluster */
   \   000134   5F481A00     MOV.B   0x1a(R8), R15
   \   000138   5E481B00     MOV.B   0x1b(R8), R14
   \   00013C   8E10         SWPB    R14
   \   00013E   0EDF         BIS.W   R15, R14
   \   000140   5B481400     MOV.B   0x14(R8), R11
   \   000144   5F481500     MOV.B   0x15(R8), R15
   \   000148   8F10         SWPB    R15
   \   00014A   0FDB         BIS.W   R11, R15
   \   00014C   8A4E1000     MOV.W   R14, 0x10(R10)
   \   000150   8A4F1200     MOV.W   R15, 0x12(R10)
   2348          		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   000154   5D481C00     MOV.B   0x1c(R8), R13
   \   000158   5B481D00     MOV.B   0x1d(R8), R11
   \   00015C   8B10         SWPB    R11
   \   00015E   5E481E00     MOV.B   0x1e(R8), R14
   \   000162   56481F00     MOV.B   0x1f(R8), R6
   \   000166   8610         SWPB    R6
   \   000168   0746         MOV.W   R6, R7
   \   00016A   07DE         BIS.W   R14, R7
   \   00016C   064B         MOV.W   R11, R6
   \   00016E   06DD         BIS.W   R13, R6
   \   000170   8A460C00     MOV.W   R6, 0xc(R10)
   \   000174   8A470E00     MOV.W   R7, 0xe(R10)
   2349          		fp->fptr = 0;						/* File pointer */
   \   000178   8A430800     MOV.W   #0x0, 0x8(R10)
   \   00017C   8A430A00     MOV.W   #0x0, 0xa(R10)
   2350          		fp->dsect = 0;
   \   000180   8A431800     MOV.W   #0x0, 0x18(R10)
   \   000184   8A431A00     MOV.W   #0x0, 0x1a(R10)
   2351          #if _USE_FASTSEEK
   2352          		fp->cltbl = 0;						/* Normal seek mode */
   2353          #endif
   2354          		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   000188   0F01         MOVA    @SP, R15
   \   00018A   7A0F0000     MOVA    R15, 0(R10)
   \   00018E   0F01         MOVA    @SP, R15
   \   000190   9A4F06000400 MOV.W   0x6(R15), 0x4(R10)
   2355          	}
   2356          
   2357          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_1:
   \   000196   4C49         MOV.B   R9, R12
   \   000198   31502C00     ADD.W   #0x2c, SP
   \   00019C   7416         POPM.A  #0x8, R11
   \   00019E   1001         RETA
   \                     ??f_open_7:
   \   0001A0   F8B011000B00 BIT.B   #0x11, 0xb(R8)
   \   0001A6   1120         JNE     ??f_open_10
   \   0001A8   6BB2         BIT.B   #0x4, R11
   \   0001AA   622B         JNC     ??f_open_0
   \   0001AC   7942         MOV.B   #0x8, R9
   \   0001AE   F33F         JMP     ??f_open_1
   \                     ??f_open_6:
   \   0001B0   4993         CMP.B   #0x0, R9
   \   0001B2   AF23         JNE     ??f_open_2
   \   0001B4   F8B010000B00 BIT.B   #0x10, 0xb(R8)
   \   0001BA   0228         JNC     ??f_open_11
   \   0001BC   6942         MOV.B   #0x4, R9
   \   0001BE   EB3F         JMP     ??f_open_1
   \                     ??f_open_11:
   \   0001C0   6BB3         BIT.B   #0x2, R11
   \   0001C2   A92B         JNC     ??f_open_3
   \   0001C4   D8B30B00     BIT.B   #0x1, 0xb(R8)
   \   0001C8   A62B         JNC     ??f_open_3
   \                     ??f_open_10:
   \   0001CA   79400700     MOV.B   #0x7, R9
   \   0001CE   E33F         JMP     ??f_open_1
   \   0001D0   0343         NOP
   2358          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine29:
   \   000000   0C41         MOV.W   SP, R12
   \   000002   3C502C00     ADD.W   #0x2c, R12
   \   000006   ........     BRA     #chk_mounted
   2359          
   2360          
   2361          
   2362          
   2363          /*-----------------------------------------------------------------------*/
   2364          /* Read File                                                             */
   2365          /*-----------------------------------------------------------------------*/
   2366          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine36:
   \   000000   1D4C0400     MOV.W   0x4(R12), R13
   \   000004   0C0A         MOVA    @R10, R12
   \   000006   ........     BRA     #validate

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine37:
   \   000000   FAD080000600 BIS.B   #0x80, 0x6(R10)
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine33:
   \   000000   ........     CALLA   #?Subroutine37
   \                     ??CrossCallReturnLabel_58:
   \   000004   5C43         MOV.B   #0x1, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine30:
   \   000000   1E4A1400     MOV.W   0x14(R10), R14
   \   000004   1F4A1600     MOV.W   0x16(R10), R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   C50D         MOVA    R13, R5
   \   000002   8F430000     MOV.W   #0x0, 0(R15)
   \   000006                REQUIRE ??Subroutine42_0
   \   000006                // Fall through to label ??Subroutine42_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   ........     CALLA   #?Subroutine36
   \                     ??CrossCallReturnLabel_98:
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2367          FRESULT f_read (
   \                     f_read:
   2368          	FIL *fp, 		/* Pointer to the file object */
   2369          	void *buff,		/* Pointer to data buffer */
   2370          	UINT btr,		/* Number of bytes to read */
   2371          	UINT *br		/* Pointer to number of bytes read */
   2372          )
   2373          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0F14         PUSHM.A #0x1, R15
   \   000004   CA0C         MOVA    R12, R10
   \   000006   064E         MOV.W   R14, R6
   2374          	FRESULT res;
   2375          	DWORD clst, sect, remain;
   2376          	UINT rcnt, cc;
   2377          	BYTE csect, *rbuff = buff;
   \   000008   ........     CALLA   #?Subroutine21
   2378          
   2379          
   2380          	*br = 0;	/* Initialize byte counter */
   2381          
   2382          	res = validate(fp->fs, fp->id);				/* Check validity */
   \                     ??CrossCallReturnLabel_96:
   \   00000C   B620         JNE     ??f_read_3
   2383          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2384          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \   00000E   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000012   5B38         JL      ??f_read_5
   2385          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2386          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \   000014   DAB30600     BIT.B   #0x1, 0x6(R10)
   \   000018   032C         JC      ??f_read_6
   2387          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00001A   7C400700     MOV.B   #0x7, R12
   \   00001E   AD3C         JMP     ??f_read_3
   2388          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_6:
   \   000020   C70A         MOVA    R10, R7
   \   000022   A7000800     ADDA    #0x8, R7
   \   000026   184A0C00     MOV.W   0xc(R10), R8
   \   00002A   194A0E00     MOV.W   0xe(R10), R9
   \   00002E   2887         SUB.W   @R7, R8
   \   000030   19770200     SUBC.W  0x2(R7), R9
   2389          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   000034   1C20         JNE     ??f_read_7
   \   000036   0896         CMP.W   R6, R8
   \   000038   1A2C         JC      ??f_read_7
   \   00003A   0648         MOV.W   R8, R6
   \   00003C   183C         JMP     ??f_read_7
   2390          
   2391          	for ( ;  btr;								/* Repeat until all data read */
   2392          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2393          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2394          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2395          			if (!csect) {						/* On the cluster boundary? */
   2396          				if (fp->fptr == 0) {			/* On the top of the file? */
   2397          					clst = fp->sclust;			/* Follow from the origin */
   2398          				} else {						/* Middle or end of the file */
   2399          #if _USE_FASTSEEK
   2400          					if (fp->cltbl)
   2401          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2402          					else
   2403          #endif
   2404          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2405          				}
   2406          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2407          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2408          				fp->clust = clst;				/* Update current cluster */
   2409          			}
   2410          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2411          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2412          			sect += csect;
   2413          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2414          			if (cc) {							/* Read maximum contiguous sectors directly */
   2415          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2416          					cc = fp->fs->csize - csect;
   2417          				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2418          					ABORT(fp->fs, FR_DISK_ERR);
   2419          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2420          #if _FS_TINY
   2421          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2422          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2423          #else
   2424          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2425          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2426          #endif
   2427          #endif
   2428          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2429          				continue;
   2430          			}
   2431          #if !_FS_TINY
   2432          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2433          #if !_FS_READONLY
   2434          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2435          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2436          						ABORT(fp->fs, FR_DISK_ERR);
   2437          					fp->flag &= ~FA__DIRTY;
   2438          				}
   2439          #endif
   2440          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2441          					ABORT(fp->fs, FR_DISK_ERR);
   2442          			}
   2443          #endif
   2444          			fp->dsect = sect;
   2445          		}
   2446          		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   2447          		if (rcnt > btr) rcnt = btr;
   2448          #if _FS_TINY
   2449          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2450          			ABORT(fp->fs, FR_DISK_ERR);
   2451          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_1:
   \   00003E   0D0A         MOVA    @R10, R13
   \   000040   3E40FF01     MOV.W   #0x1ff, R14
   \   000044   0F43         MOV.W   #0x0, R15
   \   000046   2EF7         AND.W   @R7, R14
   \   000048   1F15         PUSHM.W #0x2, R15
   \   00004A   0F16         POPM.A  #0x1, R15
   \   00004C   ED0F         ADDA    R15, R13
   \   00004E   AD002E00     ADDA    #0x2e, R13
   \   000052   0E44         MOV.W   R4, R14
   \   000054   CC05         MOVA    R5, R12
   \   000056   ........     CALLA   #mem_cpy
   \                     ??f_read_0:
   \   00005A   E504         ADDA    R4, R5
   \   00005C   0E44         MOV.W   R4, R14
   \   00005E   8A5E0800     ADD.W   R14, 0x8(R10)
   \   000062   8A630A00     ADDC.W  #0x0, 0xa(R10)
   \   000066   0F01         MOVA    @SP, R15
   \   000068   8F540000     ADD.W   R4, 0(R15)
   \   00006C   0684         SUB.W   R4, R6
   \                     ??f_read_7:
   \   00006E   0693         CMP.W   #0x0, R6
   \   000070   8324         JEQ     ??f_read_8
   \   000072   2E47         MOV.W   @R7, R14
   \   000074   1F470200     MOV.W   0x2(R7), R15
   \   000078   3EB0FF01     BIT.W   #0x1ff, R14
   \   00007C   6920         JNE     ??f_read_9
   \   00007E   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_35:
   \   000082   4B4C         MOV.B   R12, R11
   \   000084   5D480200     MOV.B   0x2(R8), R13
   \   000088   7D53         ADD.B   #0xff, R13
   \   00008A   4BFD         AND.B   R13, R11
   \   00008C   1920         JNE     ??f_read_10
   \   00008E   ........     CALLA   #??Subroutine19_0
   \                     ??CrossCallReturnLabel_106:
   \   000092   0520         JNE     ??f_read_11
   \   000094   1C4A1000     MOV.W   0x10(R10), R12
   \   000098   1D4A1200     MOV.W   0x12(R10), R13
   \   00009C   053C         JMP     ??f_read_12
   \                     ??f_read_11:
   \   00009E   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_44:
   \   0000A2   CC08         MOVA    R8, R12
   \   0000A4   ........     CALLA   #get_fat
   \                     ??f_read_12:
   \   0000A8   0D93         CMP.W   #0x0, R13
   \   0000AA   0220         JNE     ??f_read_13
   \   0000AC   2C93         CMP.W   #0x2, R12
   \   0000AE   0B28         JNC     ??f_read_14
   \                     ??f_read_13:
   \   0000B0   3C93         CMP.W   #0xffff, R12
   \   0000B2   0220         JNE     ??f_read_15
   \   0000B4   3D93         CMP.W   #0xffff, R13
   \   0000B6   5D24         JEQ     ??f_read_16
   \                     ??f_read_15:
   \   0000B8   8A4C1400     MOV.W   R12, 0x14(R10)
   \   0000BC   8A4D1600     MOV.W   R13, 0x16(R10)
   \                     ??f_read_10:
   \   0000C0   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_60:
   \   0000C4   0420         JNE     ??f_read_17
   \                     ??f_read_14:
   \   0000C6   ........     CALLA   #?Subroutine37
   \                     ??f_read_5:
   \   0000CA   6C43         MOV.B   #0x2, R12
   \   0000CC   563C         JMP     ??f_read_3
   \                     ??f_read_17:
   \   0000CE   085B         ADD.W   R11, R8
   \   0000D0   0963         ADDC.W  #0x0, R9
   \   0000D2   0446         MOV.W   R6, R4
   \   0000D4   8410         SWPB    R4
   \   0000D6   74F3         AND.B   #0xff, R4
   \   0000D8   0411         RRA.W   R4
   \   0000DA   4493         CMP.B   #0x0, R4
   \   0000DC   3524         JEQ     ??f_read_18
   \   0000DE   0C0A         MOVA    @R10, R12
   \   0000E0   5E4C0200     MOV.B   0x2(R12), R14
   \   0000E4   4F4B         MOV.B   R11, R15
   \   0000E6   0F54         ADD.W   R4, R15
   \   0000E8   0E9F         CMP.W   R15, R14
   \   0000EA   022C         JC      ??f_read_19
   \   0000EC   444E         MOV.B   R14, R4
   \   0000EE   048B         SUB.W   R11, R4
   \                     ??f_read_19:
   \   0000F0   4412         PUSH.B  R4
   \   0000F2   0E48         MOV.W   R8, R14
   \   0000F4   0F49         MOV.W   R9, R15
   \   0000F6   CD05         MOVA    R5, R13
   \   0000F8   5C4C0100     MOV.B   0x1(R12), R12
   \   0000FC   ........     CALLA   #disk_read
   \   000100   2153         ADD.W   #0x2, SP
   \   000102   4C93         CMP.B   #0x0, R12
   \   000104   3620         JNE     ??f_read_16
   \   000106   0D0A         MOVA    @R10, R13
   \   000108   CD930400     CMP.B   #0x0, 0x4(R13)
   \   00010C   1A24         JEQ     ??f_read_20
   \   00010E   1E4D2A00     MOV.W   0x2a(R13), R14
   \   000112   1F4D2C00     MOV.W   0x2c(R13), R15
   \   000116   0E88         SUB.W   R8, R14
   \   000118   0F79         SUBC.W  R9, R15
   \   00011A   0C4E         MOV.W   R14, R12
   \   00011C   094F         MOV.W   R15, R9
   \   00011E   1120         JNE     ??f_read_20
   \   000120   0E94         CMP.W   R4, R14
   \   000122   0F2C         JC      ??f_read_20
   \   000124   3E400002     MOV.W   #0x200, R14
   \   000128   AD002E00     ADDA    #0x2e, R13
   \   00012C   CF0D         MOVA    R13, R15
   \   00012E   0D49         MOV.W   R9, R13
   \   000130   ........     CALLA   #?ShiftLeft32_9
   \   000134   1D15         PUSHM.W #0x2, R13
   \   000136   0B16         POPM.A  #0x1, R11
   \   000138   CC05         MOVA    R5, R12
   \   00013A   EC0B         ADDA    R11, R12
   \   00013C   CD0F         MOVA    R15, R13
   \   00013E   ........     CALLA   #mem_cpy
   \                     ??f_read_20:
   \   000142   4454         RLA.B   R4
   \   000144   8410         SWPB    R4
   \   000146   893F         JMP     ??f_read_0
   \                     ??f_read_18:
   \   000148   8A481800     MOV.W   R8, 0x18(R10)
   \   00014C   8A491A00     MOV.W   R9, 0x1a(R10)
   \                     ??f_read_9:
   \   000150   34400002     MOV.W   #0x200, R4
   \   000154   3F40FF01     MOV.W   #0x1ff, R15
   \   000158   2FF7         AND.W   @R7, R15
   \   00015A   048F         SUB.W   R15, R4
   \   00015C   0694         CMP.W   R4, R6
   \   00015E   012C         JC      ??f_read_21
   \   000160   0446         MOV.W   R6, R4
   \                     ??f_read_21:
   \   000162   1E4A1800     MOV.W   0x18(R10), R14
   \   000166   1F4A1A00     MOV.W   0x1a(R10), R15
   \   00016A   0C0A         MOVA    @R10, R12
   \   00016C   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_81:
   \   000170   6627         JEQ     ??f_read_1
   \                     ??f_read_16:
   \   000172   ........     CALLA   #?Subroutine33
   2452          #else
   2453          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2454          #endif
   2455          	}
   \                     ??CrossCallReturnLabel_52:
   \   000176   013C         JMP     ??f_read_3
   2456          
   2457          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_8:
   \   000178   4C43         MOV.B   #0x0, R12
   \                     ??f_read_3:
   \   00017A                REQUIRE ?Subroutine0
   \   00017A                // Fall through to label ?Subroutine0
   2458          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   2152         ADD.W   #0x4, SP
   \   000002   7416         POPM.A  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine27:
   \   000000   080A         MOVA    @R10, R8
   \   000002   0C4E         MOV.W   R14, R12
   \   000004   0D4F         MOV.W   R15, R13
   \   000006   ........     BRA     #?ShiftRight32u_9

   \                                 In  segment CODE, align 2
   \                     ?Subroutine20:
   \   000000   1E4A1400     MOV.W   0x14(R10), R14
   \   000004   1F4A1600     MOV.W   0x16(R10), R15
   \   000008   0C0A         MOVA    @R10, R12
   \   00000A   ........     CALLA   #clust2sect
   \   00000E   084C         MOV.W   R12, R8
   \   000010   094D         MOV.W   R13, R9
   \   000012   ........     BRA     #?Subroutine38
   2459          
   2460          
   2461          
   2462          
   2463          #if !_FS_READONLY
   2464          /*-----------------------------------------------------------------------*/
   2465          /* Write File                                                            */
   2466          /*-----------------------------------------------------------------------*/
   2467          

   \                                 In  segment CODE, align 2, keep-with-next
   2468          FRESULT f_write (
   \                     f_write:
   2469          	FIL *fp,			/* Pointer to the file object */
   2470          	const void *buff,	/* Pointer to the data to be written */
   2471          	UINT btw,			/* Number of bytes to write */
   2472          	UINT *bw			/* Pointer to number of bytes written */
   2473          )
   2474          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0F14         PUSHM.A #0x1, R15
   \   000004   CA0C         MOVA    R12, R10
   \   000006   044E         MOV.W   R14, R4
   2475          	FRESULT res;
   2476          	DWORD clst, sect;
   2477          	UINT wcnt, cc;
   2478          	const BYTE *wbuff = buff;
   \   000008   ........     CALLA   #?Subroutine21
   2479          	BYTE csect;
   2480          
   2481          
   2482          	*bw = 0;	/* Initialize byte counter */
   2483          
   2484          	res = validate(fp->fs, fp->id);			/* Check validity */
   \                     ??CrossCallReturnLabel_95:
   \   00000C   2B20         JNE     ??f_write_1
   2485          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2486          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \   00000E   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000012   0234         JGE     ??f_write_6
   2487          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \                     ??f_write_21:
   \   000014   6C43         MOV.B   #0x2, R12
   \   000016   263C         JMP     ??f_write_1
   2488          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_6:
   \   000018   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   00001C   032C         JC      ??f_write_7
   2489          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00001E   7C400700     MOV.B   #0x7, R12
   \   000022   203C         JMP     ??f_write_1
   \                     ??f_write_7:
   \   000024   184A0C00     MOV.W   0xc(R10), R8
   \   000028   194A0E00     MOV.W   0xe(R10), R9
   \   00002C   0648         MOV.W   R8, R6
   \   00002E   0749         MOV.W   R9, R7
   \   000030   0654         ADD.W   R4, R6
   \   000032   0763         ADDC.W  #0x0, R7
   \   000034   0799         CMP.W   R9, R7
   \   000036   0328         JNC     ??f_write_4
   \   000038   3020         JNE     ??f_write_8
   \   00003A   0698         CMP.W   R8, R6
   \   00003C   2E2C         JC      ??f_write_8
   2490          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   2491          
   2492          	for ( ;  btw;							/* Repeat until all data written */
   2493          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2494          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2495          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2496          			if (!csect) {					/* On the cluster boundary? */
   2497          				if (fp->fptr == 0) {		/* On the top of the file? */
   2498          					clst = fp->sclust;		/* Follow from the origin */
   2499          					if (clst == 0)			/* When no cluster is allocated, */
   2500          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2501          				} else {					/* Middle or end of the file */
   2502          #if _USE_FASTSEEK
   2503          					if (fp->cltbl)
   2504          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2505          					else
   2506          #endif
   2507          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2508          				}
   2509          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2510          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2511          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2512          				fp->clust = clst;			/* Update current cluster */
   2513          			}
   2514          #if _FS_TINY
   2515          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   2516          				ABORT(fp->fs, FR_DISK_ERR);
   2517          #else
   2518          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2519          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2520          					ABORT(fp->fs, FR_DISK_ERR);
   2521          				fp->flag &= ~FA__DIRTY;
   2522          			}
   2523          #endif
   2524          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2525          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2526          			sect += csect;
   2527          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2528          			if (cc) {						/* Write maximum contiguous sectors directly */
   2529          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2530          					cc = fp->fs->csize - csect;
   2531          				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2532          					ABORT(fp->fs, FR_DISK_ERR);
   2533          #if _FS_TINY
   2534          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2535          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2536          					fp->fs->wflag = 0;
   2537          				}
   2538          #else
   2539          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2540          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2541          					fp->flag &= ~FA__DIRTY;
   2542          				}
   2543          #endif
   2544          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2545          				continue;
   2546          			}
   2547          #if _FS_TINY
   2548          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2549          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2550          				fp->fs->winsect = sect;
   2551          			}
   2552          #else
   2553          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2554          				if (fp->fptr < fp->fsize &&
   2555          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2556          						ABORT(fp->fs, FR_DISK_ERR);
   2557          			}
   2558          #endif
   2559          			fp->dsect = sect;
   2560          		}
   2561          		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   2562          		if (wcnt > btw) wcnt = btw;
   2563          #if _FS_TINY
   2564          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2565          			ABORT(fp->fs, FR_DISK_ERR);
   2566          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2567          		fp->fs->wflag = 1;
   2568          #else
   2569          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2570          		fp->flag |= FA__DIRTY;
   2571          #endif
   2572          	}
   2573          
   2574          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_4:
   \   00003E   CB0A         MOVA    R10, R11
   \   000040   AB000800     ADDA    #0x8, R11
   \   000044   9A9B02000E00 CMP.W   0x2(R11), 0xe(R10)
   \   00004A   0428         JNC     ??f_write_9
   \   00004C   0720         JNE     ??f_write_10
   \   00004E   AA9B0C00     CMP.W   @R11, 0xc(R10)
   \   000052   042C         JC      ??f_write_10
   \                     ??f_write_9:
   \   000054   BA4B0C00     MOV.W   @R11+, 0xc(R10)
   \   000058   BA4B0E00     MOV.W   @R11+, 0xe(R10)
   2575          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_10:
   \   00005C   FAD020000600 BIS.B   #0x20, 0x6(R10)
   2576          
   2577          	LEAVE_FF(fp->fs, FR_OK);
   \   000062   4C43         MOV.B   #0x0, R12
   \                     ??f_write_1:
   \   000064   ....         JMP     ?Subroutine0
   \                     ??f_write_3:
   \   000066   CD05         MOVA    R5, R13
   \   000068   0C0A         MOVA    @R10, R12
   \   00006A   3E40FF01     MOV.W   #0x1ff, R14
   \   00006E   0F43         MOV.W   #0x0, R15
   \   000070   3EFB         AND.W   @R11+, R14
   \   000072   1F15         PUSHM.W #0x2, R15
   \   000074   0F16         POPM.A  #0x1, R15
   \   000076   EC0F         ADDA    R15, R12
   \   000078   AC002E00     ADDA    #0x2e, R12
   \   00007C   0E46         MOV.W   R6, R14
   \   00007E   ........     CALLA   #mem_cpy
   \   000082   0F0A         MOVA    @R10, R15
   \   000084   DF430400     MOV.B   #0x1, 0x4(R15)
   \                     ??f_write_2:
   \   000088   E506         ADDA    R6, R5
   \   00008A   8A560800     ADD.W   R6, 0x8(R10)
   \   00008E   8A630A00     ADDC.W  #0x0, 0xa(R10)
   \   000092   0F01         MOVA    @SP, R15
   \   000094   8F560000     ADD.W   R6, 0(R15)
   \   000098   0486         SUB.W   R6, R4
   \                     ??f_write_8:
   \   00009A   0493         CMP.W   #0x0, R4
   \   00009C   D027         JEQ     ??f_write_4
   \   00009E   CB0A         MOVA    R10, R11
   \   0000A0   AB000800     ADDA    #0x8, R11
   \   0000A4   2E4B         MOV.W   @R11, R14
   \   0000A6   1F4B0200     MOV.W   0x2(R11), R15
   \   0000AA   3EB0FF01     BIT.W   #0x1ff, R14
   \   0000AE   9520         JNE     ??f_write_11
   \   0000B0   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_34:
   \   0000B4   474C         MOV.B   R12, R7
   \   0000B6   5D480200     MOV.B   0x2(R8), R13
   \   0000BA   7D53         ADD.B   #0xff, R13
   \   0000BC   47FD         AND.B   R13, R7
   \   0000BE   2820         JNE     ??f_write_12
   \   0000C0   ........     CALLA   #??Subroutine19_0
   \                     ??CrossCallReturnLabel_105:
   \   0000C4   1120         JNE     ??f_write_13
   \   0000C6   1C4A1000     MOV.W   0x10(R10), R12
   \   0000CA   1D4A1200     MOV.W   0x12(R10), R13
   \   0000CE   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_69:
   \   0000D2   0F20         JNE     ??f_write_14
   \   0000D4   0E43         MOV.W   #0x0, R14
   \   0000D6   0F43         MOV.W   #0x0, R15
   \   0000D8   CC08         MOVA    R8, R12
   \   0000DA   ........     CALLA   #create_chain
   \   0000DE   8A4C1000     MOV.W   R12, 0x10(R10)
   \   0000E2   8A4D1200     MOV.W   R13, 0x12(R10)
   \   0000E6   053C         JMP     ??f_write_14
   \                     ??f_write_13:
   \   0000E8   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_43:
   \   0000EC   CC08         MOVA    R8, R12
   \   0000EE   ........     CALLA   #create_chain
   \                     ??f_write_14:
   \   0000F2   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_70:
   \   0000F6   A327         JEQ     ??f_write_4
   \   0000F8   1C93         CMP.W   #0x1, R12
   \   0000FA   0220         JNE     ??f_write_15
   \   0000FC   0D93         CMP.W   #0x0, R13
   \   0000FE   1924         JEQ     ??f_write_16
   \                     ??f_write_15:
   \   000100   3C93         CMP.W   #0xffff, R12
   \   000102   0220         JNE     ??f_write_17
   \   000104   3D93         CMP.W   #0xffff, R13
   \   000106   7A24         JEQ     ??f_write_18
   \                     ??f_write_17:
   \   000108   8A4C1400     MOV.W   R12, 0x14(R10)
   \   00010C   8A4D1600     MOV.W   R13, 0x16(R10)
   \                     ??f_write_12:
   \   000110   0C0A         MOVA    @R10, R12
   \   000112   9C9A18002A00 CMP.W   0x18(R10), 0x2a(R12)
   \   000118   0920         JNE     ??f_write_19
   \   00011A   9C9A1A002C00 CMP.W   0x1a(R10), 0x2c(R12)
   \   000120   0520         JNE     ??f_write_19
   \   000122   0E43         MOV.W   #0x0, R14
   \   000124   0F43         MOV.W   #0x0, R15
   \   000126   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_78:
   \   00012A   6820         JNE     ??f_write_18
   \                     ??f_write_19:
   \   00012C   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_59:
   \   000130   0320         JNE     ??f_write_20
   \                     ??f_write_16:
   \   000132   ........     CALLA   #?Subroutine37
   \                     ??CrossCallReturnLabel_57:
   \   000136   6E3F         JMP     ??f_write_21
   \                     ??f_write_20:
   \   000138   0E47         MOV.W   R7, R14
   \   00013A   0F43         MOV.W   #0x0, R15
   \   00013C   0857         ADD.W   R7, R8
   \   00013E   0963         ADDC.W  #0x0, R9
   \   000140   0644         MOV.W   R4, R6
   \   000142   8610         SWPB    R6
   \   000144   76F3         AND.B   #0xff, R6
   \   000146   0611         RRA.W   R6
   \   000148   4693         CMP.B   #0x0, R6
   \   00014A   3024         JEQ     ??f_write_22
   \   00014C   0B0A         MOVA    @R10, R11
   \   00014E   5F4B0200     MOV.B   0x2(R11), R15
   \   000152   0E56         ADD.W   R6, R14
   \   000154   0F9E         CMP.W   R14, R15
   \   000156   022C         JC      ??f_write_23
   \   000158   464F         MOV.B   R15, R6
   \   00015A   0687         SUB.W   R7, R6
   \                     ??f_write_23:
   \   00015C   4612         PUSH.B  R6
   \   00015E   0E48         MOV.W   R8, R14
   \   000160   0F49         MOV.W   R9, R15
   \   000162   CD05         MOVA    R5, R13
   \   000164   5C4B0100     MOV.B   0x1(R11), R12
   \   000168   ........     CALLA   #disk_write
   \   00016C   2153         ADD.W   #0x2, SP
   \   00016E   4C93         CMP.B   #0x0, R12
   \   000170   4520         JNE     ??f_write_18
   \   000172   0F0A         MOVA    @R10, R15
   \   000174   1C4F2A00     MOV.W   0x2a(R15), R12
   \   000178   1D4F2C00     MOV.W   0x2c(R15), R13
   \   00017C   0C88         SUB.W   R8, R12
   \   00017E   0D79         SUBC.W  R9, R13
   \   000180   1220         JNE     ??f_write_24
   \   000182   0C96         CMP.W   R6, R12
   \   000184   102C         JC      ??f_write_24
   \   000186   3E400002     MOV.W   #0x200, R14
   \   00018A   ........     CALLA   #?ShiftLeft32_9
   \   00018E   1D15         PUSHM.W #0x2, R13
   \   000190   0B16         POPM.A  #0x1, R11
   \   000192   CD05         MOVA    R5, R13
   \   000194   ED0B         ADDA    R11, R13
   \   000196   AF002E00     ADDA    #0x2e, R15
   \   00019A   CC0F         MOVA    R15, R12
   \   00019C   ........     CALLA   #mem_cpy
   \   0001A0   0F0A         MOVA    @R10, R15
   \   0001A2   CF430400     MOV.B   #0x0, 0x4(R15)
   \                     ??f_write_24:
   \   0001A6   4656         RLA.B   R6
   \   0001A8   8610         SWPB    R6
   \   0001AA   6E3F         JMP     ??f_write_2
   \                     ??f_write_22:
   \   0001AC   9A9A0E000A00 CMP.W   0xe(R10), 0xa(R10)
   \   0001B2   0F28         JNC     ??f_write_25
   \   0001B4   0420         JNE     ??f_write_26
   \   0001B6   9A9A0C000800 CMP.W   0xc(R10), 0x8(R10)
   \   0001BC   0A28         JNC     ??f_write_25
   \                     ??f_write_26:
   \   0001BE   0E43         MOV.W   #0x0, R14
   \   0001C0   0C0A         MOVA    @R10, R12
   \   0001C2   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_79:
   \   0001C6   1A20         JNE     ??f_write_18
   \   0001C8   0F0A         MOVA    @R10, R15
   \   0001CA   8F482A00     MOV.W   R8, 0x2a(R15)
   \   0001CE   8F492C00     MOV.W   R9, 0x2c(R15)
   \                     ??f_write_25:
   \   0001D2   8A481800     MOV.W   R8, 0x18(R10)
   \   0001D6   8A491A00     MOV.W   R9, 0x1a(R10)
   \                     ??f_write_11:
   \   0001DA   36400002     MOV.W   #0x200, R6
   \   0001DE   3F40FF01     MOV.W   #0x1ff, R15
   \   0001E2   2FFB         AND.W   @R11, R15
   \   0001E4   068F         SUB.W   R15, R6
   \   0001E6   0496         CMP.W   R6, R4
   \   0001E8   012C         JC      ??f_write_27
   \   0001EA   0644         MOV.W   R4, R6
   \                     ??f_write_27:
   \   0001EC   1E4A1800     MOV.W   0x18(R10), R14
   \   0001F0   1F4A1A00     MOV.W   0x1a(R10), R15
   \   0001F4   0C0A         MOVA    @R10, R12
   \   0001F6   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_80:
   \   0001FA   3527         JEQ     ??f_write_3
   \                     ??f_write_18:
   \   0001FC   ........     CALLA   #?Subroutine33
   \                     ??CrossCallReturnLabel_51:
   \   000200   313F         JMP     ??f_write_1
   \   000202   0343         NOP
   2578          }
   2579          
   2580          
   2581          
   2582          
   2583          /*-----------------------------------------------------------------------*/
   2584          /* Synchronize the File Object                                           */
   2585          /*-----------------------------------------------------------------------*/
   2586          

   \                                 In  segment CODE, align 2, keep-with-next
   2587          FRESULT f_sync (
   \                     f_sync:
   2588          	FIL *fp		/* Pointer to the file object */
   2589          )
   2590          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   ........     CALLA   #?Subroutine8
   2591          	FRESULT res;
   2592          	DWORD tim;
   2593          	BYTE *dir;
   2594          
   2595          
   2596          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   2597          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_100:
   \   000006   4C93         CMP.B   #0x0, R12
   \   000008   4920         JNE     ??f_sync_0
   2598          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000A   FAB020000600 BIT.B   #0x20, 0x6(R10)
   \   000010   4528         JNC     ??f_sync_0
   2599          #if !_FS_TINY	/* Write-back dirty buffer */
   2600          			if (fp->flag & FA__DIRTY) {
   2601          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2602          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   2603          				fp->flag &= ~FA__DIRTY;
   2604          			}
   2605          #endif
   2606          			/* Update the directory entry */
   2607          			res = move_window(fp->fs, fp->dir_sect);
   \   000012   1E4A1C00     MOV.W   0x1c(R10), R14
   \   000016   1F4A1E00     MOV.W   0x1e(R10), R15
   \   00001A   0C0A         MOVA    @R10, R12
   \   00001C   ........     CALLA   #?Subroutine39
   2608          			if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_77:
   \   000020   3D20         JNE     ??f_sync_0
   2609          				dir = fp->dir_ptr;
   \   000022   3B0A2000     MOVA    0x20(R10), R11
   2610          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   000026   FBD020000B00 BIS.B   #0x20, 0xb(R11)
   2611          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00002C   CF0A         MOVA    R10, R15
   \   00002E   AF000C00     ADDA    #0xc, R15
   \   000032   EB4F1C00     MOV.B   @R15, 0x1c(R11)
   \   000036   DB4F01001D00 MOV.B   0x1(R15), 0x1d(R11)
   \   00003C   5E4F0200     MOV.B   0x2(R15), R14
   \   000040   CB4E1E00     MOV.B   R14, 0x1e(R11)
   \   000044   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_16:
   \   000048   CB4E1F00     MOV.B   R14, 0x1f(R11)
   2612          				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
   \   00004C   CF0A         MOVA    R10, R15
   \   00004E   AF001000     ADDA    #0x10, R15
   \   000052   EB4F1A00     MOV.B   @R15, 0x1a(R11)
   \   000056   DB4F01001B00 MOV.B   0x1(R15), 0x1b(R11)
   \   00005C   5E4F0200     MOV.B   0x2(R15), R14
   \   000060   CB4E1400     MOV.B   R14, 0x14(R11)
   \   000064   3E4F         MOV.W   @R15+, R14
   \   000066   3F4F         MOV.W   @R15+, R15
   \   000068   8F10         SWPB    R15
   \   00006A   CB4F1500     MOV.B   R15, 0x15(R11)
   2613          				tim = get_fattime();						/* Update updated time */
   \   00006E   ........     CALLA   #get_fattime
   2614          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   000072   CB4C1600     MOV.B   R12, 0x16(R11)
   \   000076   0F4C         MOV.W   R12, R15
   \   000078   8F10         SWPB    R15
   \   00007A   CB4F1700     MOV.B   R15, 0x17(R11)
   \   00007E   CB4D1800     MOV.B   R13, 0x18(R11)
   \   000082   8D10         SWPB    R13
   \   000084   4C4D         MOV.B   R13, R12
   \   000086   CB4C1900     MOV.B   R12, 0x19(R11)
   2615          				fp->flag &= ~FA__WRITTEN;
   \   00008A   FAC020000600 BIC.B   #0x20, 0x6(R10)
   2616          				fp->fs->wflag = 1;
   \   000090   0F0A         MOVA    @R10, R15
   \   000092   DF430400     MOV.B   #0x1, 0x4(R15)
   2617          				res = sync(fp->fs);
   \   000096   0C0A         MOVA    @R10, R12
   \   000098   ........     CALLA   #sync
   2618          			}
   2619          		}
   2620          	}
   2621          
   2622          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   00009C   1A16         POPM.A  #0x2, R11
   \   00009E   1001         RETA
   2623          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   CA0C         MOVA    R12, R10
   \   000002                REQUIRE ?Subroutine36
   \   000002                // Fall through to label ?Subroutine36
   2624          
   2625          #endif /* !_FS_READONLY */
   2626          
   2627          
   2628          
   2629          
   2630          /*-----------------------------------------------------------------------*/
   2631          /* Close File                                                            */
   2632          /*-----------------------------------------------------------------------*/
   2633          

   \                                 In  segment CODE, align 2, keep-with-next
   2634          FRESULT f_close (
   \                     f_close:
   2635          	FIL *fp		/* Pointer to the file object to be closed */
   2636          )
   2637          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
   2638          	FRESULT res;
   2639          
   2640          #if _FS_READONLY
   2641          	FATFS *fs = fp->fs;
   2642          	res = validate(fs, fp->id);
   2643          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2644          	LEAVE_FF(fs, res);
   2645          
   2646          #else
   2647          	res = f_sync(fp);		/* Flush cached data */
   \   000004   ........     CALLA   #f_sync
   2648          #if _FS_SHARE
   2649          	if (res == FR_OK) {		/* Decrement open counter */
   2650          #if _FS_REENTRANT
   2651          		res = validate(fp->fs, fp->id);
   2652          		if (res == FR_OK) {
   2653          			res = dec_lock(fp->lockid);	
   2654          			unlock_fs(fp->fs, FR_OK);
   2655          		}
   2656          #else
   2657          		res = dec_lock(fp->lockid);
   2658          #endif
   2659          	}
   2660          #endif
   2661          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   0320         JNE     ??f_close_0
   \   00000C   0018CA430000 MOVX.A  #0x0, 0(R10)
   2662          	return res;
   \                     ??f_close_0:
   \   000012   0A16         POPM.A  #0x1, R10
   \   000014   1001         RETA
   2663          #endif
   2664          }
   2665          
   2666          
   2667          
   2668          
   2669          /*-----------------------------------------------------------------------*/
   2670          /* Current Drive/Directory Handlings                                     */
   2671          /*-----------------------------------------------------------------------*/
   2672          
   2673          #if _FS_RPATH >= 1
   2674          
   2675          FRESULT f_chdrive (
   2676          	BYTE drv		/* Drive number */
   2677          )
   2678          {
   2679          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   2680          
   2681          	CurrVol = drv;
   2682          
   2683          	return FR_OK;
   2684          }
   2685          
   2686          
   2687          
   2688          FRESULT f_chdir (
   2689          	const TCHAR *path	/* Pointer to the directory path */
   2690          )
   2691          {
   2692          	FRESULT res;
   2693          	DIRS dj;
   2694          	DEF_NAMEBUF;
   2695          
   2696          
   2697          	res = chk_mounted(&path, &dj.fs, 0);
   2698          	if (res == FR_OK) {
   2699          		INIT_BUF(dj);
   2700          		res = follow_path(&dj, path);		/* Follow the path */
   2701          		FREE_BUF();
   2702          		if (res == FR_OK) {					/* Follow completed */
   2703          			if (!dj.dir) {
   2704          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   2705          			} else {
   2706          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   2707          					dj.fs->cdir = LD_CLUST(dj.dir);
   2708          				else
   2709          					res = FR_NO_PATH;		/* Reached but a file */
   2710          			}
   2711          		}
   2712          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   2713          	}
   2714          
   2715          	LEAVE_FF(dj.fs, res);
   2716          }
   2717          
   2718          
   2719          #if _FS_RPATH >= 2
   2720          FRESULT f_getcwd (
   2721          	TCHAR *path,	/* Pointer to the directory path */
   2722          	UINT sz_path	/* Size of path */
   2723          )
   2724          {
   2725          	FRESULT res;
   2726          	DIRS dj;
   2727          	UINT i, n;
   2728          	DWORD ccl;
   2729          	TCHAR *tp;
   2730          	FILINFO fno;
   2731          	DEF_NAMEBUF;
   2732          
   2733          
   2734          	*path = 0;
   2735          	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
   2736          	if (res == FR_OK) {
   2737          		INIT_BUF(dj);
   2738          		i = sz_path;		/* Bottom of buffer (dir stack base) */
   2739          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   2740          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   2741          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   2742          			if (res != FR_OK) break;
   2743          			res = dir_read(&dj);
   2744          			if (res != FR_OK) break;
   2745          			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
   2746          			res = dir_sdi(&dj, 0);
   2747          			if (res != FR_OK) break;
   2748          			do {							/* Find the entry links to the child dir */
   2749          				res = dir_read(&dj);
   2750          				if (res != FR_OK) break;
   2751          				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
   2752          				res = dir_next(&dj, 0);	
   2753          			} while (res == FR_OK);
   2754          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2755          			if (res != FR_OK) break;
   2756          #if _USE_LFN
   2757          			fno.lfname = path;
   2758          			fno.lfsize = i;
   2759          #endif
   2760          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   2761          			tp = fno.fname;
   2762          			if (_USE_LFN && *path) tp = path;
   2763          			for (n = 0; tp[n]; n++) ;
   2764          			if (i < n + 3) {
   2765          				res = FR_NOT_ENOUGH_CORE; break;
   2766          			}
   2767          			while (n) path[--i] = tp[--n];
   2768          			path[--i] = '/';
   2769          		}
   2770          		tp = path;
   2771          		if (res == FR_OK) {
   2772          			*tp++ = '0' + CurrVol;			/* Put drive number */
   2773          			*tp++ = ':';
   2774          			if (i == sz_path) {				/* Root-dir */
   2775          				*tp++ = '/';
   2776          			} else {						/* Sub-dir */
   2777          				do		/* Add stacked path str */
   2778          					*tp++ = path[i++];
   2779          				while (i < sz_path);
   2780          			}
   2781          		}
   2782          		*tp = 0;
   2783          		FREE_BUF();
   2784          	}
   2785          
   2786          	LEAVE_FF(dj.fs, res);
   2787          }
   2788          #endif /* _FS_RPATH >= 2 */
   2789          #endif /* _FS_RPATH >= 1 */
   2790          
   2791          
   2792          
   2793          #if _FS_MINIMIZE <= 2
   2794          /*-----------------------------------------------------------------------*/
   2795          /* Seek File R/W Pointer                                                 */
   2796          /*-----------------------------------------------------------------------*/
   2797          

   \                                 In  segment CODE, align 2, keep-with-next
   2798          FRESULT f_lseek (
   \                     f_lseek:
   2799          	FIL *fp,		/* Pointer to the file object */
   2800          	DWORD ofs		/* File pointer from top of file */
   2801          )
   2802          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   CA0C         MOVA    R12, R10
   \   000008   084E         MOV.W   R14, R8
   \   00000A   094F         MOV.W   R15, R9
   2803          	FRESULT res;
   2804          
   2805          
   2806          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000C   ........     CALLA   #?Subroutine36
   \                     ??CrossCallReturnLabel_101:
   \   000010   C14C0000     MOV.B   R12, 0(SP)
   2807          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   E220         JNE     ??f_lseek_4
   2808          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \   000018   CA930600     CMP.B   #0x0, 0x6(R10)
   \   00001C   AD38         JL      ??f_lseek_3
   2809          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2810          
   2811          #if _USE_FASTSEEK
   2812          	if (fp->cltbl) {	/* Fast seek */
   2813          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2814          
   2815          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   2816          			tbl = fp->cltbl;
   2817          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   2818          			cl = fp->sclust;			/* Top of the chain */
   2819          			if (cl) {
   2820          				do {
   2821          					/* Get a fragment */
   2822          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   2823          					do {
   2824          						pcl = cl; ncl++;
   2825          						cl = get_fat(fp->fs, cl);
   2826          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   2827          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2828          					} while (cl == pcl + 1);
   2829          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   2830          						*tbl++ = ncl; *tbl++ = tcl;
   2831          					}
   2832          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   2833          			}
   2834          			*fp->cltbl = ulen;	/* Number of items used */
   2835          			if (ulen <= tlen)
   2836          				*tbl = 0;		/* Terminate table */
   2837          			else
   2838          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   2839          
   2840          		} else {						/* Fast seek */
   2841          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   2842          				ofs = fp->fsize;
   2843          			fp->fptr = ofs;				/* Set file pointer */
   2844          			if (ofs) {
   2845          				fp->clust = clmt_clust(fp, ofs - 1);
   2846          				dsc = clust2sect(fp->fs, fp->clust);
   2847          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   2848          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   2849          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   2850          #if !_FS_TINY
   2851          #if !_FS_READONLY
   2852          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2853          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2854          							ABORT(fp->fs, FR_DISK_ERR);
   2855          						fp->flag &= ~FA__DIRTY;
   2856          					}
   2857          #endif
   2858          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   2859          						ABORT(fp->fs, FR_DISK_ERR);
   2860          #endif
   2861          					fp->dsect = dsc;
   2862          				}
   2863          			}
   2864          		}
   2865          	} else
   2866          #endif
   2867          
   2868          	/* Normal Seek */
   2869          	{
   2870          		DWORD clst, bcs, nsect, ifptr;
   2871          
   2872          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2873          #if !_FS_READONLY
   2874          			 && !(fp->flag & FA_WRITE)
   2875          #endif
   2876          			) ofs = fp->fsize;
   \   00001E   1E4A0C00     MOV.W   0xc(R10), R14
   \   000022   1F4A0E00     MOV.W   0xe(R10), R15
   \   000026   0F99         CMP.W   R9, R15
   \   000028   0328         JNC     ??f_lseek_5
   \   00002A   0720         JNE     ??f_lseek_6
   \   00002C   0E98         CMP.W   R8, R14
   \   00002E   052C         JC      ??f_lseek_6
   \                     ??f_lseek_5:
   \   000030   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   000034   022C         JC      ??f_lseek_6
   \   000036   084E         MOV.W   R14, R8
   \   000038   094F         MOV.W   R15, R9
   \                     ??f_lseek_6:
   \   00003A   914A08000200 MOV.W   0x8(R10), 0x2(SP)
   \   000040   914A0A000400 MOV.W   0xa(R10), 0x4(SP)
   2877          
   2878          		ifptr = fp->fptr;
   2879          		fp->fptr = nsect = 0;
   \   000046   0443         MOV.W   #0x0, R4
   \   000048   0543         MOV.W   #0x0, R5
   \   00004A   8A430800     MOV.W   #0x0, 0x8(R10)
   \   00004E   8A430A00     MOV.W   #0x0, 0xa(R10)
   2880          		if (ofs) {
   \   000052   0F48         MOV.W   R8, R15
   \   000054   0FD9         BIS.W   R9, R15
   \   000056   0F93         CMP.W   #0x0, R15
   \   000058   A224         JEQ     ??f_lseek_7
   2881          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00005A   0B0A         MOVA    @R10, R11
   \   00005C   5C4B0200     MOV.B   0x2(R11), R12
   \   000060   0D43         MOV.W   #0x0, R13
   \   000062   ........     CALLA   #?ShiftLeft32_9
   \   000066   064C         MOV.W   R12, R6
   \   000068   074D         MOV.W   R13, R7
   2882          			if (ifptr > 0 &&
   2883          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00006A   1F410200     MOV.W   0x2(SP), R15
   \   00006E   1FD10400     BIS.W   0x4(SP), R15
   \   000072   0F93         CMP.W   #0x0, R15
   \   000074   2824         JEQ     ??f_lseek_8
   \   000076   0C48         MOV.W   R8, R12
   \   000078   0D49         MOV.W   R9, R13
   \   00007A   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_21:
   \   00007E   0D12         PUSH.W  R13
   \   000080   0C12         PUSH.W  R12
   \   000082   1C410600     MOV.W   0x6(SP), R12
   \   000086   1D410800     MOV.W   0x8(SP), R13
   \   00008A   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_22:
   \   00008E   3E41         POP.W   R14
   \   000090   3F41         POP.W   R15
   \   000092   0F9D         CMP.W   R13, R15
   \   000094   1828         JNC     ??f_lseek_8
   \   000096   0220         JNE     ??f_lseek_9
   \   000098   0E9C         CMP.W   R12, R14
   \   00009A   1528         JNC     ??f_lseek_8
   2884          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \                     ??f_lseek_9:
   \   00009C   1C410200     MOV.W   0x2(SP), R12
   \   0000A0   1D410400     MOV.W   0x4(SP), R13
   \   0000A4   3C53         ADD.W   #0xffff, R12
   \   0000A6   3D63         ADDC.W  #0xffff, R13
   \   0000A8   0E46         MOV.W   R6, R14
   \   0000AA   0F47         MOV.W   R7, R15
   \   0000AC   3E53         ADD.W   #0xffff, R14
   \   0000AE   3F63         ADDC.W  #0xffff, R15
   \   0000B0   0CCE         BIC.W   R14, R12
   \   0000B2   0DCF         BIC.W   R15, R13
   \   0000B4   8A4C0800     MOV.W   R12, 0x8(R10)
   \   0000B8   8A4D0A00     MOV.W   R13, 0xa(R10)
   2885          				ofs -= fp->fptr;
   \   0000BC   088C         SUB.W   R12, R8
   \   0000BE   097D         SUBC.W  R13, R9
   2886          				clst = fp->clust;
   \   0000C0   ........     CALLA   #?Subroutine30
   2887          			} else {									/* When seek to back cluster, */
   \                     ??CrossCallReturnLabel_42:
   \   0000C4   1A3C         JMP     ??f_lseek_10
   2888          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_8:
   \   0000C6   ........     CALLA   #?Subroutine19
   2889          #if !_FS_READONLY
   2890          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \                     ??CrossCallReturnLabel_102:
   \   0000CA   1320         JNE     ??f_lseek_11
   2891          					clst = create_chain(fp->fs, 0);
   \   0000CC   0E43         MOV.W   #0x0, R14
   \   0000CE   0F43         MOV.W   #0x0, R15
   \   0000D0   CC0B         MOVA    R11, R12
   \   0000D2   ........     CALLA   #create_chain
   \   0000D6   0E4C         MOV.W   R12, R14
   \   0000D8   0F4D         MOV.W   R13, R15
   2892          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000DA   1C93         CMP.W   #0x1, R12
   \   0000DC   0220         JNE     ??f_lseek_12
   \   0000DE   0D93         CMP.W   #0x0, R13
   \   0000E0   4924         JEQ     ??f_lseek_13
   2893          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_12:
   \   0000E2   3C93         CMP.W   #0xffff, R12
   \   0000E4   0220         JNE     ??f_lseek_14
   \   0000E6   3D93         CMP.W   #0xffff, R13
   \   0000E8   5124         JEQ     ??f_lseek_1
   2894          					fp->sclust = clst;
   \                     ??f_lseek_14:
   \   0000EA   8A4E1000     MOV.W   R14, 0x10(R10)
   \   0000EE   8A4F1200     MOV.W   R15, 0x12(R10)
   2895          				}
   2896          #endif
   2897          				fp->clust = clst;
   \                     ??f_lseek_11:
   \   0000F2   8A4E1400     MOV.W   R14, 0x14(R10)
   \   0000F6   8A4F1600     MOV.W   R15, 0x16(R10)
   2898          			}
   2899          			if (clst != 0) {
   \                     ??f_lseek_10:
   \   0000FA   0B4E         MOV.W   R14, R11
   \   0000FC   0BDF         BIS.W   R15, R11
   \   0000FE   0B93         CMP.W   #0x0, R11
   \   000100   1720         JNE     ??f_lseek_15
   \   000102   4D3C         JMP     ??f_lseek_7
   2900          				while (ofs > bcs) {						/* Cluster following loop */
   2901          #if !_FS_READONLY
   2902          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2903          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   2904          						if (clst == 0) {				/* When disk gets full, clip file size */
   2905          							ofs = bcs; break;
   2906          						}
   2907          					} else
   2908          #endif
   2909          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2910          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2911          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_0:
   \   000104   0F93         CMP.W   #0x0, R15
   \   000106   0220         JNE     ??f_lseek_16
   \   000108   2E93         CMP.W   #0x2, R14
   \   00010A   3428         JNC     ??f_lseek_13
   \                     ??f_lseek_16:
   \   00010C   0B0A         MOVA    @R10, R11
   \   00010E   1F9B1800     CMP.W   0x18(R11), R15
   \   000112   0428         JNC     ??f_lseek_17
   \   000114   2F20         JNE     ??f_lseek_13
   \   000116   1E9B1600     CMP.W   0x16(R11), R14
   \   00011A   2C2C         JC      ??f_lseek_13
   2912          					fp->clust = clst;
   \                     ??f_lseek_17:
   \   00011C   8A4E1400     MOV.W   R14, 0x14(R10)
   \   000120   8A4F1600     MOV.W   R15, 0x16(R10)
   2913          					fp->fptr += bcs;
   \   000124   8A560800     ADD.W   R6, 0x8(R10)
   \   000128   8A670A00     ADDC.W  R7, 0xa(R10)
   2914          					ofs -= bcs;
   \   00012C   0886         SUB.W   R6, R8
   \   00012E   0977         SUBC.W  R7, R9
   \                     ??f_lseek_15:
   \   000130   0799         CMP.W   R9, R7
   \   000132   0328         JNC     ??f_lseek_18
   \   000134   1020         JNE     ??f_lseek_19
   \   000136   0698         CMP.W   R8, R6
   \   000138   0E2C         JC      ??f_lseek_19
   \                     ??f_lseek_18:
   \   00013A   0C0A         MOVA    @R10, R12
   \   00013C   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   000140   1D28         JNC     ??f_lseek_20
   \   000142   ........     CALLA   #create_chain
   \   000146   0E4C         MOV.W   R12, R14
   \   000148   0F4D         MOV.W   R13, R15
   \   00014A   0B4C         MOV.W   R12, R11
   \   00014C   0BDD         BIS.W   R13, R11
   \   00014E   0B93         CMP.W   #0x0, R11
   \   000150   1920         JNE     ??f_lseek_21
   \   000152   0846         MOV.W   R6, R8
   \   000154   0947         MOV.W   R7, R9
   2915          				}
   2916          				fp->fptr += ofs;
   \                     ??f_lseek_19:
   \   000156   8A580800     ADD.W   R8, 0x8(R10)
   \   00015A   8A690A00     ADDC.W  R9, 0xa(R10)
   2917          				if (ofs % SS(fp->fs)) {
   \   00015E   38B0FF01     BIT.W   #0x1ff, R8
   \   000162   1D24         JEQ     ??f_lseek_7
   2918          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000164   0C0A         MOVA    @R10, R12
   \   000166   ........     CALLA   #clust2sect
   \   00016A   044C         MOV.W   R12, R4
   \   00016C   054D         MOV.W   R13, R5
   2919          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   00016E   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_68:
   \   000172   0F20         JNE     ??f_lseek_22
   \                     ??f_lseek_13:
   \   000174   ........     CALLA   #?Subroutine37
   \                     ??f_lseek_3:
   \   000178   6C43         MOV.B   #0x2, R12
   \   00017A   313C         JMP     ??f_lseek_23
   \                     ??f_lseek_20:
   \   00017C   ........     CALLA   #get_fat
   \   000180   0E4C         MOV.W   R12, R14
   \   000182   0F4D         MOV.W   R13, R15
   \                     ??f_lseek_21:
   \   000184   3E93         CMP.W   #0xffff, R14
   \   000186   BE23         JNE     ??f_lseek_0
   \   000188   3F93         CMP.W   #0xffff, R15
   \   00018A   BC23         JNE     ??f_lseek_0
   \                     ??f_lseek_1:
   \   00018C   ........     CALLA   #?Subroutine33
   \                     ??CrossCallReturnLabel_50:
   \   000190   263C         JMP     ??f_lseek_23
   2920          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_22:
   \   000192   0C48         MOV.W   R8, R12
   \   000194   0D49         MOV.W   R9, R13
   \   000196   ........     CALLA   #?ShiftRight32u_9
   \   00019A   045C         ADD.W   R12, R4
   \   00019C   056D         ADDC.W  R13, R5
   2921          				}
   2922          			}
   2923          		}
   2924          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_7:
   \   00019E   1E4A0800     MOV.W   0x8(R10), R14
   \   0001A2   1F4A0A00     MOV.W   0xa(R10), R15
   \   0001A6   3EB0FF01     BIT.W   #0x1ff, R14
   \   0001AA   0A24         JEQ     ??f_lseek_24
   \   0001AC   149A1800     CMP.W   0x18(R10), R4
   \   0001B0   0320         JNE     ??f_lseek_25
   \   0001B2   159A1A00     CMP.W   0x1a(R10), R5
   \   0001B6   0424         JEQ     ??f_lseek_24
   2925          #if !_FS_TINY
   2926          #if !_FS_READONLY
   2927          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   2928          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2929          					ABORT(fp->fs, FR_DISK_ERR);
   2930          				fp->flag &= ~FA__DIRTY;
   2931          			}
   2932          #endif
   2933          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   2934          				ABORT(fp->fs, FR_DISK_ERR);
   2935          #endif
   2936          			fp->dsect = nsect;
   \                     ??f_lseek_25:
   \   0001B8   8A441800     MOV.W   R4, 0x18(R10)
   \   0001BC   8A451A00     MOV.W   R5, 0x1a(R10)
   2937          		}
   2938          #if !_FS_READONLY
   2939          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_24:
   \   0001C0   8A9F0E00     CMP.W   R15, 0xe(R10)
   \   0001C4   0428         JNC     ??f_lseek_26
   \   0001C6   0A20         JNE     ??f_lseek_4
   \   0001C8   8A9E0C00     CMP.W   R14, 0xc(R10)
   \   0001CC   072C         JC      ??f_lseek_4
   2940          			fp->fsize = fp->fptr;
   \                     ??f_lseek_26:
   \   0001CE   8A4E0C00     MOV.W   R14, 0xc(R10)
   \   0001D2   8A4F0E00     MOV.W   R15, 0xe(R10)
   2941          			fp->flag |= FA__WRITTEN;
   \   0001D6   FAD020000600 BIS.B   #0x20, 0x6(R10)
   2942          		}
   2943          #endif
   2944          	}
   2945          
   2946          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_4:
   \   0001DC   6C41         MOV.B   @SP, R12
   \                     ??f_lseek_23:
   \   0001DE   31500600     ADD.W   #0x6, SP
   \   0001E2   7416         POPM.A  #0x8, R11
   \   0001E4   1001         RETA
   2947          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   3C53         ADD.W   #0xffff, R12
   \   000002   3D63         ADDC.W  #0xffff, R13
   \   000004   0E46         MOV.W   R6, R14
   \   000006   0F47         MOV.W   R7, R15
   \   000008   ........     BRA     #?DivMod32u
   2948          
   2949          
   2950          
   2951          #if _FS_MINIMIZE <= 1
   2952          /*-----------------------------------------------------------------------*/
   2953          /* Create a Directroy Object                                             */
   2954          /*-----------------------------------------------------------------------*/
   2955          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine35:
   \   000000   CC0A         MOVA    R10, R12
   \   000002                REQUIRE ??Subroutine35_1
   \   000002                // Fall through to label ??Subroutine35_1

   \                                 In  segment CODE, align 2
   \                     ??Subroutine35_1:
   \   000000   ........     CALLA   #follow_path
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2956          FRESULT f_opendir (
   \                     f_opendir:
   2957          	DIRS *dj,			/* Pointer to directory object to create */
   2958          	const TCHAR *path	/* Pointer to the directory path */
   2959          )
   2960          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   31800C00     SUB.W   #0xc, SP
   \   000008   CA0C         MOVA    R12, R10
   2961          	FRESULT res;
   2962          	DEF_NAMEBUF;
   2963          
   2964          
   2965          	res = chk_mounted(&path, &dj->fs, 0);
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   CD0C         MOVA    R12, R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   3C500C00     ADD.W   #0xc, R12
   \   000014   ........     CALLA   #chk_mounted
   2966          	if (res == FR_OK) {
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1F20         JNE     ??f_opendir_0
   2967          		INIT_BUF(*dj);
   \   00001C   0F41         MOV.W   SP, R15
   \   00001E   0F53         ADD.W   #0x0, R15
   \   000020   7A0F1800     MOVA    R15, 0x18(R10)
   2968          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   000024   3D010C00     MOVA    0xc(SP), R13
   \   000028   ........     CALLA   #?Subroutine35
   2969          		FREE_BUF();
   2970          		if (res == FR_OK) {						/* Follow completed */
   \                     ??CrossCallReturnLabel_92:
   \   00002C   1220         JNE     ??f_opendir_1
   2971          			if (dj->dir) {						/* It is not the root dir */
   \   00002E   3C0A1400     MOVA    0x14(R10), R12
   \   000032   DC03         CMPA    #0x0, R12
   \   000034   0624         JEQ     ??f_opendir_2
   2972          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   000036   FCB010000B00 BIT.B   #0x10, 0xb(R12)
   \   00003C   0C28         JNC     ??f_opendir_3
   2973          					dj->sclust = LD_CLUST(dj->dir);
   \   00003E   ........     CALLA   #?Subroutine15
   2974          				} else {						/* The object is not a directory */
   2975          					res = FR_NO_PATH;
   2976          				}
   2977          			}
   2978          			if (res == FR_OK) {
   2979          				dj->id = dj->fs->id;
   \                     ??f_opendir_2:
   \   000042   0F0A         MOVA    @R10, R15
   \   000044   9A4F06000400 MOV.W   0x6(R15), 0x4(R10)
   2980          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   00004A   0D43         MOV.W   #0x0, R13
   \   00004C   CC0A         MOVA    R10, R12
   \   00004E   ........     CALLA   #dir_sdi
   2981          			}
   2982          		}
   2983          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_1:
   \   000052   6C92         CMP.B   #0x4, R12
   \   000054   0220         JNE     ??f_opendir_0
   \                     ??f_opendir_3:
   \   000056   7C400500     MOV.B   #0x5, R12
   2984          	}
   2985          
   2986          	LEAVE_FF(dj->fs, res);
   \                     ??f_opendir_0:
   \   00005A   31501000     ADD.W   #0x10, SP
   \   00005E   0A16         POPM.A  #0x1, R10
   \   000060   1001         RETA
   2987          }
   2988          
   2989          
   2990          
   2991          
   2992          /*-----------------------------------------------------------------------*/
   2993          /* Read Directory Entry in Sequense                                      */
   2994          /*-----------------------------------------------------------------------*/
   2995          

   \                                 In  segment CODE, align 2, keep-with-next
   2996          FRESULT f_readdir (
   \                     f_readdir:
   2997          	DIRS *dj,			/* Pointer to the open directory object */
   2998          	FILINFO *fno		/* Pointer to file information to return */
   2999          )
   3000          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   CA0C         MOVA    R12, R10
   \   000008   CB0D         MOVA    R13, R11
   3001          	FRESULT res;
   3002          	DEF_NAMEBUF;
   3003          
   3004          
   3005          	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   \   00000A   ........     CALLA   #??Subroutine42_0
   3006          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_97:
   \   00000E   2020         JNE     ??f_readdir_0
   3007          		if (!fno) {
   \   000010   DB03         CMPA    #0x0, R11
   \   000012   0520         JNE     ??f_readdir_1
   3008          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   000014   0D43         MOV.W   #0x0, R13
   \   000016   CC0A         MOVA    R10, R12
   \   000018   ........     CALLA   #dir_sdi
   \   00001C   193C         JMP     ??f_readdir_0
   3009          		} else {
   3010          			INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   0F53         ADD.W   #0x0, R15
   \   000022   7A0F1800     MOVA    R15, 0x18(R10)
   3011          			res = dir_read(dj);				/* Read an directory item */
   \   000026   CC0A         MOVA    R10, R12
   \   000028   ........     CALLA   #dir_read
   3012          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00002C   6C92         CMP.B   #0x4, R12
   \   00002E   0320         JNE     ??f_readdir_2
   3013          				dj->sect = 0;
   \   000030   ........     CALLA   #?Subroutine32
   3014          				res = FR_OK;
   \                     ??CrossCallReturnLabel_48:
   \   000034   023C         JMP     ??f_readdir_3
   3015          			}
   3016          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2:
   \   000036   4C93         CMP.B   #0x0, R12
   \   000038   0B20         JNE     ??f_readdir_0
   3017          				get_fileinfo(dj, fno);		/* Get the object information */
   \                     ??f_readdir_3:
   \   00003A   CD0B         MOVA    R11, R13
   \   00003C   CC0A         MOVA    R10, R12
   \   00003E   ........     CALLA   #get_fileinfo
   3018          				res = dir_next(dj, 0);		/* Increment index for next */
   \   000042   ........     CALLA   #?Subroutine25
   3019          				if (res == FR_NO_FILE) {
   \                     ??CrossCallReturnLabel_89:
   \   000046   6C92         CMP.B   #0x4, R12
   \   000048   0320         JNE     ??f_readdir_0
   3020          					dj->sect = 0;
   \   00004A   ........     CALLA   #?Subroutine32
   3021          					res = FR_OK;
   \                     ??CrossCallReturnLabel_49:
   \   00004E   4C43         MOV.B   #0x0, R12
   3022          				}
   3023          			}
   3024          			FREE_BUF();
   3025          		}
   3026          	}
   3027          
   3028          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   000050   31500C00     ADD.W   #0xc, SP
   \   000054   1A16         POPM.A  #0x2, R11
   \   000056   1001         RETA
   3029          }
   3030          
   3031          
   3032          
   3033          #if _FS_MINIMIZE == 0
   3034          /*-----------------------------------------------------------------------*/
   3035          /* Get File Status                                                       */
   3036          /*-----------------------------------------------------------------------*/
   3037          

   \                                 In  segment CODE, align 2, keep-with-next
   3038          FRESULT f_stat (
   \                     f_stat:
   3039          	const TCHAR *path,	/* Pointer to the file path */
   3040          	FILINFO *fno		/* Pointer to file information to return */
   3041          )
   3042          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31802800     SUB.W   #0x28, SP
   \   000008   C80D         MOVA    R13, R8
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   0D41         MOV.W   SP, R13
   \   00000E   3D500C00     ADD.W   #0xc, R13
   \   000012   ........     CALLA   #?Subroutine29
   \                     ??CrossCallReturnLabel_39:
   \   000016   4A4C         MOV.B   R12, R10
   3043          	FRESULT res;
   3044          	DIRS dj;
   3045          	DEF_NAMEBUF;
   3046          
   3047          
   3048          	res = chk_mounted(&path, &dj.fs, 0);
   3049          	if (res == FR_OK) {
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1A20         JNE     ??f_stat_0
   3050          		INIT_BUF(dj);
   \   00001C   0F41         MOV.W   SP, R15
   \   00001E   0F53         ADD.W   #0x0, R15
   \   000020   710F2400     MOVA    R15, 0x24(SP)
   3051          		res = follow_path(&dj, path);	/* Follow the file path */
   \   000024   0B41         MOV.W   SP, R11
   \   000026   3B500C00     ADD.W   #0xc, R11
   \   00002A   3D012800     MOVA    0x28(SP), R13
   \   00002E   CC0B         MOVA    R11, R12
   \   000030   ........     CALLA   #follow_path
   \   000034   4A4C         MOV.B   R12, R10
   3052          		if (res == FR_OK) {				/* Follow completed */
   \   000036   4C93         CMP.B   #0x0, R12
   \   000038   0B20         JNE     ??f_stat_0
   3053          			if (dj.dir)		/* Found an object */
   \   00003A   3F012000     MOVA    0x20(SP), R15
   \   00003E   DF03         CMPA    #0x0, R15
   \   000040   0524         JEQ     ??f_stat_1
   3054          				get_fileinfo(&dj, fno);
   \   000042   CD08         MOVA    R8, R13
   \   000044   CC0B         MOVA    R11, R12
   \   000046   ........     CALLA   #get_fileinfo
   \   00004A   023C         JMP     ??f_stat_0
   3055          			else			/* It is root dir */
   3056          				res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   00004C   7A400600     MOV.B   #0x6, R10
   3057          		}
   3058          		FREE_BUF();
   3059          	}
   3060          
   3061          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   000050   4C4A         MOV.B   R10, R12
   \   000052   31502C00     ADD.W   #0x2c, SP
   \   000056   3816         POPM.A  #0x4, R11
   \   000058   1001         RETA
   3062          }
   3063          
   3064          
   3065          
   3066          #if !_FS_READONLY
   3067          /*-----------------------------------------------------------------------*/
   3068          /* Get Number of Free Clusters                                           */
   3069          /*-----------------------------------------------------------------------*/
   3070          

   \                                 In  segment CODE, align 2
   3071          FRESULT f_getfree (
   \                     f_getfree:
   3072          	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
   3073          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   3074          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   3075          )
   3076          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   0D14         PUSHM.A #0x1, R13
   \   000006   31800600     SUB.W   #0x6, SP
   \   00000A   C60E         MOVA    R14, R6
   3077          	FRESULT res;
   3078          	DWORD n, clst, sect, stat;
   3079          	UINT i;
   3080          	BYTE fat, *p;
   3081          
   3082          
   3083          	/* Get drive number */
   3084          	res = chk_mounted(&path, fatfs, 0);
   \   00000C   4E43         MOV.B   #0x0, R14
   \   00000E   CD06         MOVA    R6, R13
   \   000010   0C41         MOV.W   SP, R12
   \   000012   3C500A00     ADD.W   #0xa, R12
   \   000016   ........     CALLA   #chk_mounted
   \   00001A   454C         MOV.B   R12, R5
   3085          	if (res == FR_OK) {
   \   00001C   4C93         CMP.B   #0x0, R12
   \   00001E   A120         JNE     ??f_getfree_7
   3086          		/* If free_clust is valid, return it without full cluster scan */
   3087          		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
   \   000020   0F06         MOVA    @R6, R15
   \   000022   1A4F0E00     MOV.W   0xe(R15), R10
   \   000026   1B4F1000     MOV.W   0x10(R15), R11
   \   00002A   184F1600     MOV.W   0x16(R15), R8
   \   00002E   194F1800     MOV.W   0x18(R15), R9
   \   000032   0C48         MOV.W   R8, R12
   \   000034   0D49         MOV.W   R9, R13
   \   000036   3C50FEFF     ADD.W   #0xfffe, R12
   \   00003A   3D63         ADDC.W  #0xffff, R13
   \   00003C   0D9B         CMP.W   R11, R13
   \   00003E   0328         JNC     ??f_getfree_6
   \   000040   8A20         JNE     ??f_getfree_4
   \   000042   0C9A         CMP.W   R10, R12
   \   000044   882C         JC      ??f_getfree_4
   3088          			*nclst = (*fatfs)->free_clust;
   3089          		} else {
   3090          			/* Get number of free clusters */
   3091          			fat = (*fatfs)->fs_type;
   \                     ??f_getfree_6:
   \   000046   4018E14F0000 MOVX.B  @R15, 0(SP)
   3092          			n = 0;
   \   00004C   0A43         MOV.W   #0x0, R10
   \   00004E   0B43         MOV.W   #0x0, R11
   3093          			if (fat == FS_FAT12) {
   \   000050   D1930000     CMP.B   #0x1, 0(SP)
   \   000054   2320         JNE     ??f_getfree_8
   3094          				clst = 2;
   \   000056   2843         MOV.W   #0x2, R8
   \   000058   0943         MOV.W   #0x0, R9
   3095          				do {
   3096          					stat = get_fat(*fatfs, clst);
   \                     ??f_getfree_0:
   \   00005A   0E48         MOV.W   R8, R14
   \   00005C   0F49         MOV.W   R9, R15
   \   00005E   0C06         MOVA    @R6, R12
   \   000060   ........     CALLA   #get_fat
   3097          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   000064   3C93         CMP.W   #0xffff, R12
   \   000066   0420         JNE     ??f_getfree_9
   \   000068   3D93         CMP.W   #0xffff, R13
   \   00006A   0220         JNE     ??f_getfree_9
   \   00006C   5543         MOV.B   #0x1, R5
   \   00006E   683C         JMP     ??f_getfree_3
   3098          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_9:
   \   000070   1C93         CMP.W   #0x1, R12
   \   000072   0420         JNE     ??f_getfree_10
   \   000074   0D93         CMP.W   #0x0, R13
   \   000076   0220         JNE     ??f_getfree_10
   \   000078   6543         MOV.B   #0x2, R5
   \   00007A   623C         JMP     ??f_getfree_3
   3099          					if (stat == 0) n++;
   \                     ??f_getfree_10:
   \   00007C   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_67:
   \   000080   0220         JNE     ??f_getfree_11
   \   000082   1A53         ADD.W   #0x1, R10
   \   000084   0B63         ADDC.W  #0x0, R11
   3100          				} while (++clst < (*fatfs)->n_fatent);
   \                     ??f_getfree_11:
   \   000086   1853         ADD.W   #0x1, R8
   \   000088   0963         ADDC.W  #0x0, R9
   \   00008A   0F06         MOVA    @R6, R15
   \   00008C   199F1800     CMP.W   0x18(R15), R9
   \   000090   E42B         JNC     ??f_getfree_0
   \   000092   5620         JNE     ??f_getfree_3
   \   000094   189F1600     CMP.W   0x16(R15), R8
   \   000098   E02B         JNC     ??f_getfree_0
   \   00009A   523C         JMP     ??f_getfree_3
   3101          			} else {
   3102          				clst = (*fatfs)->n_fatent;
   3103          				sect = (*fatfs)->fatbase;
   \                     ??f_getfree_8:
   \   00009C   914F1E000200 MOV.W   0x1e(R15), 0x2(SP)
   \   0000A2   914F20000400 MOV.W   0x20(R15), 0x4(SP)
   3104          				i = 0; p = 0;
   \   0000A8   023C         JMP     ??f_getfree_12
   3105          				do {
   3106          					if (!i) {
   \                     ??f_getfree_1:
   \   0000AA   0493         CMP.W   #0x0, R4
   \   0000AC   1920         JNE     ??f_getfree_13
   3107          						res = move_window(*fatfs, sect++);
   \                     ??f_getfree_12:
   \   0000AE   1E410200     MOV.W   0x2(SP), R14
   \   0000B2   1F410400     MOV.W   0x4(SP), R15
   \   0000B6   0C06         MOVA    @R6, R12
   \   0000B8   ........     CALLA   #move_window
   \   0000BC   454C         MOV.B   R12, R5
   \   0000BE   1E410200     MOV.W   0x2(SP), R14
   \   0000C2   1F410400     MOV.W   0x4(SP), R15
   \   0000C6   1E53         ADD.W   #0x1, R14
   \   0000C8   0F63         ADDC.W  #0x0, R15
   \   0000CA   814E0200     MOV.W   R14, 0x2(SP)
   \   0000CE   814F0400     MOV.W   R15, 0x4(SP)
   3108          						if (res != FR_OK) break;
   \   0000D2   4C93         CMP.B   #0x0, R12
   \   0000D4   3520         JNE     ??f_getfree_3
   3109          						p = (*fatfs)->win;
   \   0000D6   0706         MOVA    @R6, R7
   \   0000D8   A7002E00     ADDA    #0x2e, R7
   3110          						i = SS(*fatfs);
   \   0000DC   34400002     MOV.W   #0x200, R4
   3111          					}
   3112          					if (fat == FS_FAT16) {
   \                     ??f_getfree_13:
   \   0000E0   E1930000     CMP.B   #0x2, 0(SP)
   \   0000E4   0C20         JNE     ??f_getfree_14
   3113          						if (LD_WORD(p) == 0) n++;
   \   0000E6   6E47         MOV.B   @R7, R14
   \   0000E8   5F470100     MOV.B   0x1(R7), R15
   \   0000EC   8F10         SWPB    R15
   \   0000EE   0FDE         BIS.W   R14, R15
   \   0000F0   0F93         CMP.W   #0x0, R15
   \   0000F2   0220         JNE     ??f_getfree_15
   \   0000F4   1A53         ADD.W   #0x1, R10
   \   0000F6   0B63         ADDC.W  #0x0, R11
   3114          						p += 2; i -= 2;
   \                     ??f_getfree_15:
   \   0000F8   E703         ADDA    #0x2, R7
   \   0000FA   2483         SUB.W   #0x2, R4
   \   0000FC   1B3C         JMP     ??f_getfree_16
   3115          					} else {
   3116          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_14:
   \   0000FE   6F47         MOV.B   @R7, R15
   \   000100   0F12         PUSH.W  R15
   \   000102   5F470100     MOV.B   0x1(R7), R15
   \   000106   8F10         SWPB    R15
   \   000108   0F12         PUSH.W  R15
   \   00010A   5E470200     MOV.B   0x2(R7), R14
   \   00010E   0D4E         MOV.W   R14, R13
   \   000110   5E470300     MOV.B   0x3(R7), R14
   \   000114   8E10         SWPB    R14
   \   000116   0F4E         MOV.W   R14, R15
   \   000118   0FDD         BIS.W   R13, R15
   \   00011A   3E41         POP.W   R14
   \   00011C   3D41         POP.W   R13
   \   00011E   0EDD         BIS.W   R13, R14
   \   000120   3EB3         BIT.W   #0xffff, R14
   \   000122   0520         JNE     ??f_getfree_17
   \   000124   3FB0FF0F     BIT.W   #0xfff, R15
   \   000128   0220         JNE     ??f_getfree_17
   \   00012A   1A53         ADD.W   #0x1, R10
   \   00012C   0B63         ADDC.W  #0x0, R11
   3117          						p += 4; i -= 4;
   \                     ??f_getfree_17:
   \   00012E   A7000400     ADDA    #0x4, R7
   \   000132   2482         SUB.W   #0x4, R4
   3118          					}
   3119          				} while (--clst);
   \                     ??f_getfree_16:
   \   000134   3853         ADD.W   #0xffff, R8
   \   000136   3963         ADDC.W  #0xffff, R9
   \   000138   0F48         MOV.W   R8, R15
   \   00013A   0FD9         BIS.W   R9, R15
   \   00013C   0F93         CMP.W   #0x0, R15
   \   00013E   B523         JNE     ??f_getfree_1
   3120          			}
   3121          			(*fatfs)->free_clust = n;
   \                     ??f_getfree_3:
   \   000140   0F06         MOVA    @R6, R15
   \   000142   8F4A0E00     MOV.W   R10, 0xe(R15)
   \   000146   8F4B1000     MOV.W   R11, 0x10(R15)
   3122          			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   \   00014A   F19003000000 CMP.B   #0x3, 0(SP)
   \   000150   0220         JNE     ??f_getfree_4
   \   000152   DF430500     MOV.B   #0x1, 0x5(R15)
   3123          			*nclst = n;
   \                     ??f_getfree_4:
   \   000156   3F010600     MOVA    0x6(SP), R15
   \   00015A   8F4A0000     MOV.W   R10, 0(R15)
   \   00015E   8F4B0200     MOV.W   R11, 0x2(R15)
   3124          		}
   3125          	}
   3126          	LEAVE_FF(*fatfs, res);
   \                     ??f_getfree_7:
   \   000162   4C45         MOV.B   R5, R12
   \   000164   31500E00     ADD.W   #0xe, SP
   \   000168   7416         POPM.A  #0x8, R11
   \   00016A   1001         RETA
   3127          }
   3128          
   3129          
   3130          
   3131          
   3132          /*-----------------------------------------------------------------------*/
   3133          /* Truncate File                                                         */
   3134          /*-----------------------------------------------------------------------*/
   3135          

   \                                 In  segment CODE, align 2
   3136          FRESULT f_truncate (
   \                     f_truncate:
   3137          	FIL *fp		/* Pointer to the file object */
   3138          )
   3139          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   ........     CALLA   #?Subroutine8
   3140          	FRESULT res;
   3141          	DWORD ncl;
   3142          
   3143          
   3144          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \                     ??CrossCallReturnLabel_99:
   \   000006   4B4C         MOV.B   R12, R11
   3145          	if (res == FR_OK) {
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   5920         JNE     ??f_truncate_0
   3146          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000C   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000010   0234         JGE     ??f_truncate_1
   3147          			res = FR_INT_ERR;
   \   000012   6B43         MOV.B   #0x2, R11
   \   000014   543C         JMP     ??f_truncate_0
   3148          		} else {
   3149          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1:
   \   000016   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   00001A   032C         JC      ??f_truncate_2
   3150          				res = FR_DENIED;
   \   00001C   7B400700     MOV.B   #0x7, R11
   \   000020   4E3C         JMP     ??f_truncate_0
   3151          		}
   3152          	}
   3153          	if (res == FR_OK) {
   3154          		if (fp->fsize > fp->fptr) {
   \                     ??f_truncate_2:
   \   000022   184A0800     MOV.W   0x8(R10), R8
   \   000026   194A0A00     MOV.W   0xa(R10), R9
   \   00002A   199A0E00     CMP.W   0xe(R10), R9
   \   00002E   0428         JNC     ??f_truncate_3
   \   000030   4620         JNE     ??f_truncate_0
   \   000032   189A0C00     CMP.W   0xc(R10), R8
   \   000036   432C         JC      ??f_truncate_0
   3155          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \                     ??f_truncate_3:
   \   000038   8A480C00     MOV.W   R8, 0xc(R10)
   \   00003C   8A490E00     MOV.W   R9, 0xe(R10)
   3156          			fp->flag |= FA__WRITTEN;
   \   000040   FAD020000600 BIS.B   #0x20, 0x6(R10)
   3157          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   000046   0C0A         MOVA    @R10, R12
   \   000048   0F48         MOV.W   R8, R15
   \   00004A   0FD9         BIS.W   R9, R15
   \   00004C   0F93         CMP.W   #0x0, R15
   \   00004E   0820         JNE     ??f_truncate_4
   3158          				res = remove_chain(fp->fs, fp->sclust);
   \   000050   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_54:
   \   000054   ........     CALLA   #remove_chain
   \   000058   4B4C         MOV.B   R12, R11
   3159          				fp->sclust = 0;
   \   00005A   ........     CALLA   #?Subroutine32
   3160          			} else {				/* When truncate a part of the file, remove remaining clusters */
   \                     ??CrossCallReturnLabel_47:
   \   00005E   2B3C         JMP     ??f_truncate_5
   3161          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4:
   \   000060   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_40:
   \   000064   ........     CALLA   #get_fat
   \   000068   084C         MOV.W   R12, R8
   \   00006A   094D         MOV.W   R13, R9
   3162          				res = FR_OK;
   3163          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   00006C   3C93         CMP.W   #0xffff, R12
   \   00006E   0420         JNE     ??f_truncate_6
   \   000070   3D93         CMP.W   #0xffff, R13
   \   000072   0220         JNE     ??f_truncate_6
   \   000074   5B43         MOV.B   #0x1, R11
   \   000076   213C         JMP     ??f_truncate_7
   3164          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6:
   \   000078   1C93         CMP.W   #0x1, R12
   \   00007A   0420         JNE     ??f_truncate_8
   \   00007C   0D93         CMP.W   #0x0, R13
   \   00007E   0220         JNE     ??f_truncate_8
   \   000080   6B43         MOV.B   #0x2, R11
   \   000082   1B3C         JMP     ??f_truncate_7
   3165          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_8:
   \   000084   0C0A         MOVA    @R10, R12
   \   000086   199C1800     CMP.W   0x18(R12), R9
   \   00008A   0428         JNC     ??f_truncate_9
   \   00008C   1820         JNE     ??f_truncate_0
   \   00008E   189C1600     CMP.W   0x16(R12), R8
   \   000092   152C         JC      ??f_truncate_0
   3166          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \                     ??f_truncate_9:
   \   000094   3012FF0F     PUSH.W  #0xfff
   \   000098   3312         PUSH.W  #0xffff
   \   00009A   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_41:
   \   00009E   ........     CALLA   #put_fat
   \   0000A2   4B4C         MOV.B   R12, R11
   3167          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   0000A4   2152         ADD.W   #0x4, SP
   \   0000A6   4C93         CMP.B   #0x0, R12
   \   0000A8   0620         JNE     ??f_truncate_5
   \   0000AA   0E48         MOV.W   R8, R14
   \   0000AC   0F49         MOV.W   R9, R15
   \   0000AE   0C0A         MOVA    @R10, R12
   \   0000B0   ........     CALLA   #remove_chain
   \   0000B4   4B4C         MOV.B   R12, R11
   3168          				}
   3169          			}
   3170          		}
   3171          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_5:
   \   0000B6   4B93         CMP.B   #0x0, R11
   \   0000B8   0224         JEQ     ??f_truncate_0
   \                     ??f_truncate_7:
   \   0000BA   ........     CALLA   #?Subroutine37
   3172          	}
   3173          
   3174          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_0:
   \   0000BE   4C4B         MOV.B   R11, R12
   \   0000C0   3816         POPM.A  #0x4, R11
   \   0000C2   1001         RETA
   3175          }
   3176          
   3177          
   3178          
   3179          
   3180          /*-----------------------------------------------------------------------*/
   3181          /* Delete a File or Directory                                            */
   3182          /*-----------------------------------------------------------------------*/
   3183          

   \                                 In  segment CODE, align 2, keep-with-next
   3184          FRESULT f_unlink (
   \                     f_unlink:
   3185          	const TCHAR *path		/* Pointer to the file or directory path */
   3186          )
   3187          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31804400     SUB.W   #0x44, SP
   \   000008   5E43         MOV.B   #0x1, R14
   \   00000A   0D41         MOV.W   SP, R13
   \   00000C   0D53         ADD.W   #0x0, R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   3C504400     ADD.W   #0x44, R12
   3188          	FRESULT res;
   3189          	DIRS dj, sdj;
   3190          	BYTE *dir;
   3191          	DWORD dclst;
   3192          	DEF_NAMEBUF;
   3193          
   3194          
   3195          	res = chk_mounted(&path, &dj.fs, 1);
   \   000014   ........     CALLA   #chk_mounted
   3196          	if (res == FR_OK) {
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   6420         JNE     ??f_unlink_0
   3197          		INIT_BUF(dj);
   \   00001C   0F41         MOV.W   SP, R15
   \   00001E   3F501C00     ADD.W   #0x1c, R15
   \   000022   710F1800     MOVA    R15, 0x18(SP)
   3198          		res = follow_path(&dj, path);		/* Follow the file path */
   \   000026   0841         MOV.W   SP, R8
   \   000028   0853         ADD.W   #0x0, R8
   \   00002A   3D014400     MOVA    0x44(SP), R13
   \   00002E   CC08         MOVA    R8, R12
   \   000030   ........     CALLA   #??Subroutine35_1
   3199          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3200          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   3201          #if _FS_SHARE
   3202          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   3203          #endif
   3204          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??CrossCallReturnLabel_94:
   \   000034   5720         JNE     ??f_unlink_0
   3205          			dir = dj.dir;
   \   000036   3E011400     MOVA    0x14(SP), R14
   3206          			if (!dir) {
   \   00003A   DE03         CMPA    #0x0, R14
   \   00003C   0320         JNE     ??f_unlink_1
   3207          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   00003E   7C400600     MOV.B   #0x6, R12
   \   000042   053C         JMP     ??f_unlink_2
   3208          			} else {
   3209          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_1:
   \   000044   DEB30B00     BIT.B   #0x1, 0xb(R14)
   \   000048   0228         JNC     ??f_unlink_2
   3210          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00004A   7C400700     MOV.B   #0x7, R12
   3211          			}
   3212          			dclst = LD_CLUST(dir);
   \                     ??f_unlink_2:
   \   00004E   5F4E1A00     MOV.B   0x1a(R14), R15
   \   000052   5A4E1B00     MOV.B   0x1b(R14), R10
   \   000056   8A10         SWPB    R10
   \   000058   0ADF         BIS.W   R15, R10
   \   00005A   5F4E1400     MOV.B   0x14(R14), R15
   \   00005E   5B4E1500     MOV.B   0x15(R14), R11
   \   000062   8B10         SWPB    R11
   \   000064   0BDF         BIS.W   R15, R11
   3213          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   000066   4C93         CMP.B   #0x0, R12
   \   000068   2820         JNE     ??f_unlink_3
   \   00006A   FEB010000B00 BIT.B   #0x10, 0xb(R14)
   \   000070   2628         JNC     ??f_unlink_4
   3214          				if (dclst < 2) {
   \   000072   0B93         CMP.W   #0x0, R11
   \   000074   0420         JNE     ??f_unlink_5
   \   000076   2A93         CMP.W   #0x2, R10
   \   000078   022C         JC      ??f_unlink_5
   3215          					res = FR_INT_ERR;
   \   00007A   6C43         MOV.B   #0x2, R12
   \   00007C   333C         JMP     ??f_unlink_0
   3216          				} else {
   \                     ??f_unlink_5:
   \   00007E   0941         MOV.W   SP, R9
   \   000080   39502800     ADD.W   #0x28, R9
   \   000084   3E401C00     MOV.W   #0x1c, R14
   \   000088   CD08         MOVA    R8, R13
   \   00008A   CC09         MOVA    R9, R12
   3217          					mem_cpy(&sdj, &dj, sizeof(DIRS));	/* Check if the sub-dir is empty or not */
   \   00008C   ........     CALLA   #mem_cpy
   3218          					sdj.sclust = dclst;
   \   000090   814A3000     MOV.W   R10, 0x30(SP)
   \   000094   814B3200     MOV.W   R11, 0x32(SP)
   3219          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   000098   2D43         MOV.W   #0x2, R13
   \   00009A   CC09         MOVA    R9, R12
   \   00009C   ........     CALLA   #dir_sdi
   3220          					if (res == FR_OK) {
   \   0000A0   4C93         CMP.B   #0x0, R12
   \   0000A2   0B20         JNE     ??f_unlink_3
   3221          						res = dir_read(&sdj);
   \   0000A4   CC09         MOVA    R9, R12
   \   0000A6   ........     CALLA   #dir_read
   3222          						if (res == FR_OK			/* Not empty dir */
   3223          #if _FS_RPATH
   3224          						|| dclst == sdj.fs->cdir	/* Current dir */
   3225          #endif
   3226          						) res = FR_DENIED;
   \   0000AA   4C93         CMP.B   #0x0, R12
   \   0000AC   0320         JNE     ??f_unlink_6
   \   0000AE   7C400700     MOV.B   #0x7, R12
   \   0000B2   183C         JMP     ??f_unlink_0
   3227          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_6:
   \   0000B4   6C92         CMP.B   #0x4, R12
   \   0000B6   1620         JNE     ??f_unlink_0
   \   0000B8   023C         JMP     ??f_unlink_4
   3228          					}
   3229          				}
   3230          			}
   3231          			if (res == FR_OK) {
   \                     ??f_unlink_3:
   \   0000BA   4C93         CMP.B   #0x0, R12
   \   0000BC   1320         JNE     ??f_unlink_0
   3232          				res = dir_remove(&dj);		/* Remove the directory entry */
   \                     ??f_unlink_4:
   \   0000BE   CC08         MOVA    R8, R12
   \   0000C0   ........     CALLA   #dir_remove
   3233          				if (res == FR_OK) {
   \   0000C4   4C93         CMP.B   #0x0, R12
   \   0000C6   0E20         JNE     ??f_unlink_0
   3234          					if (dclst)				/* Remove the cluster chain if exist */
   \   0000C8   0F4A         MOV.W   R10, R15
   \   0000CA   0FDB         BIS.W   R11, R15
   \   0000CC   0F93         CMP.W   #0x0, R15
   \   0000CE   0724         JEQ     ??f_unlink_7
   3235          						res = remove_chain(dj.fs, dclst);
   \   0000D0   0E4A         MOV.W   R10, R14
   \   0000D2   0F4B         MOV.W   R11, R15
   \   0000D4   0C01         MOVA    @SP, R12
   \   0000D6   ........     CALLA   #remove_chain
   3236          					if (res == FR_OK) res = sync(dj.fs);
   \   0000DA   4C93         CMP.B   #0x0, R12
   \   0000DC   0320         JNE     ??f_unlink_0
   \                     ??f_unlink_7:
   \   0000DE   0C01         MOVA    @SP, R12
   \   0000E0   ........     CALLA   #sync
   3237          				}
   3238          			}
   3239          		}
   3240          		FREE_BUF();
   3241          	}
   3242          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   0000E4   31504800     ADD.W   #0x48, SP
   \   0000E8   3816         POPM.A  #0x4, R11
   \   0000EA   1001         RETA
   3243          }
   3244          
   3245          
   3246          
   3247          
   3248          /*-----------------------------------------------------------------------*/
   3249          /* Create a Directory                                                    */
   3250          /*-----------------------------------------------------------------------*/
   3251          

   \                                 In  segment CODE, align 2, keep-with-next
   3252          FRESULT f_mkdir (
   \                     f_mkdir:
   3253          	const TCHAR *path		/* Pointer to the directory path */
   3254          )
   3255          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31802E00     SUB.W   #0x2e, SP
   3256          	FRESULT res;
   3257          	DIRS dj;
   3258          	BYTE *dir, n;
   3259          	DWORD dsc, dcl, pcl, tim = get_fattime();
   \   000008   ........     CALLA   #get_fattime
   \   00000C   064C         MOV.W   R12, R6
   \   00000E   074D         MOV.W   R13, R7
   \   000010   5E43         MOV.B   #0x1, R14
   \   000012   0D41         MOV.W   SP, R13
   \   000014   3D500600     ADD.W   #0x6, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   3C502E00     ADD.W   #0x2e, R12
   3260          	DEF_NAMEBUF;
   3261          
   3262          
   3263          	res = chk_mounted(&path, &dj.fs, 1);
   \   00001E   ........     CALLA   #chk_mounted
   \   000022   484C         MOV.B   R12, R8
   3264          	if (res == FR_OK) {
   \   000024   4C93         CMP.B   #0x0, R12
   \   000026   D020         JNE     ??f_mkdir_4
   3265          		INIT_BUF(dj);
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F502200     ADD.W   #0x22, R15
   \   00002E   710F1E00     MOVA    R15, 0x1e(SP)
   3266          		res = follow_path(&dj, path);			/* Follow the file path */
   \   000032   3F50E4FF     ADD.W   #0xffe4, R15
   \   000036   710F0200     MOVA    R15, 0x2(SP)
   \   00003A   3D012E00     MOVA    0x2e(SP), R13
   \   00003E   3C010200     MOVA    0x2(SP), R12
   \   000042   ........     CALLA   #follow_path
   \   000046   484C         MOV.B   R12, R8
   3267          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   000048   4C93         CMP.B   #0x0, R12
   \   00004A   0220         JNE     ??f_mkdir_5
   \   00004C   7842         MOV.B   #0x8, R8
   \   00004E   BC3C         JMP     ??f_mkdir_4
   3268          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   3269          			res = FR_INVALID_NAME;
   3270          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_5:
   \   000050   6C92         CMP.B   #0x4, R12
   \   000052   BA20         JNE     ??f_mkdir_4
   3271          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   000054   0E43         MOV.W   #0x0, R14
   \   000056   0F43         MOV.W   #0x0, R15
   \   000058   3C010600     MOVA    0x6(SP), R12
   \   00005C   ........     CALLA   #?Subroutine24
   3272          			res = FR_OK;
   3273          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \                     ??CrossCallReturnLabel_62:
   \   000060   0320         JNE     ??f_mkdir_6
   \   000062   78400700     MOV.B   #0x7, R8
   \   000066   933C         JMP     ??f_mkdir_7
   3274          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_6:
   \   000068   1C93         CMP.W   #0x1, R12
   \   00006A   0420         JNE     ??f_mkdir_8
   \   00006C   0D93         CMP.W   #0x0, R13
   \   00006E   0220         JNE     ??f_mkdir_8
   \   000070   6843         MOV.B   #0x2, R8
   \   000072   8D3C         JMP     ??f_mkdir_7
   3275          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_8:
   \   000074   3C93         CMP.W   #0xffff, R12
   \   000076   0420         JNE     ??f_mkdir_9
   \   000078   3D93         CMP.W   #0xffff, R13
   \   00007A   0220         JNE     ??f_mkdir_9
   \   00007C   5843         MOV.B   #0x1, R8
   \   00007E   873C         JMP     ??f_mkdir_7
   3276          			if (res == FR_OK)					/* Flush FAT */
   3277          				res = move_window(dj.fs, 0);
   \                     ??f_mkdir_9:
   \   000080   ........     CALLA   #?Subroutine6
   3278          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??CrossCallReturnLabel_8:
   \   000084   7B20         JNE     ??f_mkdir_10
   3279          				dsc = clust2sect(dj.fs, dcl);
   \   000086   0E4A         MOV.W   R10, R14
   \   000088   0F4B         MOV.W   R11, R15
   \   00008A   3C010600     MOVA    0x6(SP), R12
   \   00008E   ........     CALLA   #clust2sect
   \   000092   044C         MOV.W   R12, R4
   \   000094   054D         MOV.W   R13, R5
   3280          				dir = dj.fs->win;
   \   000096   39010600     MOVA    0x6(SP), R9
   \   00009A   A9002E00     ADDA    #0x2e, R9
   3281          				mem_set(dir, 0, SS(dj.fs));
   \   00009E   CF09         MOVA    R9, R15
   \   0000A0   ........     CALLA   #??Subroutine10_0
   3282          				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
   \                     ??CrossCallReturnLabel_12:
   \   0000A4   CF09         MOVA    R9, R15
   \   0000A6   F94020000000 MOV.B   #0x20, 0(R9)
   \   0000AC   AF000100     ADDA    #0x1, R15
   \   0000B0   7E400500     MOV.B   #0x5, R14
   \                     ??f_mkdir_1:
   \   0000B4   FF4020000000 MOV.B   #0x20, 0(R15)
   \   0000BA   AF000100     ADDA    #0x1, R15
   \   0000BE   FF4020000000 MOV.B   #0x20, 0(R15)
   \   0000C4   AF000100     ADDA    #0x1, R15
   \   0000C8   7E53         ADD.B   #0xff, R14
   \   0000CA   F423         JNE     ??f_mkdir_1
   3283          				dir[DIR_Name] = '.';
   \   0000CC   F9402E000000 MOV.B   #0x2e, 0(R9)
   3284          				dir[DIR_Attr] = AM_DIR;
   \   0000D2   ........     CALLA   #?Subroutine23
   3285          				ST_DWORD(dir+DIR_WrtTime, tim);
   \                     ??CrossCallReturnLabel_30:
   \   0000D6   0F47         MOV.W   R7, R15
   \   0000D8   8F10         SWPB    R15
   \   0000DA   4E4F         MOV.B   R15, R14
   \   0000DC   C94E1900     MOV.B   R14, 0x19(R9)
   3286          				ST_CLUST(dir, dcl);
   \   0000E0   ........     CALLA   #?Subroutine31
   \                     ??CrossCallReturnLabel_45:
   \   0000E4   0F4B         MOV.W   R11, R15
   \   0000E6   8F10         SWPB    R15
   \   0000E8   C94F1500     MOV.B   R15, 0x15(R9)
   3287          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   0000EC   3E402000     MOV.W   #0x20, R14
   \   0000F0   CD09         MOVA    R9, R13
   \   0000F2   CC09         MOVA    R9, R12
   \   0000F4   AC002000     ADDA    #0x20, R12
   \   0000F8   ........     CALLA   #mem_cpy
   3288          				dir[33] = '.'; pcl = dj.sclust;
   \   0000FC   F9402E002100 MOV.B   #0x2e, 0x21(R9)
   \   000102   1E410E00     MOV.W   0xe(SP), R14
   \   000106   1F411000     MOV.W   0x10(SP), R15
   3289          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   00010A   3D010600     MOVA    0x6(SP), R13
   \   00010E   FD9003000000 CMP.B   #0x3, 0(R13)
   \   000114   0820         JNE     ??f_mkdir_11
   \   000116   1E9D2200     CMP.W   0x22(R13), R14
   \   00011A   0520         JNE     ??f_mkdir_11
   \   00011C   1F9D2400     CMP.W   0x24(R13), R15
   \   000120   0220         JNE     ??f_mkdir_11
   3290          					pcl = 0;
   \   000122   0E43         MOV.W   #0x0, R14
   \   000124   0F43         MOV.W   #0x0, R15
   3291          				ST_CLUST(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_11:
   \   000126   C94E3A00     MOV.B   R14, 0x3a(R9)
   \   00012A   0D4E         MOV.W   R14, R13
   \   00012C   8D10         SWPB    R13
   \   00012E   C94D3B00     MOV.B   R13, 0x3b(R9)
   \   000132   C94F3400     MOV.B   R15, 0x34(R9)
   \   000136   8F10         SWPB    R15
   \   000138   C94F3500     MOV.B   R15, 0x35(R9)
   3292          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00013C   3F010600     MOVA    0x6(SP), R15
   \   000140   5E4F0200     MOV.B   0x2(R15), R14
   \   000144   4E93         CMP.B   #0x0, R14
   \   000146   1C24         JEQ     ??f_mkdir_12
   \   000148   C14E0000     MOV.B   R14, 0(SP)
   3293          					dj.fs->winsect = dsc++;
   \                     ??f_mkdir_3:
   \   00014C   3F010600     MOVA    0x6(SP), R15
   \   000150   8F442A00     MOV.W   R4, 0x2a(R15)
   \   000154   8F452C00     MOV.W   R5, 0x2c(R15)
   \   000158   1453         ADD.W   #0x1, R4
   \   00015A   0563         ADDC.W  #0x0, R5
   3294          					dj.fs->wflag = 1;
   \   00015C   3F010600     MOVA    0x6(SP), R15
   \   000160   DF430400     MOV.B   #0x1, 0x4(R15)
   3295          					res = move_window(dj.fs, 0);
   \   000164   ........     CALLA   #?Subroutine6
   3296          					if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_9:
   \   000168   0920         JNE     ??f_mkdir_10
   3297          					mem_set(dir, 0, SS(dj.fs));
   \   00016A   CF09         MOVA    R9, R15
   \   00016C   ........     CALLA   #??Subroutine10_0
   3298          				}
   \                     ??CrossCallReturnLabel_13:
   \   000170   6E41         MOV.B   @SP, R14
   \   000172   7E53         ADD.B   #0xff, R14
   \   000174   C14E0000     MOV.B   R14, 0(SP)
   \   000178   E923         JNE     ??f_mkdir_3
   \   00017A   023C         JMP     ??f_mkdir_12
   3299          			}
   3300          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_10:
   \   00017C   4893         CMP.B   #0x0, R8
   \   00017E   0520         JNE     ??f_mkdir_13
   \                     ??f_mkdir_12:
   \   000180   3C010200     MOVA    0x2(SP), R12
   \   000184   ........     CALLA   #dir_register
   \   000188   484C         MOV.B   R12, R8
   3301          			if (res != FR_OK) {
   \                     ??f_mkdir_13:
   \   00018A   4893         CMP.B   #0x0, R8
   \   00018C   0724         JEQ     ??f_mkdir_14
   3302          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \                     ??f_mkdir_7:
   \   00018E   0E4A         MOV.W   R10, R14
   \   000190   0F4B         MOV.W   R11, R15
   \   000192   3C010600     MOVA    0x6(SP), R12
   \   000196   ........     CALLA   #remove_chain
   \   00019A   163C         JMP     ??f_mkdir_4
   3303          			} else {
   3304          				dir = dj.dir;
   \                     ??f_mkdir_14:
   \   00019C   39011A00     MOVA    0x1a(SP), R9
   3305          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   0001A0   ........     CALLA   #?Subroutine23
   3306          				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
   \                     ??CrossCallReturnLabel_31:
   \   0001A4   8710         SWPB    R7
   \   0001A6   4647         MOV.B   R7, R6
   \   0001A8   C9461900     MOV.B   R6, 0x19(R9)
   3307          				ST_CLUST(dir, dcl);					/* Table start cluster */
   \   0001AC   ........     CALLA   #?Subroutine31
   \                     ??CrossCallReturnLabel_46:
   \   0001B0   8B10         SWPB    R11
   \   0001B2   C94B1500     MOV.B   R11, 0x15(R9)
   3308          				dj.fs->wflag = 1;
   \   0001B6   3F010600     MOVA    0x6(SP), R15
   \   0001BA   DF430400     MOV.B   #0x1, 0x4(R15)
   3309          				res = sync(dj.fs);
   \   0001BE   3C010600     MOVA    0x6(SP), R12
   \   0001C2   ........     CALLA   #sync
   \   0001C6   484C         MOV.B   R12, R8
   3310          			}
   3311          		}
   3312          		FREE_BUF();
   3313          	}
   3314          
   3315          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_4:
   \   0001C8   4C48         MOV.B   R8, R12
   \   0001CA   31503200     ADD.W   #0x32, SP
   \   0001CE   7416         POPM.A  #0x8, R11
   \   0001D0   1001         RETA
   3316          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine31:
   \   000000   C94A1A00     MOV.B   R10, 0x1a(R9)
   \   000004   0F4A         MOV.W   R10, R15
   \   000006   8F10         SWPB    R15
   \   000008   C94F1B00     MOV.B   R15, 0x1b(R9)
   \   00000C   C94B1400     MOV.B   R11, 0x14(R9)
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine23:
   \   000000   F94010000B00 MOV.B   #0x10, 0xb(R9)
   \   000006   C9461600     MOV.B   R6, 0x16(R9)
   \   00000A   0F46         MOV.W   R6, R15
   \   00000C   8F10         SWPB    R15
   \   00000E   C94F1700     MOV.B   R15, 0x17(R9)
   \   000012   C9471800     MOV.B   R7, 0x18(R9)
   \   000016   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   0E43         MOV.W   #0x0, R14
   \   000002   0F43         MOV.W   #0x0, R15
   \   000004   3C010A00     MOVA    0xa(SP), R12
   \   000008   ........     CALLA   #move_window
   \   00000C   484C         MOV.B   R12, R8
   \   00000E   4C93         CMP.B   #0x0, R12
   \   000010   1001         RETA
   3317          
   3318          
   3319          
   3320          
   3321          /*-----------------------------------------------------------------------*/
   3322          /* Change Attribute                                                      */
   3323          /*-----------------------------------------------------------------------*/
   3324          

   \                                 In  segment CODE, align 2, keep-with-next
   3325          FRESULT f_chmod (
   \                     f_chmod:
   3326          	const TCHAR *path,	/* Pointer to the file path */
   3327          	BYTE value,			/* Attribute bits */
   3328          	BYTE mask			/* Attribute mask to change */
   3329          )
   3330          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31802800     SUB.W   #0x28, SP
   \   000008   4A4D         MOV.B   R13, R10
   \   00000A   4B4E         MOV.B   R14, R11
   3331          	FRESULT res;
   3332          	DIRS dj;
   3333          	BYTE *dir;
   3334          	DEF_NAMEBUF;
   3335          
   3336          
   3337          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000C   ........     CALLA   #?Subroutine26
   3338          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_33:
   \   000010   1520         JNE     ??f_chmod_0
   3339          		INIT_BUF(dj);
   \   000012   ........     CALLA   #?Subroutine28
   3340          		res = follow_path(&dj, path);		/* Follow the file path */
   3341          		FREE_BUF();
   3342          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3343          			res = FR_INVALID_NAME;
   3344          		if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_37:
   \   000016   1220         JNE     ??f_chmod_0
   3345          			dir = dj.dir;
   \   000018   3F011400     MOVA    0x14(SP), R15
   3346          			if (!dir) {						/* Is it a root directory? */
   \   00001C   DF03         CMPA    #0x0, R15
   \   00001E   0320         JNE     ??f_chmod_1
   3347          				res = FR_INVALID_NAME;
   \   000020   7C400600     MOV.B   #0x6, R12
   \   000024   0B3C         JMP     ??f_chmod_0
   3348          			} else {						/* File or sub directory */
   3349          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_1:
   \   000026   7BF02700     AND.B   #0x27, R11
   3350          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00002A   5E4F0B00     MOV.B   0xb(R15), R14
   \   00002E   4ECB         BIC.B   R11, R14
   \   000030   4AFB         AND.B   R11, R10
   \   000032   4ADE         BIS.B   R14, R10
   \   000034   CF4A0B00     MOV.B   R10, 0xb(R15)
   3351          				dj.fs->wflag = 1;
   \   000038   ........     CALLA   #?Subroutine22
   3352          				res = sync(dj.fs);
   3353          			}
   3354          		}
   3355          	}
   3356          
   3357          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   00003C   31502C00     ADD.W   #0x2c, SP
   \   000040   1A16         POPM.A  #0x2, R11
   \   000042   1001         RETA
   3358          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine28:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   3F502000     ADD.W   #0x20, R15
   \   000006   710F1C00     MOVA    R15, 0x1c(SP)
   \   00000A   3D012C00     MOVA    0x2c(SP), R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   2C52         ADD.W   #0x4, R12
   \   000012   ........     BRA     #??Subroutine35_1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine26:
   \   000000   5E43         MOV.B   #0x1, R14
   \   000002   0D41         MOV.W   SP, R13
   \   000004   2D52         ADD.W   #0x4, R13
   \   000006   0C41         MOV.W   SP, R12
   \   000008   3C502C00     ADD.W   #0x2c, R12
   \   00000C   ........     CALLA   #chk_mounted
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   3F010400     MOVA    0x4(SP), R15
   \   000004   DF430400     MOV.B   #0x1, 0x4(R15)
   \   000008   3C010400     MOVA    0x4(SP), R12
   \   00000C   ........     BRA     #sync
   3359          
   3360          
   3361          
   3362          
   3363          /*-----------------------------------------------------------------------*/
   3364          /* Change Timestamp                                                      */
   3365          /*-----------------------------------------------------------------------*/
   3366          

   \                                 In  segment CODE, align 2, keep-with-next
   3367          FRESULT f_utime (
   \                     f_utime:
   3368          	const TCHAR *path,	/* Pointer to the file/directory name */
   3369          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3370          )
   3371          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31802800     SUB.W   #0x28, SP
   \   000008   CA0D         MOVA    R13, R10
   3372          	FRESULT res;
   3373          	DIRS dj;
   3374          	BYTE *dir;
   3375          	DEF_NAMEBUF;
   3376          
   3377          
   3378          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000A   ........     CALLA   #?Subroutine26
   3379          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_32:
   \   00000E   1820         JNE     ??f_utime_0
   3380          		INIT_BUF(dj);
   \   000010   ........     CALLA   #?Subroutine28
   3381          		res = follow_path(&dj, path);	/* Follow the file path */
   3382          		FREE_BUF();
   3383          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3384          			res = FR_INVALID_NAME;
   3385          		if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_36:
   \   000014   1520         JNE     ??f_utime_0
   3386          			dir = dj.dir;
   \   000016   3F011400     MOVA    0x14(SP), R15
   3387          			if (!dir) {					/* Root directory */
   \   00001A   DF03         CMPA    #0x0, R15
   \   00001C   0320         JNE     ??f_utime_1
   3388          				res = FR_INVALID_NAME;
   \   00001E   7C400600     MOV.B   #0x6, R12
   \   000022   0E3C         JMP     ??f_utime_0
   3389          			} else {					/* File or sub-directory */
   3390          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_1:
   \   000024   DF4A06001600 MOV.B   0x6(R10), 0x16(R15)
   \   00002A   DF4A07001700 MOV.B   0x7(R10), 0x17(R15)
   3391          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   000030   DF4A04001800 MOV.B   0x4(R10), 0x18(R15)
   \   000036   DF4A05001900 MOV.B   0x5(R10), 0x19(R15)
   3392          				dj.fs->wflag = 1;
   \   00003C   ........     CALLA   #?Subroutine22
   3393          				res = sync(dj.fs);
   3394          			}
   3395          		}
   3396          	}
   3397          
   3398          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   000040   31502C00     ADD.W   #0x2c, SP
   \   000044   0A16         POPM.A  #0x1, R10
   \   000046   1001         RETA
   3399          }
   3400          
   3401          
   3402          
   3403          
   3404          /*-----------------------------------------------------------------------*/
   3405          /* Rename File/Directory                                                 */
   3406          /*-----------------------------------------------------------------------*/
   3407          

   \                                 In  segment CODE, align 2, keep-with-next
   3408          FRESULT f_rename (
   \                     f_rename:
   3409          	const TCHAR *path_old,	/* Pointer to the old name */
   3410          	const TCHAR *path_new	/* Pointer to the new name */
   3411          )
   3412          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31805A00     SUB.W   #0x5a, SP
   \   000008   CB0D         MOVA    R13, R11
   \   00000A   5E43         MOV.B   #0x1, R14
   \   00000C   0D41         MOV.W   SP, R13
   \   00000E   3D501C00     ADD.W   #0x1c, R13
   \   000012   0C41         MOV.W   SP, R12
   \   000014   3C505A00     ADD.W   #0x5a, R12
   3413          	FRESULT res;
   3414          	DIRS djo, djn;
   3415          	BYTE buf[21], *dir;
   3416          	DWORD dw;
   3417          	DEF_NAMEBUF;
   3418          
   3419          
   3420          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   000018   ........     CALLA   #chk_mounted
   3421          	if (res == FR_OK) {
   \   00001C   4C93         CMP.B   #0x0, R12
   \   00001E   A220         JNE     ??f_rename_1
   3422          		djn.fs = djo.fs;
   \   000020   0018D1411C00 MOVX.A  0x1c(SP), 0(SP)
   \            0000        
   3423          		INIT_BUF(djo);
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F503800     ADD.W   #0x38, R15
   \   00002E   710F3400     MOVA    R15, 0x34(SP)
   3424          		res = follow_path(&djo, path_old);		/* Check old object */
   \   000032   0A41         MOV.W   SP, R10
   \   000034   3A501C00     ADD.W   #0x1c, R10
   \   000038   3D015A00     MOVA    0x5a(SP), R13
   \   00003C   ........     CALLA   #?Subroutine35
   3425          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   3426          			res = FR_INVALID_NAME;
   3427          #if _FS_SHARE
   3428          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3429          #endif
   3430          		if (res == FR_OK) {						/* Old object is found */
   \                     ??CrossCallReturnLabel_91:
   \   000040   9120         JNE     ??f_rename_1
   3431          			if (!djo.dir) {						/* Is root dir? */
   \   000042   3D013000     MOVA    0x30(SP), R13
   \   000046   DD03         CMPA    #0x0, R13
   \   000048   0220         JNE     ??f_rename_2
   3432          				res = FR_NO_FILE;
   \   00004A   6C42         MOV.B   #0x4, R12
   \   00004C   8B3C         JMP     ??f_rename_1
   3433          			} else {
   3434          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_2:
   \   00004E   3E401500     MOV.W   #0x15, R14
   \   000052   AD000B00     ADDA    #0xb, R13
   \   000056   0C41         MOV.W   SP, R12
   \   000058   3C504400     ADD.W   #0x44, R12
   \   00005C   ........     CALLA   #mem_cpy
   \   000060   0841         MOV.W   SP, R8
   \   000062   0853         ADD.W   #0x0, R8
   \   000064   3E401C00     MOV.W   #0x1c, R14
   \   000068   CD0A         MOVA    R10, R13
   \   00006A   CC08         MOVA    R8, R12
   3435          				mem_cpy(&djn, &djo, sizeof(DIRS));		/* Check new object */
   \   00006C   ........     CALLA   #mem_cpy
   3436          				res = follow_path(&djn, path_new);
   \   000070   CD0B         MOVA    R11, R13
   \   000072   CC08         MOVA    R8, R12
   \   000074   ........     CALLA   #??Subroutine35_1
   3437          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \                     ??CrossCallReturnLabel_93:
   \   000078   0220         JNE     ??f_rename_3
   \   00007A   7C42         MOV.B   #0x8, R12
   \   00007C   733C         JMP     ??f_rename_1
   3438          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_3:
   \   00007E   6C92         CMP.B   #0x4, R12
   \   000080   7120         JNE     ??f_rename_1
   3439          /* Start critical section that any interruption or error can cause cross-link */
   3440          					res = dir_register(&djn);			/* Register the new entry */
   \   000082   CC08         MOVA    R8, R12
   \   000084   ........     CALLA   #dir_register
   3441          					if (res == FR_OK) {
   \   000088   4C93         CMP.B   #0x0, R12
   \   00008A   6C20         JNE     ??f_rename_1
   3442          						dir = djn.dir;					/* Copy object information except for name */
   \   00008C   3F011400     MOVA    0x14(SP), R15
   3443          						mem_cpy(dir+13, buf+2, 19);
   \   000090   3E401300     MOV.W   #0x13, R14
   \   000094   0D41         MOV.W   SP, R13
   \   000096   3D504600     ADD.W   #0x46, R13
   \   00009A   CC0F         MOVA    R15, R12
   \   00009C   AC000D00     ADDA    #0xd, R12
   \   0000A0   ........     CALLA   #mem_cpy
   3444          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   0000A4   5E414400     MOV.B   0x44(SP), R14
   \   0000A8   7ED02000     BIS.B   #0x20, R14
   \   0000AC   CF4E0B00     MOV.B   R14, 0xb(R15)
   3445          						djo.fs->wflag = 1;
   \   0000B0   3B011C00     MOVA    0x1c(SP), R11
   \   0000B4   DB430400     MOV.B   #0x1, 0x4(R11)
   3446          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   0000B8   919108002400 CMP.W   0x8(SP), 0x24(SP)
   \   0000BE   0420         JNE     ??f_rename_4
   \   0000C0   91910A002600 CMP.W   0xa(SP), 0x26(SP)
   \   0000C6   4524         JEQ     ??f_rename_5
   \                     ??f_rename_4:
   \   0000C8   FFB010000B00 BIT.B   #0x10, 0xb(R15)
   \   0000CE   4128         JNC     ??f_rename_5
   3447          							dw = clust2sect(djn.fs, LD_CLUST(dir));
   \   0000D0   5D4F1A00     MOV.B   0x1a(R15), R13
   \   0000D4   5E4F1B00     MOV.B   0x1b(R15), R14
   \   0000D8   8E10         SWPB    R14
   \   0000DA   0EDD         BIS.W   R13, R14
   \   0000DC   5D4F1400     MOV.B   0x14(R15), R13
   \   0000E0   5F4F1500     MOV.B   0x15(R15), R15
   \   0000E4   8F10         SWPB    R15
   \   0000E6   0FDD         BIS.W   R13, R15
   \   0000E8   0C01         MOVA    @SP, R12
   \   0000EA   ........     CALLA   #clust2sect
   3448          							if (!dw) {
   \   0000EE   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_65:
   \   0000F2   0220         JNE     ??f_rename_6
   3449          								res = FR_INT_ERR;
   \   0000F4   6C43         MOV.B   #0x2, R12
   \   0000F6   363C         JMP     ??f_rename_1
   3450          							} else {
   3451          								res = move_window(djn.fs, dw);
   \                     ??f_rename_6:
   \   0000F8   0E4C         MOV.W   R12, R14
   \   0000FA   0F4D         MOV.W   R13, R15
   \   0000FC   0C01         MOVA    @SP, R12
   \   0000FE   ........     CALLA   #move_window
   3452          								dir = djn.fs->win+SZ_DIR;	/* .. entry */
   \   000102   0F01         MOVA    @SP, R15
   \   000104   AF004E00     ADDA    #0x4e, R15
   3453          								if (res == FR_OK && dir[1] == '.') {
   \   000108   4C93         CMP.B   #0x0, R12
   \   00010A   2C20         JNE     ??f_rename_1
   \   00010C   FF902E000100 CMP.B   #0x2e, 0x1(R15)
   \   000112   1F20         JNE     ??f_rename_5
   3454          									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
   \   000114   1C410800     MOV.W   0x8(SP), R12
   \   000118   1D410A00     MOV.W   0xa(SP), R13
   \   00011C   0B01         MOVA    @SP, R11
   \   00011E   FB9003000000 CMP.B   #0x3, 0(R11)
   \   000124   0820         JNE     ??f_rename_0
   \   000126   1C9B2200     CMP.W   0x22(R11), R12
   \   00012A   0520         JNE     ??f_rename_0
   \   00012C   1D9B2400     CMP.W   0x24(R11), R13
   \   000130   0220         JNE     ??f_rename_0
   \   000132   0C43         MOV.W   #0x0, R12
   \   000134   0D43         MOV.W   #0x0, R13
   3455          									ST_CLUST(dir, dw);
   \                     ??f_rename_0:
   \   000136   CF4C1A00     MOV.B   R12, 0x1a(R15)
   \   00013A   0E4C         MOV.W   R12, R14
   \   00013C   8E10         SWPB    R14
   \   00013E   CF4E1B00     MOV.B   R14, 0x1b(R15)
   \   000142   CF4D1400     MOV.B   R13, 0x14(R15)
   \   000146   8D10         SWPB    R13
   \   000148   CF4D1500     MOV.B   R13, 0x15(R15)
   3456          									djn.fs->wflag = 1;
   \   00014C   0F01         MOVA    @SP, R15
   \   00014E   DF430400     MOV.B   #0x1, 0x4(R15)
   3457          								}
   3458          							}
   3459          						}
   3460          						if (res == FR_OK) {
   3461          							res = dir_remove(&djo);		/* Remove old entry */
   \                     ??f_rename_5:
   \   000152   CC0A         MOVA    R10, R12
   \   000154   ........     CALLA   #dir_remove
   3462          							if (res == FR_OK)
   \   000158   4C93         CMP.B   #0x0, R12
   \   00015A   0420         JNE     ??f_rename_1
   3463          								res = sync(djo.fs);
   \   00015C   3C011C00     MOVA    0x1c(SP), R12
   \   000160   ........     CALLA   #sync
   3464          						}
   3465          					}
   3466          /* End critical section */
   3467          				}
   3468          			}
   3469          		}
   3470          		FREE_BUF();
   3471          	}
   3472          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_1:
   \   000164   31505E00     ADD.W   #0x5e, SP
   \   000168   3816         POPM.A  #0x4, R11
   \   00016A   1001         RETA
   3473          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine10:
   \   000000   AF002E00     ADDA    #0x2e, R15
   \                     ??Subroutine10_0:
   \   000004   3E400001     MOV.W   #0x100, R14
   \                     ??sync_0:
   \   000008   CF430000     MOV.B   #0x0, 0(R15)
   \   00000C   AF000100     ADDA    #0x1, R15
   \   000010   CF430000     MOV.B   #0x0, 0(R15)
   \   000014   AF000100     ADDA    #0x1, R15
   \   000018   3E53         ADD.W   #0xffff, R14
   \   00001A   F623         JNE     ??sync_0
   \   00001C   1001         RETA

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "\\"*+,:;<=>?[]|\\177">`:
   \   000000   222A2B2C3A3B DC8 "\"*+,:;<=>?[]|\177"
   \            3C3D3E3F5B5D
   \            7C7F00      
   3474          
   3475          #endif /* !_FS_READONLY */
   3476          #endif /* _FS_MINIMIZE == 0 */
   3477          #endif /* _FS_MINIMIZE <= 1 */
   3478          #endif /* _FS_MINIMIZE <= 2 */
   3479          
   3480          
   3481          
   3482          /*-----------------------------------------------------------------------*/
   3483          /* Forward data to the stream directly (available on only tiny cfg)      */
   3484          /*-----------------------------------------------------------------------*/
   3485          #if _USE_FORWARD && _FS_TINY
   3486          
   3487          FRESULT f_forward (
   3488          	FIL *fp, 						/* Pointer to the file object */
   3489          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3490          	UINT btr,						/* Number of bytes to forward */
   3491          	UINT *bf						/* Pointer to number of bytes forwarded */
   3492          )
   3493          {
   3494          	FRESULT res;
   3495          	DWORD remain, clst, sect;
   3496          	UINT rcnt;
   3497          	BYTE csect;
   3498          
   3499          
   3500          	*bf = 0;	/* Initialize byte counter */
   3501          
   3502          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   3503          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3504          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3505          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3506          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3507          		LEAVE_FF(fp->fs, FR_DENIED);
   3508          
   3509          	remain = fp->fsize - fp->fptr;
   3510          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   3511          
   3512          	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3513          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3514          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3515          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3516          			if (!csect) {							/* On the cluster boundary? */
   3517          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3518          					fp->sclust : get_fat(fp->fs, fp->clust);
   3519          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3520          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3521          				fp->clust = clst;					/* Update current cluster */
   3522          			}
   3523          		}
   3524          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3525          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3526          		sect += csect;
   3527          		if (move_window(fp->fs, sect))				/* Move sector window */
   3528          			ABORT(fp->fs, FR_DISK_ERR);
   3529          		fp->dsect = sect;
   3530          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3531          		if (rcnt > btr) rcnt = btr;
   3532          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3533          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3534          	}
   3535          
   3536          	LEAVE_FF(fp->fs, FR_OK);
   3537          }
   3538          #endif /* _USE_FORWARD */
   3539          
   3540          
   3541          
   3542          #if _USE_MKFS && !_FS_READONLY
   3543          /*-----------------------------------------------------------------------*/
   3544          /* Create File System on the Drive                                       */
   3545          /*-----------------------------------------------------------------------*/
   3546          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3547          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3548          
   3549          
   3550          FRESULT f_mkfs (
   3551          	BYTE drv,		/* Logical drive number */
   3552          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3553          	UINT au			/* Allocation unit size [bytes] */
   3554          )
   3555          {
   3556          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3557          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3558          	BYTE fmt, md, *tbl;
   3559          	DWORD n_clst, vs, n, wsect;
   3560          	UINT i;
   3561          	DWORD b_vol, b_fat, b_dir, b_data;	/* Offset (LBA) */
   3562          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3563          	FATFS *fs;
   3564          	DSTATUS stat;
   3565          
   3566          
   3567          	/* Check mounted drive and clear work area */
   3568          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   3569          	fs = FatFs[drv];
   3570          	if (!fs) return FR_NOT_ENABLED;
   3571          	fs->fs_type = 0;
   3572          	drv = LD2PD(drv);
   3573          
   3574          	/* Get disk statics */
   3575          	stat = disk_initialize(drv);
   3576          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3577          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3578          #if _MAX_SS != 512					/* Get disk sector size */
   3579          	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK)
   3580          		return FR_DISK_ERR;
   3581          #endif
   3582          	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   3583          		return FR_DISK_ERR;
   3584          	b_vol = (sfd) ? 0 : 63;	/* Volume start sector */
   3585          	n_vol -= b_vol;
   3586          	if (au & (au - 1)) au = 0;	/* Check validity of the AU size */
   3587          	if (!au) {					/* AU auto selection */
   3588          		vs = n_vol / (2000 / (SS(fs) / 512));
   3589          		for (i = 0; vs < vst[i]; i++) ;
   3590          		au = cst[i];
   3591          	}
   3592          	au /= SS(fs);		/* Number of sectors per cluster */
   3593          	if (au == 0) au = 1;
   3594          	if (au > 128) au = 128;
   3595          
   3596          	/* Pre-compute number of clusters and FAT syb-type */
   3597          	n_clst = n_vol / au;
   3598          	fmt = FS_FAT12;
   3599          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   3600          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   3601          
   3602          	/* Determine offset and size of FAT structure */
   3603          	if (fmt == FS_FAT32) {
   3604          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   3605          		n_rsv = 32;
   3606          		n_dir = 0;
   3607          	} else {
   3608          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   3609          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   3610          		n_rsv = 1;
   3611          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   3612          	}
   3613          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   3614          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   3615          	b_data = b_dir + n_dir;				/* Data area start sector */
   3616          	if (n_vol < b_data + au) return FR_MKFS_ABORTED;	/* Too small volume */
   3617          
   3618          	/* Align data start sector to erase block boundary (for flash memory media) */
   3619          	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   3620          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   3621          	n = (n - b_data) / N_FATS;
   3622          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   3623          		n_rsv += n;
   3624          		b_fat += n;
   3625          	} else {					/* FAT12/16: Expand FAT size */
   3626          		n_fat += n;
   3627          	}
   3628          
   3629          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3630          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   3631          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3632          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   3633          		return FR_MKFS_ABORTED;
   3634          
   3635          	/* Create partition table if required */
   3636          	if (sfd) {	/* No patition table (SFD) */
   3637          		md = 0xF0;
   3638          	} else {	/* With patition table (FDISK) */
   3639          		DWORD n_disk = b_vol + n_vol;
   3640          
   3641          		mem_set(fs->win, 0, SS(fs));
   3642          		tbl = fs->win+MBR_Table;
   3643          		ST_DWORD(tbl, 0x00010180);			/* Partition start in CHS */
   3644          		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
   3645          			n_disk = n_disk / 63 / 255;
   3646          			tbl[7] = (BYTE)n_disk;
   3647          			tbl[6] = (BYTE)((n_disk >> 2) | 63);
   3648          		} else {
   3649          			ST_WORD(&tbl[6], 0xFFFF);	/* CHS saturated */
   3650          		}
   3651          		tbl[5] = 254;
   3652          		if (fmt != FS_FAT32)				/* System ID */
   3653          			tbl[4] = (n_vol < 0x10000) ? 0x04 : 0x06;
   3654          		else
   3655          			tbl[4] = 0x0c;
   3656          		ST_DWORD(tbl+8, 63);				/* Partition start in LBA */
   3657          		ST_DWORD(tbl+12, n_vol);			/* Partition size in LBA */
   3658          		ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   3659          		if (disk_write(drv, fs->win, 0, 1) != RES_OK)	/* Put the MBR into first physical sector */
   3660          			return FR_DISK_ERR;
   3661          		md = 0xF8;
   3662          	}
   3663          
   3664          	/* Create volume boot record */
   3665          	tbl = fs->win;							/* Clear sector */
   3666          	mem_set(tbl, 0, SS(fs));
   3667          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   3668          	i = SS(fs);								/* Sector size */
   3669          	ST_WORD(tbl+BPB_BytsPerSec, i);
   3670          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   3671          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   3672          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   3673          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   3674          	ST_WORD(tbl+BPB_RootEntCnt, i);
   3675          	if (n_vol < 0x10000) {					/* Number of total sectors */
   3676          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   3677          	} else {
   3678          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   3679          	}
   3680          	tbl[BPB_Media] = md;					/* Media descriptor */
   3681          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   3682          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   3683          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   3684          	n = get_fattime();						/* Use current time as VSN */
   3685          	if (fmt == FS_FAT32) {
   3686          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   3687          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   3688          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   3689          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   3690          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   3691          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   3692          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   3693          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   3694          	} else {
   3695          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   3696          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   3697          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   3698          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   3699          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   3700          	}
   3701          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   3702          	if (disk_write(drv, tbl, b_vol, 1) != RES_OK)	/* Write VBR */
   3703          		return FR_DISK_ERR;
   3704          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   3705          		disk_write(drv, tbl, b_vol + 6, 1);
   3706          
   3707          	/* Initialize FAT area */
   3708          	wsect = b_fat;
   3709          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   3710          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   3711          		n = md;								/* Media descriptor byte */
   3712          		if (fmt != FS_FAT32) {
   3713          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   3714          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   3715          		} else {
   3716          			n |= 0xFFFFFF00;
   3717          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   3718          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   3719          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   3720          		}
   3721          		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3722          			return FR_DISK_ERR;
   3723          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   3724          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   3725          			if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3726          				return FR_DISK_ERR;
   3727          		}
   3728          	}
   3729          
   3730          	/* Initialize root directory */
   3731          	i = (fmt == FS_FAT32) ? au : n_dir;
   3732          	do {
   3733          		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3734          			return FR_DISK_ERR;
   3735          	} while (--i);
   3736          
   3737          #if _USE_ERASE	/* Erase data area if needed */
   3738          	{
   3739          		DWORD eb[2];
   3740          
   3741          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3742          		disk_ioctl(drv, CTRL_ERASE_SECTOR, eb);
   3743          	}
   3744          #endif
   3745          
   3746          	/* Create FSInfo if needed */
   3747          	if (fmt == FS_FAT32) {
   3748          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   3749          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   3750          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   3751          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   3752          		ST_WORD(tbl+BS_55AA, 0xAA55);
   3753          		disk_write(drv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   3754          		disk_write(drv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   3755          	}
   3756          
   3757          	return (disk_ioctl(drv, CTRL_SYNC, (void*)0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   3758          }
   3759          
   3760          #endif /* _USE_MKFS && !_FS_READONLY */
   3761          
   3762          
   3763          
   3764          
   3765          #if _USE_STRFUNC
   3766          /*-----------------------------------------------------------------------*/
   3767          /* Get a string from the file                                            */
   3768          /*-----------------------------------------------------------------------*/
   3769          TCHAR* f_gets (
   3770          	TCHAR* buff,	/* Pointer to the string buffer to read */
   3771          	int len,		/* Size of string buffer (characters) */
   3772          	FIL* fil		/* Pointer to the file object */
   3773          )
   3774          {
   3775          	int n = 0;
   3776          	TCHAR c, *p = buff;
   3777          	BYTE s[2];
   3778          	UINT rc;
   3779          
   3780          
   3781          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   3782          		f_read(fil, s, 1, &rc);
   3783          		if (rc != 1) break;			/* Break on EOF or error */
   3784          		c = s[0];
   3785          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   3786          		if (c >= 0x80) {
   3787          			if (c < 0xC0) continue;	/* Skip stray trailer */
   3788          			if (c < 0xE0) {			/* Two-byte sequense */
   3789          				f_read(fil, s, 1, &rc);
   3790          				if (rc != 1) break;
   3791          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3792          				if (c < 0x80) c = '?';
   3793          			} else {
   3794          				if (c < 0xF0) {		/* Three-byte sequense */
   3795          					f_read(fil, s, 2, &rc);
   3796          					if (rc != 2) break;
   3797          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3798          					if (c < 0x800) c = '?';
   3799          				} else {			/* Reject four-byte sequense */
   3800          					c = '?';
   3801          				}
   3802          			}
   3803          		}
   3804          #endif
   3805          #if _USE_STRFUNC >= 2
   3806          		if (c == '\r') continue;	/* Strip '\r' */
   3807          #endif
   3808          		*p++ = c;
   3809          		n++;
   3810          		if (c == '\n') break;		/* Break on EOL */
   3811          	}
   3812          	*p = 0;
   3813          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   3814          }
   3815          
   3816          
   3817          
   3818          #if !_FS_READONLY
   3819          #include <stdarg.h>
   3820          /*-----------------------------------------------------------------------*/
   3821          /* Put a character to the file                                           */
   3822          /*-----------------------------------------------------------------------*/
   3823          int f_putc (
   3824          	TCHAR c,	/* A character to be output */
   3825          	FIL* fil	/* Pointer to the file object */
   3826          )
   3827          {
   3828          	UINT bw, btw;
   3829          	BYTE s[3];
   3830          
   3831          
   3832          #if _USE_STRFUNC >= 2
   3833          	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   3834          #endif
   3835          
   3836          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   3837          	if (c < 0x80) {			/* 7-bit */
   3838          		s[0] = (BYTE)c;
   3839          		btw = 1;
   3840          	} else {
   3841          		if (c < 0x800) {	/* 11-bit */
   3842          			s[0] = (BYTE)(0xC0 | (c >> 6));
   3843          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   3844          			btw = 2;
   3845          		} else {			/* 16-bit */
   3846          			s[0] = (BYTE)(0xE0 | (c >> 12));
   3847          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   3848          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   3849          			btw = 3;
   3850          		}
   3851          	}
   3852          #else				/* Write the character without conversion */
   3853          	s[0] = (BYTE)c;
   3854          	btw = 1;
   3855          #endif
   3856          	f_write(fil, s, btw, &bw);		/* Write the char to the file */
   3857          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   3858          }
   3859          
   3860          
   3861          
   3862          
   3863          /*-----------------------------------------------------------------------*/
   3864          /* Put a string to the file                                              */
   3865          /*-----------------------------------------------------------------------*/
   3866          int f_puts (
   3867          	const TCHAR* str,	/* Pointer to the string to be output */
   3868          	FIL* fil			/* Pointer to the file object */
   3869          )
   3870          {
   3871          	int n;
   3872          
   3873          
   3874          	for (n = 0; *str; str++, n++) {
   3875          		if (f_putc(*str, fil) == EOF) return EOF;
   3876          	}
   3877          	return n;
   3878          }
   3879          
   3880          
   3881          
   3882          
   3883          /*-----------------------------------------------------------------------*/
   3884          /* Put a formatted string to the file                                    */
   3885          /*-----------------------------------------------------------------------*/
   3886          int f_printf (
   3887          	FIL* fil,			/* Pointer to the file object */
   3888          	const TCHAR* str,	/* Pointer to the format string */
   3889          	...					/* Optional arguments... */
   3890          )
   3891          {
   3892          	va_list arp;
   3893          	BYTE f, r;
   3894          	UINT i, j, w;
   3895          	ULONG v;
   3896          	TCHAR c, d, s[16], *p;
   3897          	int res, cc;
   3898          
   3899          
   3900          	va_start(arp, str);
   3901          
   3902          	for (cc = res = 0; cc != EOF; res += cc) {
   3903          		c = *str++;
   3904          		if (c == 0) break;			/* End of string */
   3905          		if (c != '%') {				/* Non escape character */
   3906          			cc = f_putc(c, fil);
   3907          			if (cc != EOF) cc = 1;
   3908          			continue;
   3909          		}
   3910          		w = f = 0;
   3911          		c = *str++;
   3912          		if (c == '0') {				/* Flag: '0' padding */
   3913          			f = 1; c = *str++;
   3914          		} else {
   3915          			if (c == '-') {			/* Flag: left justified */
   3916          				f = 2; c = *str++;
   3917          			}
   3918          		}
   3919          		while (IsDigit(c)) {		/* Precision */
   3920          			w = w * 10 + c - '0';
   3921          			c = *str++;
   3922          		}
   3923          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   3924          			f |= 4; c = *str++;
   3925          		}
   3926          		if (!c) break;
   3927          		d = c;
   3928          		if (IsLower(d)) d -= 0x20;
   3929          		switch (d) {				/* Type is... */
   3930          		case 'S' :					/* String */
   3931          			p = va_arg(arp, TCHAR*);
   3932          			for (j = 0; p[j]; j++) ;
   3933          			res = 0;
   3934          			while (!(f & 2) && j++ < w) res += (cc = f_putc(' ', fil));
   3935          			res += (cc = f_puts(p, fil));
   3936          			while (j++ < w) res += (cc = f_putc(' ', fil));
   3937          			if (cc != EOF) cc = res;
   3938          			continue;
   3939          		case 'C' :					/* Character */
   3940          			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   3941          		case 'B' :					/* Binary */
   3942          			r = 2; break;
   3943          		case 'O' :					/* Octal */
   3944          			r = 8; break;
   3945          		case 'D' :					/* Signed decimal */
   3946          		case 'U' :					/* Unsigned decimal */
   3947          			r = 10; break;
   3948          		case 'X' :					/* Hexdecimal */
   3949          			r = 16; break;
   3950          		default:					/* Unknown type (passthrough) */
   3951          			cc = f_putc(c, fil); continue;
   3952          		}
   3953          
   3954          		/* Get an argument and put it in numeral */
   3955          		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : va_arg(arp, unsigned int));
   3956          		if (d == 'D' && (v & 0x80000000)) {
   3957          			v = 0 - v;
   3958          			f |= 8;
   3959          		}
   3960          		i = 0;
   3961          		do {
   3962          			d = (TCHAR)(v % r); v /= r;
   3963          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   3964          			s[i++] = d + '0';
   3965          		} while (v && i < sizeof(s) / sizeof(s[0]));
   3966          		if (f & 8) s[i++] = '-';
   3967          		j = i; d = (f & 1) ? '0' : ' ';
   3968          		res = 0;
   3969          		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   3970          		do res += (cc = f_putc(s[--i], fil)); while(i);
   3971          		while (j++ < w) res += (cc = f_putc(' ', fil));
   3972          		if (cc != EOF) cc = res;
   3973          	}
   3974          
   3975          	va_end(arp);
   3976          	return (cc == EOF) ? cc : res;
   3977          }
   3978          
   3979          #endif /* !_FS_READONLY */
   3980          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      10  check_fs
             10 -> disk_read
      40  chk_mounted
             38 -> check_fs
             38 -> disk_initialize
             40 -> disk_read
             38 -> disk_status
       8  clust2sect
      40  create_chain
             36 -> get_fat
             40 -> put_fat
      36  create_name
      12  dir_find
             12 -> dir_next
             12 -> dir_sdi
             12 -> mem_cmp
             12 -> move_window
      28  dir_next
             28 -> clust2sect
             28 -> create_chain
             28 -> get_fat
             28 -> move_window
       8  dir_read
              8 -> dir_next
              8 -> move_window
       8  dir_register
              8 -> dir_next
              8 -> dir_sdi
              8 -> mem_cpy
              8 -> move_window
       8  dir_remove
              8 -> dir_sdi
              8 -> move_window
      20  dir_sdi
             20 -> clust2sect
             20 -> get_fat
      56  f_chmod
             56 -> chk_mounted
             56 -> follow_path
             56 -> sync
       8  f_close
              8 -> f_sync
      54  f_getfree
             50 -> chk_mounted
             50 -> get_fat
             50 -> move_window
      46  f_lseek
             42 -> clust2sect
             42 -> create_chain
             42 -> get_fat
             42 -> validate
      86  f_mkdir
             86 -> chk_mounted
             86 -> clust2sect
             86 -> create_chain
             86 -> dir_register
             86 -> follow_path
             86 -> get_fattime
             86 -> mem_cpy
             86 -> move_window
             86 -> remove_chain
             86 -> sync
       4  f_mount
      80  f_open
             80 -> chk_mounted
             80 -> dir_register
             80 -> follow_path
             80 -> get_fattime
             80 -> move_window
             80 -> remove_chain
      24  f_opendir
             24 -> chk_mounted
             24 -> dir_sdi
             24 -> follow_path
      42  f_read
             40 -> clust2sect
             42 -> disk_read
             40 -> get_fat
             40 -> mem_cpy
             40 -> move_window
             40 -> validate
      24  f_readdir
             24 -> dir_next
             24 -> dir_read
             24 -> dir_sdi
             24 -> get_fileinfo
             24 -> validate
     114  f_rename
            114 -> chk_mounted
            114 -> clust2sect
            114 -> dir_register
            114 -> dir_remove
            114 -> follow_path
            114 -> mem_cpy
            114 -> move_window
            114 -> sync
      64  f_stat
             64 -> chk_mounted
             64 -> follow_path
             64 -> get_fileinfo
      12  f_sync
             12 -> get_fattime
             12 -> move_window
             12 -> sync
             12 -> validate
      24  f_truncate
             20 -> get_fat
             24 -> put_fat
             20 -> remove_chain
             20 -> validate
      92  f_unlink
             92 -> chk_mounted
             92 -> dir_read
             92 -> dir_remove
             92 -> dir_sdi
             92 -> follow_path
             92 -> mem_cpy
             92 -> remove_chain
             92 -> sync
      52  f_utime
             52 -> chk_mounted
             52 -> follow_path
             52 -> sync
      42  f_write
             40 -> clust2sect
             40 -> create_chain
             42 -> disk_write
             40 -> mem_cpy
             40 -> move_window
             40 -> validate
      12  follow_path
             12 -> create_name
             12 -> dir_find
             12 -> dir_sdi
      28  get_fat
             28 -> move_window
      28  get_fileinfo
       8  mem_cmp
       4  mem_cpy
      30  move_window
             30 -> disk_read
             30 -> disk_write
      28  put_fat
             28 -> move_window
      32  remove_chain
             28 -> get_fat
             32 -> put_fat
      14  sync
             12 -> disk_ioctl
             14 -> disk_write
             12 -> move_window
       4  validate
              4 -> disk_status


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?<Constant "\"*+,:;<=>?[]|\177">
       8  ??Subroutine19_0
       8  ??Subroutine35_1
       6  ??Subroutine40_0
       8  ??Subroutine42_0
       6  ?Subroutine0
      12  ?Subroutine1
      30  ?Subroutine10
      24  ?Subroutine11
      10  ?Subroutine12
      10  ?Subroutine13
      20  ?Subroutine14
      34  ?Subroutine15
      12  ?Subroutine16
      12  ?Subroutine17
      10  ?Subroutine18
       4  ?Subroutine19
      10  ?Subroutine2
      22  ?Subroutine20
       6  ?Subroutine21
      16  ?Subroutine22
      24  ?Subroutine23
       8  ?Subroutine24
       2  ?Subroutine25
      20  ?Subroutine26
      10  ?Subroutine27
      22  ?Subroutine28
      10  ?Subroutine29
      10  ?Subroutine3
      10  ?Subroutine30
      18  ?Subroutine31
      10  ?Subroutine32
       8  ?Subroutine33
      10  ?Subroutine34
       2  ?Subroutine35
      10  ?Subroutine36
       8  ?Subroutine37
       8  ?Subroutine38
       8  ?Subroutine39
      10  ?Subroutine4
      24  ?Subroutine5
      18  ?Subroutine6
      26  ?Subroutine7
       2  ?Subroutine8
       6  ?Subroutine9
       4  FatFs
       2  Fsid
     120  check_fs
     950  chk_mounted
      66  clust2sect
     262  create_chain
     372  create_name
      92  dir_find
     292  dir_next
      72  dir_read
     122  dir_register
      48  dir_remove
     218  dir_sdi
      68  f_chmod
      22  f_close
     364  f_getfree
     486  f_lseek
     466  f_mkdir
      38  f_mount
     466  f_open
      98  f_opendir
     378  f_read
      88  f_readdir
     364  f_rename
      90  f_stat
     160  f_sync
     196  f_truncate
     236  f_unlink
      72  f_utime
     516  f_write
     134  follow_path
     224  get_fat
     214  get_fileinfo
      26  mem_cmp
      18  mem_cpy
     168  move_window
     274  put_fat
     134  remove_chain
     224  sync
      44  validate

 
 8 734 bytes in segment CODE
    15 bytes in segment DATA20_C
     6 bytes in segment DATA20_Z
 
 8 734 bytes of CODE  memory
    15 bytes of CONST memory
     6 bytes of DATA  memory

Errors: none
Warnings: none
