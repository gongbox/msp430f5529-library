###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:32 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_q.c                           #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_q.c -D NDEBUG -D RAM_VECTOR   #
#                     -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C° #
#                     æ\¹¤³ÌÄ£°å\Release\List\ -lA                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_q.lst                            #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_q.r43                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_q.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                        MESSAGE QUEUE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_Q.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include "ucos_ii.h"

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          #endif
     27          
     28          #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
     29          /*
     30          *********************************************************************************************************
     31          *                                      ACCEPT MESSAGE FROM QUEUE
     32          *
     33          * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
     34          *              OSQAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          *              perr          is a pointer to where an error message will be deposited.  Possible error
     39          *                            messages are:
     40          *
     41          *                            OS_ERR_NONE         The call was successful and your task received a
     42          *                                                message.
     43          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
     44          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
     45          *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
     46          *
     47          * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
     48          *                            from the so the next time OSQAccept() is called, the queue will contain
     49          *                            one less entry.
     50          *              == (void *)0  if you received a NULL pointer message
     51          *                            if the queue is empty or,
     52          *                            if 'pevent' is a NULL pointer or,
     53          *                            if you passed an invalid event type
     54          *
     55          * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
     56          *              'perr' has been added to the API to tell you about the outcome of the call.
     57          *********************************************************************************************************
     58          */
     59          
     60          #if OS_Q_ACCEPT_EN > 0u

   \                                 In  segment CODE, align 2
   \                     ?Subroutine9:
   \   000000   0018DF4F0400 MOVX.A  0x4(R15), 0x10(R15)
   \            1000        
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
     61          void  *OSQAccept (OS_EVENT  *pevent,
   \                     OSQAccept:
     62                            INT8U     *perr)
     63          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   CA0D         MOVA    R13, R10
     64              void      *pmsg;
     65              OS_Q      *pq;
     66          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     67              OS_CPU_SR  cpu_sr = 0u;
     68          #endif
     69          
     70          
     71          
     72          #ifdef OS_SAFETY_CRITICAL
     73              if (perr == (INT8U *)0) {
     74                  OS_SAFETY_CRITICAL_EXCEPTION();
     75              }
     76          #endif
     77          
     78          #if OS_ARG_CHK_EN > 0u
     79              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
     80                  *perr = OS_ERR_PEVENT_NULL;
     81                  return ((void *)0);
     82              }
     83          #endif
     84              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \   000006   EC930000     CMP.B   #0x2, 0(R12)
   \   00000A   0424         JEQ     ??OSQAccept_0
     85                  *perr = OS_ERR_EVENT_TYPE;
   \   00000C   DD430000     MOV.B   #0x1, 0(R13)
     86                  return ((void *)0);
   \   000010   4C43         MOVA    #0x0, R12
   \   000012   1B3C         JMP     ??OSQAccept_1
     87              }
     88              OS_ENTER_CRITICAL();
   \                     ??OSQAccept_0:
   \   000014   ........     CALLA   #OSCPUSaveSR
     89              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   000018   3F0B0200     MOVA    0x2(R11), R15
     90              if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
   \   00001C   8F931600     CMP.W   #0x0, 0x16(R15)
   \   000020   0C24         JEQ     ??OSQAccept_2
     91                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   000022   ........     CALLA   #?Subroutine8
     92                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
     93                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \                     ??CrossCallReturnLabel_13:
   \   000026   3E0F1000     MOVA    0x10(R15), R14
   \   00002A   3D0F0800     MOVA    0x8(R15), R13
   \   00002E   DE0D         CMPA    R13, R14
   \   000030   0220         JNE     ??OSQAccept_3
     94                      pq->OSQOut = pq->OSQStart;
   \   000032   ........     CALLA   #?Subroutine9
     95                  }
     96                  *perr = OS_ERR_NONE;
   \                     ??OSQAccept_3:
   \   000036   4E43         MOV.B   #0x0, R14
   \   000038   033C         JMP     ??OSQAccept_4
     97              } else {
     98                  *perr = OS_ERR_Q_EMPTY;
   \                     ??OSQAccept_2:
   \   00003A   7E401F00     MOV.B   #0x1f, R14
     99                  pmsg  = (void *)0;                       /* Queue is empty                                     */
   \   00003E   4B43         MOVA    #0x0, R11
   \                     ??OSQAccept_4:
   \   000040   CA4E0000     MOV.B   R14, 0(R10)
    100              }
    101              OS_EXIT_CRITICAL();
   \   000044   ........     CALLA   #OSCPURestoreSR
    102              return (pmsg);                               /* Return message received (or NULL)                  */
   \   000048   CC0B         MOVA    R11, R12
   \                     ??OSQAccept_1:
   \   00004A   1A16         POPM.A  #0x2, R11
   \   00004C   1001         RETA
    103          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine8:
   \   000000   3B0F1000     MOVA    0x10(R15), R11
   \   000004   0B0B         MOVA    @R11, R11
   \   000006   0018EF521000 ADDX.A  #0x4, 0x10(R15)
   \   00000C   BF531600     ADD.W   #0xffff, 0x16(R15)
   \   000010   1001         RETA
    104          #endif
    105          /*$PAGE*/
    106          /*
    107          *********************************************************************************************************
    108          *                                        CREATE A MESSAGE QUEUE
    109          *
    110          * Description: This function creates a message queue if free event control blocks are available.
    111          *
    112          * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
    113          *                            storage area MUST be declared as an array of pointers to 'void' as follows
    114          *
    115          *                            void *MessageStorage[size]
    116          *
    117          *              size          is the number of elements in the storage area
    118          *
    119          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    120          *                                created queue
    121          *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
    122          *********************************************************************************************************
    123          */
    124          

   \                                 In  segment CODE, align 2
    125          OS_EVENT  *OSQCreate (void    **start,
   \                     OSQCreate:
    126                                INT16U    size)
    127          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   0A4D         MOV.W   R13, R10
    128              OS_EVENT  *pevent;
    129              OS_Q      *pq;
    130          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    131              OS_CPU_SR  cpu_sr = 0u;
    132          #endif
    133          
    134          
    135          
    136          #ifdef OS_SAFETY_CRITICAL_IEC61508
    137              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    138                  OS_SAFETY_CRITICAL_EXCEPTION();
    139              }
    140          #endif
    141          
    142              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \   000006   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00000C   0224         JEQ     ??OSQCreate_0
    143                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   00000E   4C43         MOVA    #0x0, R12
   \   000010   3F3C         JMP     ??OSQCreate_1
    144              }
    145              OS_ENTER_CRITICAL();
   \                     ??OSQCreate_0:
   \   000012   ........     CALLA   #OSCPUSaveSR
    146              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   000016   ........     MOVA    #OSEventFreeList, R6
   \   00001A   0F06         MOVA    @R6, R15
   \   00001C   0806         MOVA    @R6, R8
    147              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   00001E   DF03         CMPA    #0x0, R15
   \   000020   0424         JEQ     ??OSQCreate_2
    148                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   000022   0018D64F0200 MOVX.A  0x2(R15), 0(R6)
   \            0000        
    149              }
    150              OS_EXIT_CRITICAL();
   \                     ??OSQCreate_2:
   \   00002A   ........     CALLA   #OSCPURestoreSR
    151              if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
   \   00002E   D803         CMPA    #0x0, R8
   \   000030   2E24         JEQ     ??OSQCreate_3
    152                  OS_ENTER_CRITICAL();
   \   000032   ........     CALLA   #OSCPUSaveSR
   \   000036   ........     MOVA    &OSQFreeList, R15
   \   00003A   C90F         MOVA    R15, R9
    153                  pq = OSQFreeList;                        /* Get a free queue control block                     */
    154                  if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
   \   00003C   DF03         CMPA    #0x0, R15
   \   00003E   1F24         JEQ     ??OSQCreate_4
    155                      OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
   \   000040   ....E24F.... MOVX.A  @R15, &OSQFreeList
    156                      OS_EXIT_CRITICAL();
   \   000046   ........     CALLA   #OSCPURestoreSR
    157                      pq->OSQStart           = start;               /*      Initialize the queue                 */
   \   00004A   790B0400     MOVA    R11, 0x4(R9)
    158                      pq->OSQEnd             = &start[size];
   \   00004E   0F4A         MOV.W   R10, R15
   \   000050   4F06         RLAM.A  #0x2, R15
   \   000052   CE0B         MOVA    R11, R14
   \   000054   EE0F         ADDA    R15, R14
   \   000056   790E0800     MOVA    R14, 0x8(R9)
    159                      pq->OSQIn              = start;
   \   00005A   790B0C00     MOVA    R11, 0xc(R9)
    160                      pq->OSQOut             = start;
   \   00005E   790B1000     MOVA    R11, 0x10(R9)
    161                      pq->OSQSize            = size;
   \   000062   894A1400     MOV.W   R10, 0x14(R9)
    162                      pq->OSQEntries         = 0u;
   \   000066   89431600     MOV.W   #0x0, 0x16(R9)
    163                      pevent->OSEventType    = OS_EVENT_TYPE_Q;
   \   00006A   E8430000     MOV.B   #0x2, 0(R8)
    164                      pevent->OSEventCnt     = 0u;
   \   00006E   88430600     MOV.W   #0x0, 0x6(R8)
    165                      pevent->OSEventPtr     = pq;
   \   000072   78090200     MOVA    R9, 0x2(R8)
    166          #if OS_EVENT_NAME_EN > 0u
    167                      pevent->OSEventName    = (INT8U *)(void *)"?";
    168          #endif
    169                      OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
   \   000076   CC08         MOVA    R8, R12
   \   000078   ........     CALLA   #OS_EventWaitListInit
   \   00007C   083C         JMP     ??OSQCreate_3
    170                  } else {
    171                      pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
   \                     ??OSQCreate_4:
   \   00007E   0018E8460200 MOVX.A  @R6, 0x2(R8)
    172                      OSEventFreeList    = pevent;
   \   000084   76080000     MOVA    R8, 0(R6)
    173                      OS_EXIT_CRITICAL();
   \   000088   ........     CALLA   #OSCPURestoreSR
    174                      pevent = (OS_EVENT *)0;
   \   00008C   4843         MOVA    #0x0, R8
    175                  }
    176              }
    177              return (pevent);
   \                     ??OSQCreate_3:
   \   00008E   CC08         MOVA    R8, R12
   \                     ??OSQCreate_1:
   \   000090   5616         POPM.A  #0x6, R11
   \   000092   1001         RETA
    178          }
    179          /*$PAGE*/
    180          /*
    181          *********************************************************************************************************
    182          *                                        DELETE A MESSAGE QUEUE
    183          *
    184          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    185          *
    186          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    187          *                            queue.
    188          *
    189          *              opt           determines delete options as follows:
    190          *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
    191          *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
    192          *                                                    In this case, all the tasks pending will be readied.
    193          *
    194          *              perr          is a pointer to an error code that can contain one of the following values:
    195          *                            OS_ERR_NONE             The call was successful and the queue was deleted
    196          *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
    197          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    198          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
    199          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
    200          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    201          *
    202          * Returns    : pevent        upon error
    203          *              (OS_EVENT *)0 if the queue was successfully deleted.
    204          *
    205          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    206          *                 the queue MUST check the return code of OSQPend().
    207          *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
    208          *                 they check 'pevent' to see that it's a NULL pointer.
    209          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    210          *                 time is directly proportional to the number of tasks waiting on the queue.
    211          *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
    212          *                 applications where the queue is used for mutual exclusion because the resource(s)
    213          *                 will no longer be guarded by the queue.
    214          *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
    215          *                 type call) then your application MUST release the memory storage by call the counterpart
    216          *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
    217          *                 then, the storage can be reused.
    218          *********************************************************************************************************
    219          */
    220          
    221          #if OS_Q_DEL_EN > 0u

   \                                 In  segment CODE, align 2
   \                     ??Subroutine12_0:
   \   000000   6E42         MOV.B   #0x4, R14
   \   000002   4D43         MOVA    #0x0, R13
   \   000004   CC0B         MOVA    R11, R12
   \   000006   ........     BRA     #OS_EventTaskRdy

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #OSCPUSaveSR
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2
    222          OS_EVENT  *OSQDel (OS_EVENT  *pevent,
   \                     OSQDel:
    223                             INT8U      opt,
    224                             INT8U     *perr)
    225          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   464D         MOV.B   R13, R6
   \   000006   C80E         MOVA    R14, R8
    226              BOOLEAN    tasks_waiting;
    227              OS_EVENT  *pevent_return;
    228              OS_Q      *pq;
    229          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    230              OS_CPU_SR  cpu_sr = 0u;
    231          #endif
    232          
    233          
    234          
    235          #ifdef OS_SAFETY_CRITICAL
    236              if (perr == (INT8U *)0) {
    237                  OS_SAFETY_CRITICAL_EXCEPTION();
    238              }
    239          #endif
    240          
    241          #if OS_ARG_CHK_EN > 0u
    242              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    243                  *perr = OS_ERR_PEVENT_NULL;
    244                  return (pevent);
    245              }
    246          #endif
    247              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \   000008   EC930000     CMP.B   #0x2, 0(R12)
   \   00000C   0324         JEQ     ??OSQDel_3
    248                  *perr = OS_ERR_EVENT_TYPE;
   \   00000E   DE430000     MOV.B   #0x1, 0(R14)
    249                  return (pevent);
   \   000012   393C         JMP     ??OSQDel_1
    250              }
    251              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSQDel_3:
   \   000014   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00001A   0424         JEQ     ??OSQDel_4
    252                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00001C   FE400F000000 MOV.B   #0xf, 0(R14)
    253                  return (pevent);
   \   000022   313C         JMP     ??OSQDel_1
    254              }
    255              OS_ENTER_CRITICAL();
   \                     ??OSQDel_4:
   \   000024   ........     CALLA   #?Subroutine2
    256              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
   \                     ??CrossCallReturnLabel_6:
   \   000028   0220         JNE     ??OSQDel_5
   \   00002A   4943         MOV.B   #0x0, R9
   \   00002C   013C         JMP     ??OSQDel_6
   \                     ??OSQDel_5:
   \   00002E   5943         MOV.B   #0x1, R9
    257                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    258              } else {
    259                  tasks_waiting = OS_FALSE;                          /* No                                       */
    260              }
    261              switch (opt) {
   \                     ??OSQDel_6:
   \   000030   4683         SUB.B   #0x0, R6
   \   000032   0324         JEQ     ??OSQDel_7
   \   000034   5683         SUB.B   #0x1, R6
   \   000036   1124         JEQ     ??OSQDel_8
   \   000038   203C         JMP     ??OSQDel_9
    262                  case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
    263                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSQDel_7:
   \   00003A   59B3         BIT.B   #0x1, R9
   \   00003C   052C         JC      ??OSQDel_10
    264          #if OS_EVENT_NAME_EN > 0u
    265                           pevent->OSEventName    = (INT8U *)(void *)"?";
    266          #endif
    267                           pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
   \   00003E   ........     CALLA   #?Subroutine0
    268                           pq->OSQPtr             = OSQFreeList;
    269                           OSQFreeList            = pq;
    270                           pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
    271                           pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
    272                           pevent->OSEventCnt     = 0u;
    273                           OSEventFreeList        = pevent;          /* Get next free event control block        */
    274                           OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_0:
   \   000042   ........     CALLA   #OSCPURestoreSR
    275                           *perr                  = OS_ERR_NONE;
   \   000046   153C         JMP     ??OSQDel_2
    276                           pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
    277                       } else {
    278                           OS_EXIT_CRITICAL();
   \                     ??OSQDel_10:
   \   000048   ........     CALLA   #OSCPURestoreSR
    279                           *perr                  = OS_ERR_TASK_WAITING;
   \   00004C   F84049000000 MOV.B   #0x49, 0(R8)
    280                           pevent_return          = pevent;
   \   000052   183C         JMP     ??OSQDel_11
    281                       }
    282                       break;
    283          
    284                  case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
    285                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
    286                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQDel_0:
   \   000054   4F43         MOV.B   #0x0, R15
   \   000056   ........     CALLA   #??Subroutine12_0
    287                       }
   \                     ??OSQDel_8:
   \   00005A   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00005E   FA23         JNE     ??OSQDel_0
    288          #if OS_EVENT_NAME_EN > 0u
    289                       pevent->OSEventName    = (INT8U *)(void *)"?";
    290          #endif
    291                       pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
   \   000060   ........     CALLA   #?Subroutine0
    292                       pq->OSQPtr             = OSQFreeList;
    293                       OSQFreeList            = pq;
    294                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
    295                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
    296                       pevent->OSEventCnt     = 0u;
    297                       OSEventFreeList        = pevent;              /* Get next free event control block        */
    298                       OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_1:
   \   000064   0C4A         MOV.W   R10, R12
   \   000066   ........     CALLA   #OSCPURestoreSR
    299                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00006A   59B3         BIT.B   #0x1, R9
   \   00006C   0228         JNC     ??OSQDel_2
    300                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00006E   ........     CALLA   #OS_Sched
    301                       }
    302                       *perr                  = OS_ERR_NONE;
   \                     ??OSQDel_2:
   \   000072   C8430000     MOV.B   #0x0, 0(R8)
    303                       pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
   \   000076   4C43         MOVA    #0x0, R12
    304                       break;
   \   000078   063C         JMP     ??OSQDel_1
    305          
    306                  default:
    307                       OS_EXIT_CRITICAL();
   \                     ??OSQDel_9:
   \   00007A   ........     CALLA   #OSCPURestoreSR
    308                       *perr                  = OS_ERR_INVALID_OPT;
   \   00007E   F84007000000 MOV.B   #0x7, 0(R8)
    309                       pevent_return          = pevent;
   \                     ??OSQDel_11:
   \   000084   CC0B         MOVA    R11, R12
    310                       break;
    311              }
    312              return (pevent_return);
   \                     ??OSQDel_1:
   \   000086   5616         POPM.A  #0x6, R11
   \   000088   1001         RETA
    313          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   3F0B0200     MOVA    0x2(R11), R15
   \   000004   ....DF42.... MOVX.A  &OSQFreeList, 0(R15)
   \            0000        
   \   00000C   ........     MOVA    R15, &OSQFreeList
   \   000010   CB430000     MOV.B   #0x0, 0(R11)
   \   000014   ....DB42.... MOVX.A  &OSEventFreeList, 0x2(R11)
   \            0200        
   \   00001C   8B430600     MOV.W   #0x0, 0x6(R11)
   \   000020   ........     MOVA    R11, &OSEventFreeList
   \   000024   1001         RETA
    314          #endif
    315          
    316          /*$PAGE*/
    317          /*
    318          *********************************************************************************************************
    319          *                                             FLUSH QUEUE
    320          *
    321          * Description : This function is used to flush the contents of the message queue.
    322          *
    323          * Arguments   : none
    324          *
    325          * Returns     : OS_ERR_NONE         upon success
    326          *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
    327          *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    328          *
    329          * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
    330          *               the references to what the queue entries are pointing to and thus, you could cause
    331          *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
    332          *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
    333          *********************************************************************************************************
    334          */
    335          
    336          #if OS_Q_FLUSH_EN > 0u

   \                                 In  segment CODE, align 2
    337          INT8U  OSQFlush (OS_EVENT *pevent)
   \                     OSQFlush:
    338          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
    339              OS_Q      *pq;
    340          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    341              OS_CPU_SR  cpu_sr = 0u;
    342          #endif
    343          
    344          
    345          
    346          #if OS_ARG_CHK_EN > 0u
    347              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    348                  return (OS_ERR_PEVENT_NULL);
    349              }
    350              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    351                  return (OS_ERR_EVENT_TYPE);
    352              }
    353          #endif
    354              OS_ENTER_CRITICAL();
   \   000004   ........     CALLA   #OSCPUSaveSR
    355              pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
   \   000008   3F0A0200     MOVA    0x2(R10), R15
    356              pq->OSQIn      = pq->OSQStart;
   \   00000C   0018DF4F0400 MOVX.A  0x4(R15), 0xc(R15)
   \            0C00        
    357              pq->OSQOut     = pq->OSQStart;
   \   000014   ........     CALLA   #?Subroutine9
    358              pq->OSQEntries = 0u;
   \                     ??CrossCallReturnLabel_14:
   \   000018   8F431600     MOV.W   #0x0, 0x16(R15)
    359              OS_EXIT_CRITICAL();
   \   00001C   ........     CALLA   #OSCPURestoreSR
    360              return (OS_ERR_NONE);
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   0A16         POPM.A  #0x1, R10
   \   000024   1001         RETA
    361          }
    362          #endif
    363          
    364          /*$PAGE*/
    365          /*
    366          *********************************************************************************************************
    367          *                                     PEND ON A QUEUE FOR A MESSAGE
    368          *
    369          * Description: This function waits for a message to be sent to a queue
    370          *
    371          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    372          *
    373          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    374          *                            wait for a message to arrive at the queue up to the amount of time
    375          *                            specified by this argument.  If you specify 0, however, your task will wait
    376          *                            forever at the specified queue or, until a message arrives.
    377          *
    378          *              perr          is a pointer to where an error message will be deposited.  Possible error
    379          *                            messages are:
    380          *
    381          *                            OS_ERR_NONE         The call was successful and your task received a
    382          *                                                message.
    383          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    384          *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
    385          *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
    386          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    387          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    388          *                                                would lead to a suspension.
    389          *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
    390          *
    391          * Returns    : != (void *)0  is a pointer to the message received
    392          *              == (void *)0  if you received a NULL pointer message or,
    393          *                            if no message was received or,
    394          *                            if 'pevent' is a NULL pointer or,
    395          *                            if you didn't pass a pointer to a queue.
    396          *
    397          * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
    398          *********************************************************************************************************
    399          */
    400          

   \                                 In  segment CODE, align 2
   \                     ??Subroutine11_0:
   \   000000   ........     CALLA   #OSCPURestoreSR
   \   000004   ........     BRA     #OS_Sched

   \                                 In  segment CODE, align 2
    401          void  *OSQPend (OS_EVENT  *pevent,
   \                     OSQPend:
    402                          INT32U     timeout,
    403                          INT8U     *perr)
    404          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C90C         MOVA    R12, R9
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
   \   000008   C60D         MOVA    R13, R6
    405              void      *pmsg;
    406              OS_Q      *pq;
    407          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    408              OS_CPU_SR  cpu_sr = 0u;
    409          #endif
    410          
    411          
    412          
    413          #ifdef OS_SAFETY_CRITICAL
    414              if (perr == (INT8U *)0) {
    415                  OS_SAFETY_CRITICAL_EXCEPTION();
    416              }
    417          #endif
    418          
    419          #if OS_ARG_CHK_EN > 0u
    420              if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
    421                  *perr = OS_ERR_PEVENT_NULL;
    422                  return ((void *)0);
    423              }
    424          #endif
    425              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
   \   00000A   EC930000     CMP.B   #0x2, 0(R12)
   \   00000E   0324         JEQ     ??OSQPend_1
    426                  *perr = OS_ERR_EVENT_TYPE;
   \   000010   DD430000     MOV.B   #0x1, 0(R13)
    427                  return ((void *)0);
   \   000014   0E3C         JMP     ??OSQPend_0
    428              }
    429              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \                     ??OSQPend_1:
   \   000016   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00001C   0324         JEQ     ??OSQPend_2
    430                  *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
   \   00001E   ED430000     MOV.B   #0x2, 0(R13)
    431                  return ((void *)0);
   \   000022   073C         JMP     ??OSQPend_0
    432              }
    433              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
   \                     ??OSQPend_2:
   \   000024   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   00002A   0524         JEQ     ??OSQPend_3
    434                  *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
   \   00002C   FD400D000000 MOV.B   #0xd, 0(R13)
    435                  return ((void *)0);
   \                     ??OSQPend_0:
   \   000032   4C43         MOVA    #0x0, R12
   \   000034   583C         JMP     ??OSQPend_4
    436              }
    437              OS_ENTER_CRITICAL();
   \                     ??OSQPend_3:
   \   000036   ........     CALLA   #OSCPUSaveSR
   \   00003A   084C         MOV.W   R12, R8
    438              pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
   \   00003C   3F090200     MOVA    0x2(R9), R15
    439              if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
   \   000040   8F931600     CMP.W   #0x0, 0x16(R15)
   \   000044   0F24         JEQ     ??OSQPend_5
    440                  pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
   \   000046   ........     CALLA   #?Subroutine8
    441                  pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    442                  if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
   \                     ??CrossCallReturnLabel_12:
   \   00004A   370F1000     MOVA    0x10(R15), R7
   \   00004E   3E0F0800     MOVA    0x8(R15), R14
   \   000052   D70E         CMPA    R14, R7
   \   000054   0220         JNE     ??OSQPend_6
    443                      pq->OSQOut = pq->OSQStart;
   \   000056   ........     CALLA   #?Subroutine9
    444                  }
    445                  OS_EXIT_CRITICAL();
   \                     ??OSQPend_6:
   \   00005A   ........     CALLA   #OSCPURestoreSR
    446                  *perr = OS_ERR_NONE;
   \   00005E   C6430000     MOV.B   #0x0, 0(R6)
    447                  return (pmsg);                           /* Return message received                            */
   \   000062   403C         JMP     ??OSQPend_7
    448              }
    449              OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
   \                     ??OSQPend_5:
   \   000064   ........     MOVA    #OSTCBCur, R7
   \   000068   0F07         MOVA    @R7, R15
   \   00006A   EFD22E00     BIS.B   #0x4, 0x2e(R15)
    450              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00006E   0F07         MOVA    @R7, R15
   \   000070   CF432F00     MOV.B   #0x0, 0x2f(R15)
    451              OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
   \   000074   0F07         MOVA    @R7, R15
   \   000076   8F4A2A00     MOV.W   R10, 0x2a(R15)
   \   00007A   8F4B2C00     MOV.W   R11, 0x2c(R15)
    452              OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
   \   00007E   CC09         MOVA    R9, R12
   \   000080   ........     CALLA   #OS_EventTaskWait
    453              OS_EXIT_CRITICAL();
   \   000084   0C48         MOV.W   R8, R12
   \   000086   ........     CALLA   #??Subroutine11_0
    454              OS_Sched();                                  /* Find next highest priority task ready to run       */
    455              OS_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_15:
   \   00008A   ........     CALLA   #OSCPUSaveSR
   \   00008E   084C         MOV.W   R12, R8
    456              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   000090   0F07         MOVA    @R7, R15
   \   000092   5E4F2F00     MOV.B   0x2f(R15), R14
   \   000096   4E83         SUB.B   #0x0, R14
   \   000098   0324         JEQ     ??OSQPend_8
   \   00009A   6E83         SUB.B   #0x2, R14
   \   00009C   0624         JEQ     ??OSQPend_9
   \   00009E   0A3C         JMP     ??OSQPend_10
    457                  case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
    458                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSQPend_8:
   \   0000A0   3B0F2000     MOVA    0x20(R15), R11
    459                      *perr =  OS_ERR_NONE;
   \   0000A4   C6430000     MOV.B   #0x0, 0(R6)
    460                       break;
   \   0000A8   0D3C         JMP     ??OSQPend_11
    461          
    462                  case OS_STAT_PEND_ABORT:
    463                       pmsg = (void *)0;
   \                     ??OSQPend_9:
   \   0000AA   4B43         MOVA    #0x0, R11
    464                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \   0000AC   F6400E000000 MOV.B   #0xe, 0(R6)
    465                       break;
   \   0000B2   083C         JMP     ??OSQPend_11
    466          
    467                  case OS_STAT_PEND_TO:
    468                  default:
    469                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSQPend_10:
   \   0000B4   CD09         MOVA    R9, R13
   \   0000B6   0C07         MOVA    @R7, R12
   \   0000B8   ........     CALLA   #OS_EventTaskRemove
    470                       pmsg = (void *)0;
   \   0000BC   4B43         MOVA    #0x0, R11
    471                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   0000BE   F6400A000000 MOV.B   #0xa, 0(R6)
    472                       break;
    473              }
    474              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSQPend_11:
   \   0000C4   0F07         MOVA    @R7, R15
   \   0000C6   CF432E00     MOV.B   #0x0, 0x2e(R15)
    475              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   0000CA   0F07         MOVA    @R7, R15
   \   0000CC   CF432F00     MOV.B   #0x0, 0x2f(R15)
    476              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   0000D0   0F07         MOVA    @R7, R15
   \   0000D2   0018CF431C00 MOVX.A  #0x0, 0x1c(R15)
    477          #if (OS_EVENT_MULTI_EN > 0u)
    478              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    479          #endif
    480              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   0000D8   0018CF432000 MOVX.A  #0x0, 0x20(R15)
    481              OS_EXIT_CRITICAL();
   \   0000DE   0C48         MOV.W   R8, R12
   \   0000E0   ........     CALLA   #OSCPURestoreSR
    482              return (pmsg);                                    /* Return received message                       */
   \                     ??OSQPend_7:
   \   0000E4   CC0B         MOVA    R11, R12
   \                     ??OSQPend_4:
   \   0000E6   5616         POPM.A  #0x6, R11
   \   0000E8   1001         RETA
    483          }
    484          /*$PAGE*/
    485          /*
    486          *********************************************************************************************************
    487          *                                      ABORT WAITING ON A MESSAGE QUEUE
    488          *
    489          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
    490          *              should be used to fault-abort the wait on the queue, rather than to normally signal
    491          *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
    492          *
    493          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
    494          *
    495          *              opt           determines the type of ABORT performed:
    496          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    497          *                                                     queue
    498          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    499          *                                                     queue
    500          *
    501          *              perr          is a pointer to where an error message will be deposited.  Possible error
    502          *                            messages are:
    503          *
    504          *                            OS_ERR_NONE         No tasks were     waiting on the queue.
    505          *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
    506          *                                                and informed of the aborted wait; check return value
    507          *                                                for the number of tasks whose wait on the queue
    508          *                                                was aborted.
    509          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
    510          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    511          *
    512          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    513          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    514          *********************************************************************************************************
    515          */
    516          
    517          #if OS_Q_PEND_ABORT_EN > 0u

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   6F43         MOV.B   #0x2, R15
   \   000002                REQUIRE ??Subroutine12_0
   \   000002                // Fall through to label ??Subroutine12_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   0C4A         MOV.W   R10, R12
   \   000002                REQUIRE ??Subroutine11_0
   \   000002                // Fall through to label ??Subroutine11_0

   \                                 In  segment CODE, align 2
    518          INT8U  OSQPendAbort (OS_EVENT  *pevent,
   \                     OSQPendAbort:
    519                               INT8U      opt,
    520                               INT8U     *perr)
    521          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   464D         MOV.B   R13, R6
   \   000006   C80E         MOVA    R14, R8
    522              INT8U      nbr_tasks;
    523          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    524              OS_CPU_SR  cpu_sr = 0u;
    525          #endif
    526          
    527          
    528          
    529          #ifdef OS_SAFETY_CRITICAL
    530              if (perr == (INT8U *)0) {
    531                  OS_SAFETY_CRITICAL_EXCEPTION();
    532              }
    533          #endif
    534          
    535          #if OS_ARG_CHK_EN > 0u
    536              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    537                  *perr = OS_ERR_PEVENT_NULL;
    538                  return (0u);
    539              }
    540          #endif
    541              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
   \   000008   EC930000     CMP.B   #0x2, 0(R12)
   \   00000C   0324         JEQ     ??OSQPendAbort_1
    542                  *perr = OS_ERR_EVENT_TYPE;
   \   00000E   DE430000     MOV.B   #0x1, 0(R14)
    543                  return (0u);
   \   000012   1B3C         JMP     ??OSQPendAbort_2
    544              }
    545              OS_ENTER_CRITICAL();
   \                     ??OSQPendAbort_1:
   \   000014   ........     CALLA   #?Subroutine2
    546              if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
   \                     ??CrossCallReturnLabel_5:
   \   000018   1424         JEQ     ??OSQPendAbort_3
    547                  nbr_tasks = 0u;
   \   00001A   4943         MOV.B   #0x0, R9
    548                  switch (opt) {
   \   00001C   5693         CMP.B   #0x1, R6
   \   00001E   0720         JNE     ??OSQPendAbort_4
    549                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    550                           while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
    551                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \                     ??OSQPendAbort_0:
   \   000020   ........     CALLA   #?Subroutine4
    552                               nbr_tasks++;
   \                     ??CrossCallReturnLabel_20:
   \   000024   5953         ADD.B   #0x1, R9
    553                           }
   \   000026   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00002A   0424         JEQ     ??OSQPendAbort_5
   \   00002C   F93F         JMP     ??OSQPendAbort_0
    554                           break;
    555          
    556                      case OS_PEND_OPT_NONE:
    557                      default:                                       /* No,  ready HPT       waiting on queue    */
    558                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
   \                     ??OSQPendAbort_4:
   \   00002E   ........     CALLA   #?Subroutine4
    559                           nbr_tasks++;
   \                     ??CrossCallReturnLabel_19:
   \   000032   5943         MOV.B   #0x1, R9
    560                           break;
    561                  }
    562                  OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_5:
   \   000034   ........     CALLA   #??Subroutine10_0
    563                  OS_Sched();                                        /* Find HPT ready to run                    */
    564                  *perr = OS_ERR_PEND_ABORT;
   \                     ??CrossCallReturnLabel_16:
   \   000038   F8400E000000 MOV.B   #0xe, 0(R8)
    565                  return (nbr_tasks);
   \   00003E   4C49         MOV.B   R9, R12
   \   000040   053C         JMP     ??OSQPendAbort_6
    566              }
    567              OS_EXIT_CRITICAL();
   \                     ??OSQPendAbort_3:
   \   000042   ........     CALLA   #OSCPURestoreSR
    568              *perr = OS_ERR_NONE;
   \   000046   C8430000     MOV.B   #0x0, 0(R8)
    569              return (0u);                                           /* No tasks waiting on queue                */
   \                     ??OSQPendAbort_2:
   \   00004A   4C43         MOV.B   #0x0, R12
   \                     ??OSQPendAbort_6:
   \   00004C   5616         POPM.A  #0x6, R11
   \   00004E   1001         RETA
    570          }
    571          #endif
    572          
    573          /*$PAGE*/
    574          /*
    575          *********************************************************************************************************
    576          *                                        POST MESSAGE TO A QUEUE
    577          *
    578          * Description: This function sends a message to a queue
    579          *
    580          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    581          *
    582          *              pmsg          is a pointer to the message to send.
    583          *
    584          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    585          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    586          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    587          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    588          *
    589          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    590          *********************************************************************************************************
    591          */
    592          
    593          #if OS_Q_POST_EN > 0u

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   ........     CALLA   #OS_EventTaskRdy
   \   000004                REQUIRE ??Subroutine10_0
   \   000004                // Fall through to label ??Subroutine10_0

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   ........     CALLA   #OSCPURestoreSR
   \   000004   7C401E00     MOV.B   #0x1e, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    594          INT8U  OSQPost (OS_EVENT  *pevent,
   \                     OSQPost:
    595                          void      *pmsg)
    596          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   C80D         MOVA    R13, R8
    597              OS_Q      *pq;
    598          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    599              OS_CPU_SR  cpu_sr = 0u;
    600          #endif
    601          
    602          
    603          
    604          #if OS_ARG_CHK_EN > 0u
    605              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    606                  return (OS_ERR_PEVENT_NULL);
    607              }
    608          #endif
    609              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \   000006   EC930000     CMP.B   #0x2, 0(R12)
   \   00000A   0224         JEQ     ??OSQPost_2
    610                  return (OS_ERR_EVENT_TYPE);
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   213C         JMP     ??OSQPost_3
    611              }
    612              OS_ENTER_CRITICAL();
   \                     ??OSQPost_2:
   \   000010   ........     CALLA   #?Subroutine2
    613              if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
   \                     ??CrossCallReturnLabel_4:
   \   000014   0724         JEQ     ??OSQPost_4
    614                                                                 /* Ready highest priority task waiting on event */
    615                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   000016   4F43         MOV.B   #0x0, R15
   \   000018   6E42         MOV.B   #0x4, R14
   \   00001A   CD08         MOVA    R8, R13
   \   00001C   CC0B         MOVA    R11, R12
   \   00001E   ........     CALLA   #?Subroutine3
    616                  OS_EXIT_CRITICAL();
    617                  OS_Sched();                                    /* Find highest priority task ready to run      */
    618                  return (OS_ERR_NONE);
   \                     ??CrossCallReturnLabel_17:
   \   000022   163C         JMP     ??OSQPost_5
    619              }
    620              pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
   \                     ??OSQPost_4:
   \   000024   3F0B0200     MOVA    0x2(R11), R15
    621              if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
   \   000028   9F9F14001600 CMP.W   0x14(R15), 0x16(R15)
   \   00002E   0328         JNC     ??OSQPost_6
    622                  OS_EXIT_CRITICAL();
   \   000030   ........     CALLA   #?Subroutine6
    623                  return (OS_ERR_Q_FULL);
    624              }
   \                     ??CrossCallReturnLabel_10:
   \   000034   0E3C         JMP     ??OSQPost_3
    625              *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
   \                     ??OSQPost_6:
   \   000036   3B0F0C00     MOVA    0xc(R15), R11
   \   00003A   7B080000     MOVA    R8, 0(R11)
   \   00003E   0018EF520C00 ADDX.A  #0x4, 0xc(R15)
    626              pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
   \   000044   9F531600     ADD.W   #0x1, 0x16(R15)
    627              if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
   \   000048   ........     CALLA   #?Subroutine7
    628                  pq->OSQIn = pq->OSQStart;
    629              }
    630              OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_11:
   \   00004C   ........     CALLA   #OSCPURestoreSR
    631              return (OS_ERR_NONE);
   \                     ??OSQPost_5:
   \   000050   4C43         MOV.B   #0x0, R12
   \                     ??OSQPost_3:
   \   000052   3816         POPM.A  #0x4, R11
   \   000054   1001         RETA
    632          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine7:
   \   000000   3B0F0C00     MOVA    0xc(R15), R11
   \   000004   3E0F0800     MOVA    0x8(R15), R14
   \   000008   DB0E         CMPA    R14, R11
   \   00000A   0420         JNE     ??OSQPostOpt_5
   \   00000C   0018DF4F0400 MOVX.A  0x4(R15), 0xc(R15)
   \            0C00        
   \                     ??OSQPostOpt_5:
   \   000014   1001         RETA
    633          #endif
    634          /*$PAGE*/
    635          /*
    636          *********************************************************************************************************
    637          *                                   POST MESSAGE TO THE FRONT OF A QUEUE
    638          *
    639          * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
    640          *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
    641          *              'priority' messages.
    642          *
    643          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    644          *
    645          *              pmsg          is a pointer to the message to send.
    646          *
    647          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    648          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    649          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    650          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    651          *
    652          * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
    653          *********************************************************************************************************
    654          */
    655          
    656          #if OS_Q_POST_FRONT_EN > 0u

   \                                 In  segment CODE, align 2
    657          INT8U  OSQPostFront (OS_EVENT  *pevent,
   \                     OSQPostFront:
    658                               void      *pmsg)
    659          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   CB0D         MOVA    R13, R11
    660              OS_Q      *pq;
    661          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    662              OS_CPU_SR  cpu_sr = 0u;
    663          #endif
    664          
    665          
    666          
    667          #if OS_ARG_CHK_EN > 0u
    668              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    669                  return (OS_ERR_PEVENT_NULL);
    670              }
    671          #endif
    672              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \   000006   EC930000     CMP.B   #0x2, 0(R12)
   \   00000A   0224         JEQ     ??OSQPostFront_1
    673                  return (OS_ERR_EVENT_TYPE);
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   1D3C         JMP     ??OSQPostFront_2
    674              }
    675              OS_ENTER_CRITICAL();
   \                     ??OSQPostFront_1:
   \   000010   ........     CALLA   #OSCPUSaveSR
   \   000014   0A4C         MOV.W   R12, R10
    676              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
   \   000016   C8930800     CMP.B   #0x0, 0x8(R8)
   \   00001A   0724         JEQ     ??OSQPostFront_3
    677                                                                /* Ready highest priority task waiting on event  */
    678                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \   00001C   4F43         MOV.B   #0x0, R15
   \   00001E   6E42         MOV.B   #0x4, R14
   \   000020   CD0B         MOVA    R11, R13
   \   000022   CC08         MOVA    R8, R12
   \   000024   ........     CALLA   #?Subroutine3
    679                  OS_EXIT_CRITICAL();
    680                  OS_Sched();                                   /* Find highest priority task ready to run       */
    681                  return (OS_ERR_NONE);
   \                     ??CrossCallReturnLabel_18:
   \   000028   0F3C         JMP     ??OSQPostFront_4
    682              }
    683              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostFront_3:
   \   00002A   3F080200     MOVA    0x2(R8), R15
    684              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   00002E   9F9F14001600 CMP.W   0x14(R15), 0x16(R15)
   \   000034   0328         JNC     ??OSQPostFront_5
    685                  OS_EXIT_CRITICAL();
   \   000036   ........     CALLA   #?Subroutine6
    686                  return (OS_ERR_Q_FULL);
    687              }
   \                     ??CrossCallReturnLabel_9:
   \   00003A   073C         JMP     ??OSQPostFront_2
    688              if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
   \                     ??OSQPostFront_5:
   \   00003C   ........     CALLA   #?Subroutine1
    689                  pq->OSQOut = pq->OSQEnd;
    690              }
    691              pq->OSQOut--;
    692              *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
    693              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \                     ??CrossCallReturnLabel_3:
   \   000040   9F531600     ADD.W   #0x1, 0x16(R15)
    694              OS_EXIT_CRITICAL();
   \   000044   ........     CALLA   #OSCPURestoreSR
    695              return (OS_ERR_NONE);
   \                     ??OSQPostFront_4:
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??OSQPostFront_2:
   \   00004A   3816         POPM.A  #0x4, R11
   \   00004C   1001         RETA
    696          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   3E0F1000     MOVA    0x10(R15), R14
   \   000004   3D0F0400     MOVA    0x4(R15), R13
   \   000008   DE0D         CMPA    R13, R14
   \   00000A   0420         JNE     ??OSQPostOpt_3
   \   00000C   0018DF4F0800 MOVX.A  0x8(R15), 0x10(R15)
   \            1000        
   \                     ??OSQPostOpt_3:
   \   000014   0018EF821000 SUBX.A  #0x4, 0x10(R15)
   \   00001A   3E0F1000     MOVA    0x10(R15), R14
   \   00001E   7E0B0000     MOVA    R11, 0(R14)
   \   000022   1001         RETA
    697          #endif
    698          /*$PAGE*/
    699          /*
    700          *********************************************************************************************************
    701          *                                        POST MESSAGE TO A QUEUE
    702          *
    703          * Description: This function sends a message to a queue.  This call has been added to reduce code size
    704          *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
    705          *              capability to broadcast a message to ALL tasks waiting on the message queue.
    706          *
    707          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    708          *
    709          *              pmsg          is a pointer to the message to send.
    710          *
    711          *              opt           determines the type of POST performed:
    712          *                            OS_POST_OPT_NONE         POST to a single waiting task
    713          *                                                     (Identical to OSQPost())
    714          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
    715          *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
    716          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    717          *
    718          * Returns    : OS_ERR_NONE           The call was successful and the message was sent
    719          *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
    720          *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
    721          *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
    722          *
    723          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    724          *              interrupt disable time is proportional to the number of tasks waiting on the queue.
    725          *********************************************************************************************************
    726          */
    727          
    728          #if OS_Q_POST_OPT_EN > 0u

   \                                 In  segment CODE, align 2
    729          INT8U  OSQPostOpt (OS_EVENT  *pevent,
   \                     OSQPostOpt:
    730                             void      *pmsg,
    731                             INT8U      opt)
    732          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   C90C         MOVA    R12, R9
   \   000004   CB0D         MOVA    R13, R11
   \   000006   484E         MOV.B   R14, R8
    733              OS_Q      *pq;
    734          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    735              OS_CPU_SR  cpu_sr = 0u;
    736          #endif
    737          
    738          
    739          
    740          #if OS_ARG_CHK_EN > 0u
    741              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    742                  return (OS_ERR_PEVENT_NULL);
    743              }
    744          #endif
    745              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
   \   000008   EC930000     CMP.B   #0x2, 0(R12)
   \   00000C   0224         JEQ     ??OSQPostOpt_6
    746                  return (OS_ERR_EVENT_TYPE);
   \   00000E   5C43         MOV.B   #0x1, R12
   \   000010   343C         JMP     ??OSQPostOpt_7
    747              }
    748              OS_ENTER_CRITICAL();
   \                     ??OSQPostOpt_6:
   \   000012   ........     CALLA   #OSCPUSaveSR
   \   000016   0A4C         MOV.W   R12, R10
    749              if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
   \   000018   C9930800     CMP.B   #0x0, 0x8(R9)
   \   00001C   1224         JEQ     ??OSQPostOpt_8
    750                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
   \   00001E   58B3         BIT.B   #0x1, R8
   \   000020   0628         JNC     ??OSQPostOpt_9
    751                      while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
    752                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQPostOpt_0:
   \   000022   ........     CALLA   #?Subroutine5
    753                      }
   \                     ??CrossCallReturnLabel_7:
   \   000026   C9930800     CMP.B   #0x0, 0x8(R9)
   \   00002A   0324         JEQ     ??OSQPostOpt_10
   \   00002C   FA3F         JMP     ??OSQPostOpt_0
    754                  } else {                                      /* No,  Post to HPT waiting on queue             */
    755                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
   \                     ??OSQPostOpt_9:
   \   00002E   ........     CALLA   #?Subroutine5
    756                  }
    757                  OS_EXIT_CRITICAL();
   \                     ??OSQPostOpt_10:
   \   000032   0C4A         MOV.W   R10, R12
   \   000034   ........     CALLA   #OSCPURestoreSR
    758                  if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {	  /* See if scheduler needs to be invoked          */
   \   000038   68B2         BIT.B   #0x4, R8
   \   00003A   1E2C         JC      ??OSQPostOpt_2
    759                      OS_Sched();                               /* Find highest priority task ready to run       */
   \   00003C   ........     CALLA   #OS_Sched
    760                  }
    761                  return (OS_ERR_NONE);
   \   000040   1B3C         JMP     ??OSQPostOpt_2
    762              }
    763              pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
   \                     ??OSQPostOpt_8:
   \   000042   3F090200     MOVA    0x2(R9), R15
    764              if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
   \   000046   9F9F14001600 CMP.W   0x14(R15), 0x16(R15)
   \   00004C   0328         JNC     ??OSQPostOpt_11
    765                  OS_EXIT_CRITICAL();
   \   00004E   ........     CALLA   #?Subroutine6
    766                  return (OS_ERR_Q_FULL);
    767              }
   \                     ??CrossCallReturnLabel_8:
   \   000052   133C         JMP     ??OSQPostOpt_7
    768              if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
   \                     ??OSQPostOpt_11:
   \   000054   68B3         BIT.B   #0x2, R8
   \   000056   0328         JNC     ??OSQPostOpt_12
    769                  if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
   \   000058   ........     CALLA   #?Subroutine1
    770                      pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
    771                  }
    772                  pq->OSQOut--;
    773                  *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
    774              } else {                                          /* No,  Post as FIFO                             */
   \                     ??CrossCallReturnLabel_2:
   \   00005C   093C         JMP     ??OSQPostOpt_4
    775                  *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
   \                     ??OSQPostOpt_12:
   \   00005E   3E0F0C00     MOVA    0xc(R15), R14
   \   000062   7E0B0000     MOVA    R11, 0(R14)
   \   000066   0018EF520C00 ADDX.A  #0x4, 0xc(R15)
    776                  if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
   \   00006C   ........     CALLA   #?Subroutine7
    777                      pq->OSQIn = pq->OSQStart;
    778                  }
    779              }
    780              pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
   \                     ??OSQPostOpt_4:
   \   000070   9F531600     ADD.W   #0x1, 0x16(R15)
    781              OS_EXIT_CRITICAL();
   \   000074   ........     CALLA   #OSCPURestoreSR
    782              return (OS_ERR_NONE);
   \                     ??OSQPostOpt_2:
   \   000078   4C43         MOV.B   #0x0, R12
   \                     ??OSQPostOpt_7:
   \   00007A   3816         POPM.A  #0x4, R11
   \   00007C   1001         RETA
    783          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   6E42         MOV.B   #0x4, R14
   \   000004   CD0B         MOVA    R11, R13
   \   000006   CC09         MOVA    R9, R12
   \   000008   ........     BRA     #OS_EventTaskRdy
    784          #endif
    785          /*$PAGE*/
    786          /*
    787          *********************************************************************************************************
    788          *                                        QUERY A MESSAGE QUEUE
    789          *
    790          * Description: This function obtains information about a message queue.
    791          *
    792          * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
    793          *
    794          *              p_q_data      is a pointer to a structure that will contain information about the message
    795          *                            queue.
    796          *
    797          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    798          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
    799          *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
    800          *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
    801          *********************************************************************************************************
    802          */
    803          
    804          #if OS_Q_QUERY_EN > 0u

   \                                 In  segment CODE, align 2
    805          INT8U  OSQQuery (OS_EVENT  *pevent,
   \                     OSQQuery:
    806                           OS_Q_DATA *p_q_data)
    807          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   CA0D         MOVA    R13, R10
    808              OS_Q       *pq;
    809              INT8U       i;
    810              OS_PRIO    *psrc;
    811              OS_PRIO    *pdest;
    812          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    813              OS_CPU_SR   cpu_sr = 0u;
    814          #endif
    815          
    816          
    817          
    818          #if OS_ARG_CHK_EN > 0u
    819              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    820                  return (OS_ERR_PEVENT_NULL);
    821              }
    822              if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
    823                  return (OS_ERR_PDATA_NULL);
    824              }
    825          #endif
    826              if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
   \   000006   EC930000     CMP.B   #0x2, 0(R12)
   \   00000A   0224         JEQ     ??OSQQuery_1
    827                  return (OS_ERR_EVENT_TYPE);
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   2B3C         JMP     ??OSQQuery_2
    828              }
    829              OS_ENTER_CRITICAL();
   \                     ??OSQQuery_1:
   \   000010   ........     CALLA   #OSCPUSaveSR
    830              p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
   \   000014   DA4B08001000 MOV.B   0x8(R11), 0x10(R10)
    831              psrc                 = &pevent->OSEventTbl[0];
   \   00001A   CF0B         MOVA    R11, R15
   \   00001C   AF000900     ADDA    #0x9, R15
    832              pdest                = &p_q_data->OSEventTbl[0];
   \   000020   CE0A         MOVA    R10, R14
   \   000022   AE000800     ADDA    #0x8, R14
    833              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   000026   6D42         MOV.B   #0x4, R13
    834                  *pdest++ = *psrc++;
   \                     ??OSQQuery_0:
   \   000028   FE4F0000     MOV.B   @R15+, 0(R14)
   \   00002C   AE000100     ADDA    #0x1, R14
   \   000030   FE4F0000     MOV.B   @R15+, 0(R14)
   \   000034   AE000100     ADDA    #0x1, R14
    835              }
   \   000038   7D53         ADD.B   #0xff, R13
   \   00003A   F623         JNE     ??OSQQuery_0
    836              pq = (OS_Q *)pevent->OSEventPtr;
   \   00003C   3F0B0200     MOVA    0x2(R11), R15
    837              if (pq->OSQEntries > 0u) {
   \   000040   1B4F1600     MOV.W   0x16(R15), R11
   \   000044   0B93         CMP.W   #0x0, R11
   \   000046   0424         JEQ     ??OSQQuery_3
    838                  p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
   \   000048   3E0F1000     MOVA    0x10(R15), R14
   \   00004C   0E0E         MOVA    @R14, R14
   \   00004E   013C         JMP     ??OSQQuery_4
    839              } else {
    840                  p_q_data->OSMsg = (void *)0;
   \                     ??OSQQuery_3:
   \   000050   4E43         MOVA    #0x0, R14
   \                     ??OSQQuery_4:
   \   000052   7A0E0000     MOVA    R14, 0(R10)
    841              }
    842              p_q_data->OSNMsgs = pq->OSQEntries;
   \   000056   8A4B0400     MOV.W   R11, 0x4(R10)
    843              p_q_data->OSQSize = pq->OSQSize;
   \   00005A   9A4F14000600 MOV.W   0x14(R15), 0x6(R10)
    844              OS_EXIT_CRITICAL();
   \   000060   ........     CALLA   #OSCPURestoreSR
    845              return (OS_ERR_NONE);
   \   000064   4C43         MOV.B   #0x0, R12
   \                     ??OSQQuery_2:
   \   000066   1A16         POPM.A  #0x2, R11
   \   000068   1001         RETA
    846          }
    847          #endif                                                 /* OS_Q_QUERY_EN                                */
    848          
    849          /*$PAGE*/
    850          /*
    851          *********************************************************************************************************
    852          *                                      QUEUE MODULE INITIALIZATION
    853          *
    854          * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
    855          *               application MUST NOT call this function.
    856          *
    857          * Arguments   :  none
    858          *
    859          * Returns     : none
    860          *
    861          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    862          *********************************************************************************************************
    863          */
    864          

   \                                 In  segment CODE, align 2
    865          void  OS_QInit (void)
   \                     OS_QInit:
    866          {
   \   000000   0A14         PUSHM.A #0x1, R10
    867          #if OS_MAX_QS == 1u
    868              OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
    869              OSQFreeList->OSQPtr = (OS_Q *)0;
    870          #endif
    871          
    872          #if OS_MAX_QS >= 2u
    873              INT16U   ix;
    874              INT16U   ix_next;
    875              OS_Q    *pq1;
    876              OS_Q    *pq2;
    877          
    878          
    879          
    880              OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
   \   000002   ........     MOVA    #OSQTbl, R10
   \   000006   3D407800     MOV.W   #0x78, R13
   \   00000A   CC0A         MOVA    R10, R12
   \   00000C   ........     CALLA   #OS_MemClr
    881              for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
    882                  ix_next = ix + 1u;
    883                  pq1 = &OSQTbl[ix];
    884                  pq2 = &OSQTbl[ix_next];
    885                  pq1->OSQPtr = pq2;
   \   000010   ....FA40.... MOVX.A  #OSQTbl + 24, 0(R10)
   \            0000        
   \   000018   ....FA40.... MOVX.A  #OSQTbl + 48, 0x18(R10)
   \            1800        
   \   000020   ....FA40.... MOVX.A  #OSQTbl + 72, 0x30(R10)
   \            3000        
   \   000028   ....FA40.... MOVX.A  #OSQTbl + 96, 0x48(R10)
   \            4800        
    886              }
    887              pq1         = &OSQTbl[ix];
    888              pq1->OSQPtr = (OS_Q *)0;
   \   000030   0018CA436000 MOVX.A  #0x0, 0x60(R10)
    889              OSQFreeList = &OSQTbl[0];
   \   000036   ........     MOVA    R10, &OSQFreeList
    890          #endif
    891          }
   \   00003A   0A16         POPM.A  #0x1, R10
   \   00003C   1001         RETA
    892          #endif                                               /* OS_Q_EN                                        */
    893          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      12  OSQAccept
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
      28  OSQCreate
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventWaitListInit
      28  OSQDel
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventTaskRdy
            28 -> OS_Sched
       8  OSQFlush
             8 -> OSCPURestoreSR
             8 -> OSCPUSaveSR
      28  OSQPend
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventTaskRemove
            28 -> OS_EventTaskWait
            28 -> OS_Sched
      28  OSQPendAbort
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventTaskRdy
            28 -> OS_Sched
      20  OSQPost
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      20  OSQPostFront
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      20  OSQPostOpt
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      12  OSQQuery
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
       8  OS_QInit
             8 -> OS_MemClr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??Subroutine10_0
       8  ??Subroutine11_0
      10  ??Subroutine12_0
      38  ?Subroutine0
      36  ?Subroutine1
      12  ?Subroutine2
       4  ?Subroutine3
       2  ?Subroutine4
      12  ?Subroutine5
      10  ?Subroutine6
      22  ?Subroutine7
      18  ?Subroutine8
      10  ?Subroutine9
      78  OSQAccept
     148  OSQCreate
     138  OSQDel
      38  OSQFlush
     234  OSQPend
      80  OSQPendAbort
      86  OSQPost
      78  OSQPostFront
     126  OSQPostOpt
     106  OSQQuery
      62  OS_QInit

 
 1 358 bytes in segment CODE
 
 1 358 bytes of CODE memory

Errors: none
Warnings: 11
