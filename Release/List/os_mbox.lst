###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:30 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mbox.c                        #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_mbox.c -D NDEBUG -D           #
#                     RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿ #
#                     âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_mbox.lst                         #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_mbox.r43                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_mbox.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                       MESSAGE MAILBOX MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MBOX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include "ucos_ii.h"

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          #endif
     27          
     28          #if OS_MBOX_EN > 0u
     29          /*
     30          *********************************************************************************************************
     31          *                                     ACCEPT MESSAGE FROM MAILBOX
     32          *
     33          * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
     34          *              OSMboxAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
     39          *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
     40          *              == (void *)0  if the mailbox is empty or,
     41          *                            if 'pevent' is a NULL pointer or,
     42          *                            if you didn't pass the proper event pointer.
     43          *********************************************************************************************************
     44          */
     45          
     46          #if OS_MBOX_ACCEPT_EN > 0u

   \                                 In  segment CODE, align 2
     47          void  *OSMboxAccept (OS_EVENT *pevent)
   \                     OSMboxAccept:
     48          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
     49              void      *pmsg;
     50          #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
     51              OS_CPU_SR  cpu_sr = 0u;
     52          #endif
     53          
     54          
     55          
     56          #if OS_ARG_CHK_EN > 0u
     57              if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
     58                  return ((void *)0);
     59              }
     60          #endif
     61              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
   \   000004   DC930000     CMP.B   #0x1, 0(R12)
   \   000008   0224         JEQ     ??OSMboxAccept_0
     62                  return ((void *)0);
   \   00000A   4C43         MOVA    #0x0, R12
   \   00000C   0A3C         JMP     ??OSMboxAccept_1
     63              }
     64              OS_ENTER_CRITICAL();
   \                     ??OSMboxAccept_0:
   \   00000E   ........     CALLA   #OSCPUSaveSR
     65              pmsg               = pevent->OSEventPtr;
   \   000012   3B0A0200     MOVA    0x2(R10), R11
     66              pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
   \   000016   0018CA430200 MOVX.A  #0x0, 0x2(R10)
     67              OS_EXIT_CRITICAL();
   \   00001C   ........     CALLA   #OSCPURestoreSR
     68              return (pmsg);                                        /* Return the message received (or NULL)     */
   \   000020   CC0B         MOVA    R11, R12
   \                     ??OSMboxAccept_1:
   \   000022   1A16         POPM.A  #0x2, R11
   \   000024   1001         RETA
     69          }
     70          #endif
     71          /*$PAGE*/
     72          /*
     73          *********************************************************************************************************
     74          *                                        CREATE A MESSAGE MAILBOX
     75          *
     76          * Description: This function creates a message mailbox if free event control blocks are available.
     77          *
     78          * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
     79          *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
     80          *                            will be considered empty.
     81          *
     82          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
     83          *                                created mailbox
     84          *              == (OS_EVENT *)0  if no event control blocks were available
     85          *********************************************************************************************************
     86          */
     87          

   \                                 In  segment CODE, align 2
     88          OS_EVENT  *OSMboxCreate (void *pmsg)
   \                     OSMboxCreate:
     89          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
     90              OS_EVENT  *pevent;
     91          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     92              OS_CPU_SR  cpu_sr = 0u;
     93          #endif
     94          
     95          
     96          
     97          #ifdef OS_SAFETY_CRITICAL_IEC61508
     98              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     99                  OS_SAFETY_CRITICAL_EXCEPTION();
    100              }
    101          #endif
    102          
    103              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
   \   000004   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00000A   0224         JEQ     ??OSMboxCreate_0
    104                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   00000C   4C43         MOVA    #0x0, R12
   \   00000E   193C         JMP     ??OSMboxCreate_1
    105              }
    106              OS_ENTER_CRITICAL();
   \                     ??OSMboxCreate_0:
   \   000010   ........     CALLA   #OSCPUSaveSR
   \   000014   ........     MOVA    &OSEventFreeList, R15
   \   000018   CB0F         MOVA    R15, R11
    107              pevent = OSEventFreeList;                    /* Get next free event control block                  */
    108              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   00001A   DF03         CMPA    #0x0, R15
   \   00001C   0424         JEQ     ??OSMboxCreate_2
    109                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   00001E   ....D24F0200 MOVX.A  0x2(R15), &OSEventFreeList
   \            ....        
    110              }
    111              OS_EXIT_CRITICAL();
   \                     ??OSMboxCreate_2:
   \   000026   ........     CALLA   #OSCPURestoreSR
    112              if (pevent != (OS_EVENT *)0) {
   \   00002A   DB03         CMPA    #0x0, R11
   \   00002C   0924         JEQ     ??OSMboxCreate_3
    113                  pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
   \   00002E   DB430000     MOV.B   #0x1, 0(R11)
    114                  pevent->OSEventCnt     = 0u;
   \   000032   8B430600     MOV.W   #0x0, 0x6(R11)
    115                  pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
   \   000036   7B0A0200     MOVA    R10, 0x2(R11)
    116          #if OS_EVENT_NAME_EN > 0u
    117                  pevent->OSEventName    = (INT8U *)(void *)"?";
    118          #endif
    119                  OS_EventWaitListInit(pevent);
   \   00003A   CC0B         MOVA    R11, R12
   \   00003C   ........     CALLA   #OS_EventWaitListInit
    120              }
    121              return (pevent);                             /* Return pointer to event control block              */
   \                     ??OSMboxCreate_3:
   \   000040   CC0B         MOVA    R11, R12
   \                     ??OSMboxCreate_1:
   \   000042   1A16         POPM.A  #0x2, R11
   \   000044   1001         RETA
    122          }
    123          /*$PAGE*/
    124          /*
    125          *********************************************************************************************************
    126          *                                         DELETE A MAIBOX
    127          *
    128          * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
    129          *
    130          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    131          *                            mailbox.
    132          *
    133          *              opt           determines delete options as follows:
    134          *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
    135          *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
    136          *                                                    In this case, all the tasks pending will be readied.
    137          *
    138          *              perr          is a pointer to an error code that can contain one of the following values:
    139          *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
    140          *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
    141          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    142          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
    143          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
    144          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    145          *
    146          * Returns    : pevent        upon error
    147          *              (OS_EVENT *)0 if the mailbox was successfully deleted.
    148          *
    149          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    150          *                 the mailbox MUST check the return code of OSMboxPend().
    151          *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
    152          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    153          *                 time is directly proportional to the number of tasks waiting on the mailbox.
    154          *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
    155          *                 applications where the mailbox is used for mutual exclusion because the resource(s)
    156          *                 will no longer be guarded by the mailbox.
    157          *********************************************************************************************************
    158          */
    159          
    160          #if OS_MBOX_DEL_EN > 0u

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   CC0B         MOVA    R11, R12
   \   000002   ........     BRA     #OS_EventTaskRdy

   \                                 In  segment CODE, align 2
   \                     ??Subroutine7_0:
   \   000000   6E43         MOV.B   #0x2, R14
   \   000002   4D43         MOVA    #0x0, R13
   \   000004   ....         JMP     ?Subroutine5
   \   000006   0343         NOP

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   ........     CALLA   #OSCPUSaveSR
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2
    161          OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
   \                     OSMboxDel:
    162                                INT8U      opt,
    163                                INT8U     *perr)
    164          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   464D         MOV.B   R13, R6
   \   000006   C80E         MOVA    R14, R8
    165              BOOLEAN    tasks_waiting;
    166              OS_EVENT  *pevent_return;
    167          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    168              OS_CPU_SR  cpu_sr = 0u;
    169          #endif
    170          
    171          
    172          
    173          #ifdef OS_SAFETY_CRITICAL
    174              if (perr == (INT8U *)0) {
    175                  OS_SAFETY_CRITICAL_EXCEPTION();
    176              }
    177          #endif
    178          
    179          #if OS_ARG_CHK_EN > 0u
    180              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    181                  *perr = OS_ERR_PEVENT_NULL;
    182                  return (pevent);
    183              }
    184          #endif
    185              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   000008   DC930000     CMP.B   #0x1, 0(R12)
   \   00000C   0324         JEQ     ??OSMboxDel_3
    186                  *perr = OS_ERR_EVENT_TYPE;
   \   00000E   DE430000     MOV.B   #0x1, 0(R14)
    187                  return (pevent);
   \   000012   393C         JMP     ??OSMboxDel_1
    188              }
    189              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMboxDel_3:
   \   000014   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00001A   0424         JEQ     ??OSMboxDel_4
    190                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00001C   FE400F000000 MOV.B   #0xf, 0(R14)
    191                  return (pevent);
   \   000022   313C         JMP     ??OSMboxDel_1
    192              }
    193              OS_ENTER_CRITICAL();
   \                     ??OSMboxDel_4:
   \   000024   ........     CALLA   #?Subroutine0
    194              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
   \                     ??CrossCallReturnLabel_3:
   \   000028   0220         JNE     ??OSMboxDel_5
   \   00002A   4943         MOV.B   #0x0, R9
   \   00002C   013C         JMP     ??OSMboxDel_6
   \                     ??OSMboxDel_5:
   \   00002E   5943         MOV.B   #0x1, R9
    195                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    196              } else {
    197                  tasks_waiting = OS_FALSE;                          /* No                                       */
    198              }
    199              switch (opt) {
   \                     ??OSMboxDel_6:
   \   000030   4683         SUB.B   #0x0, R6
   \   000032   0324         JEQ     ??OSMboxDel_7
   \   000034   5683         SUB.B   #0x1, R6
   \   000036   1124         JEQ     ??OSMboxDel_8
   \   000038   203C         JMP     ??OSMboxDel_9
    200                  case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
    201                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMboxDel_7:
   \   00003A   59B3         BIT.B   #0x1, R9
   \   00003C   052C         JC      ??OSMboxDel_10
    202          #if OS_EVENT_NAME_EN > 0u
    203                           pevent->OSEventName = (INT8U *)(void *)"?";
    204          #endif
    205                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   00003E   ........     CALLA   #?Subroutine3
    206                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
    207                           pevent->OSEventCnt  = 0u;
    208                           OSEventFreeList     = pevent;             /* Get next free event control block        */
    209                           OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_4:
   \   000042   ........     CALLA   #OSCPURestoreSR
    210                           *perr               = OS_ERR_NONE;
   \   000046   153C         JMP     ??OSMboxDel_2
    211                           pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
    212                       } else {
    213                           OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_10:
   \   000048   ........     CALLA   #OSCPURestoreSR
    214                           *perr               = OS_ERR_TASK_WAITING;
   \   00004C   F84049000000 MOV.B   #0x49, 0(R8)
    215                           pevent_return       = pevent;
   \   000052   183C         JMP     ??OSMboxDel_11
    216                       }
    217                       break;
    218          
    219                  case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
    220                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
    221                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxDel_0:
   \   000054   4F43         MOV.B   #0x0, R15
   \   000056   ........     CALLA   #??Subroutine7_0
    222                       }
   \                     ??OSMboxDel_8:
   \   00005A   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00005E   FA23         JNE     ??OSMboxDel_0
    223          #if OS_EVENT_NAME_EN > 0u
    224                       pevent->OSEventName    = (INT8U *)(void *)"?";
    225          #endif
    226                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000060   ........     CALLA   #?Subroutine3
    227                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
    228                       pevent->OSEventCnt     = 0u;
    229                       OSEventFreeList        = pevent;              /* Get next free event control block        */
    230                       OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_5:
   \   000064   0C4A         MOV.W   R10, R12
   \   000066   ........     CALLA   #OSCPURestoreSR
    231                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00006A   59B3         BIT.B   #0x1, R9
   \   00006C   0228         JNC     ??OSMboxDel_2
    232                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00006E   ........     CALLA   #OS_Sched
    233                       }
    234                       *perr         = OS_ERR_NONE;
   \                     ??OSMboxDel_2:
   \   000072   C8430000     MOV.B   #0x0, 0(R8)
    235                       pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
   \   000076   4C43         MOVA    #0x0, R12
    236                       break;
   \   000078   063C         JMP     ??OSMboxDel_1
    237          
    238                  default:
    239                       OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_9:
   \   00007A   ........     CALLA   #OSCPURestoreSR
    240                       *perr         = OS_ERR_INVALID_OPT;
   \   00007E   F84007000000 MOV.B   #0x7, 0(R8)
    241                       pevent_return = pevent;
   \                     ??OSMboxDel_11:
   \   000084   CC0B         MOVA    R11, R12
    242                       break;
    243              }
    244              return (pevent_return);
   \                     ??OSMboxDel_1:
   \   000086   5616         POPM.A  #0x6, R11
   \   000088   1001         RETA
    245          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   CB430000     MOV.B   #0x0, 0(R11)
   \   000004   ....DB42.... MOVX.A  &OSEventFreeList, 0x2(R11)
   \            0200        
   \   00000C   8B430600     MOV.W   #0x0, 0x6(R11)
   \   000010   ........     MOVA    R11, &OSEventFreeList
   \   000014   1001         RETA
    246          #endif
    247          
    248          /*$PAGE*/
    249          /*
    250          *********************************************************************************************************
    251          *                                      PEND ON MAILBOX FOR A MESSAGE
    252          *
    253          * Description: This function waits for a message to be sent to a mailbox
    254          *
    255          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    256          *
    257          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    258          *                            wait for a message to arrive at the mailbox up to the amount of time
    259          *                            specified by this argument.  If you specify 0, however, your task will wait
    260          *                            forever at the specified mailbox or, until a message arrives.
    261          *
    262          *              perr          is a pointer to where an error message will be deposited.  Possible error
    263          *                            messages are:
    264          *
    265          *                            OS_ERR_NONE         The call was successful and your task received a
    266          *                                                message.
    267          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    268          *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
    269          *                            OS_ERR_EVENT_TYPE   Invalid event type
    270          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    271          *                                                would lead to a suspension.
    272          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    273          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    274          *
    275          * Returns    : != (void *)0  is a pointer to the message received
    276          *              == (void *)0  if no message was received or,
    277          *                            if 'pevent' is a NULL pointer or,
    278          *                            if you didn't pass the proper pointer to the event control block.
    279          *********************************************************************************************************
    280          */
    281          /*$PAGE*/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine6_0:
   \   000000   ........     CALLA   #OSCPURestoreSR
   \   000004   ........     BRA     #OS_Sched

   \                                 In  segment CODE, align 2
    282          void  *OSMboxPend (OS_EVENT  *pevent,
   \                     OSMboxPend:
    283                             INT32U     timeout,
    284                             INT8U     *perr)
    285          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   C90C         MOVA    R12, R9
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
   \   000008   C60D         MOVA    R13, R6
    286              void      *pmsg;
    287          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    288              OS_CPU_SR  cpu_sr = 0u;
    289          #endif
    290          
    291          
    292          
    293          #ifdef OS_SAFETY_CRITICAL
    294              if (perr == (INT8U *)0) {
    295                  OS_SAFETY_CRITICAL_EXCEPTION();
    296              }
    297          #endif
    298          
    299          #if OS_ARG_CHK_EN > 0u
    300              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    301                  *perr = OS_ERR_PEVENT_NULL;
    302                  return ((void *)0);
    303              }
    304          #endif
    305              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   00000A   DC930000     CMP.B   #0x1, 0(R12)
   \   00000E   0324         JEQ     ??OSMboxPend_1
    306                  *perr = OS_ERR_EVENT_TYPE;
   \   000010   DD430000     MOV.B   #0x1, 0(R13)
    307                  return ((void *)0);
   \   000014   0E3C         JMP     ??OSMboxPend_0
    308              }
    309              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
   \                     ??OSMboxPend_1:
   \   000016   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00001C   0324         JEQ     ??OSMboxPend_2
    310                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   00001E   ED430000     MOV.B   #0x2, 0(R13)
    311                  return ((void *)0);
   \   000022   073C         JMP     ??OSMboxPend_0
    312              }
    313              if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
   \                     ??OSMboxPend_2:
   \   000024   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   00002A   0524         JEQ     ??OSMboxPend_3
    314                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   00002C   FD400D000000 MOV.B   #0xd, 0(R13)
    315                  return ((void *)0);
   \                     ??OSMboxPend_0:
   \   000032   4C43         MOVA    #0x0, R12
   \   000034   4E3C         JMP     ??OSMboxPend_4
    316              }
    317              OS_ENTER_CRITICAL();
   \                     ??OSMboxPend_3:
   \   000036   ........     CALLA   #OSCPUSaveSR
   \   00003A   084C         MOV.W   R12, R8
    318              pmsg = pevent->OSEventPtr;
   \   00003C   37090200     MOVA    0x2(R9), R7
    319              if (pmsg != (void *)0) {                          /* See if there is already a message             */
   \   000040   D703         CMPA    #0x0, R7
   \   000042   0824         JEQ     ??OSMboxPend_5
    320                  pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
   \   000044   0018C9430200 MOVX.A  #0x0, 0x2(R9)
    321                  OS_EXIT_CRITICAL();
   \   00004A   ........     CALLA   #OSCPURestoreSR
    322                  *perr = OS_ERR_NONE;
   \   00004E   C6430000     MOV.B   #0x0, 0(R6)
    323                  return (pmsg);                                /* Return the message received (or NULL)         */
   \   000052   3E3C         JMP     ??OSMboxPend_6
    324              }
    325              OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
   \                     ??OSMboxPend_5:
   \   000054   ........     MOVA    #OSTCBCur, R4
   \   000058   0F04         MOVA    @R4, R15
   \   00005A   EFD32E00     BIS.B   #0x2, 0x2e(R15)
    326              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00005E   0F04         MOVA    @R4, R15
   \   000060   CF432F00     MOV.B   #0x0, 0x2f(R15)
    327              OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
   \   000064   0F04         MOVA    @R4, R15
   \   000066   8F4A2A00     MOV.W   R10, 0x2a(R15)
   \   00006A   8F4B2C00     MOV.W   R11, 0x2c(R15)
    328              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   00006E   CC09         MOVA    R9, R12
   \   000070   ........     CALLA   #OS_EventTaskWait
    329              OS_EXIT_CRITICAL();
   \   000074   0C48         MOV.W   R8, R12
   \   000076   ........     CALLA   #??Subroutine6_0
    330              OS_Sched();                                       /* Find next highest priority task ready to run  */
    331              OS_ENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_6:
   \   00007A   ........     CALLA   #OSCPUSaveSR
   \   00007E   084C         MOV.W   R12, R8
    332              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   000080   0F04         MOVA    @R4, R15
   \   000082   5E4F2F00     MOV.B   0x2f(R15), R14
   \   000086   4E83         SUB.B   #0x0, R14
   \   000088   0324         JEQ     ??OSMboxPend_7
   \   00008A   6E83         SUB.B   #0x2, R14
   \   00008C   0624         JEQ     ??OSMboxPend_8
   \   00008E   093C         JMP     ??OSMboxPend_9
    333                  case OS_STAT_PEND_OK:
    334                       pmsg =  OSTCBCur->OSTCBMsg;
   \                     ??OSMboxPend_7:
   \   000090   370F2000     MOVA    0x20(R15), R7
    335                      *perr =  OS_ERR_NONE;
   \   000094   C6430000     MOV.B   #0x0, 0(R6)
    336                       break;
   \   000098   0B3C         JMP     ??OSMboxPend_10
    337          
    338                  case OS_STAT_PEND_ABORT:
    339                       pmsg = (void *)0;
    340                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \                     ??OSMboxPend_8:
   \   00009A   F6400E000000 MOV.B   #0xe, 0(R6)
    341                       break;
   \   0000A0   073C         JMP     ??OSMboxPend_10
    342          
    343                  case OS_STAT_PEND_TO:
    344                  default:
    345                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSMboxPend_9:
   \   0000A2   CD09         MOVA    R9, R13
   \   0000A4   0C04         MOVA    @R4, R12
   \   0000A6   ........     CALLA   #OS_EventTaskRemove
    346                       pmsg = (void *)0;
    347                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   0000AA   F6400A000000 MOV.B   #0xa, 0(R6)
    348                       break;
    349              }
    350              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSMboxPend_10:
   \   0000B0   0F04         MOVA    @R4, R15
   \   0000B2   CF432E00     MOV.B   #0x0, 0x2e(R15)
    351              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   0000B6   0F04         MOVA    @R4, R15
   \   0000B8   CF432F00     MOV.B   #0x0, 0x2f(R15)
    352              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   0000BC   0F04         MOVA    @R4, R15
   \   0000BE   0018CF431C00 MOVX.A  #0x0, 0x1c(R15)
    353          #if (OS_EVENT_MULTI_EN > 0u)
    354              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    355          #endif
    356              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
   \   0000C4   0018CF432000 MOVX.A  #0x0, 0x20(R15)
    357              OS_EXIT_CRITICAL();
   \   0000CA   0C48         MOV.W   R8, R12
   \   0000CC   ........     CALLA   #OSCPURestoreSR
    358              return (pmsg);                                    /* Return received message                       */
   \                     ??OSMboxPend_6:
   \   0000D0   CC07         MOVA    R7, R12
   \                     ??OSMboxPend_4:
   \   0000D2   7416         POPM.A  #0x8, R11
   \   0000D4   1001         RETA
    359          }
    360          /*$PAGE*/
    361          /*
    362          *********************************************************************************************************
    363          *                                      ABORT WAITING ON A MESSAGE MAILBOX
    364          *
    365          * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
    366          *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
    367          *              the mailbox via OSMboxPost() or OSMboxPostOpt().
    368          *
    369          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
    370          *
    371          *              opt           determines the type of ABORT performed:
    372          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    373          *                                                     mailbox
    374          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    375          *                                                     mailbox
    376          *
    377          *              perr          is a pointer to where an error message will be deposited.  Possible error
    378          *                            messages are:
    379          *
    380          *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
    381          *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
    382          *                                                and informed of the aborted wait; check return value
    383          *                                                for the number of tasks whose wait on the mailbox
    384          *                                                was aborted.
    385          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
    386          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    387          *
    388          * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
    389          *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
    390          *********************************************************************************************************
    391          */
    392          
    393          #if OS_MBOX_PEND_ABORT_EN > 0u

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   0C4A         MOV.W   R10, R12
   \   000002                REQUIRE ??Subroutine6_0
   \   000002                // Fall through to label ??Subroutine6_0

   \                                 In  segment CODE, align 2, keep-with-next
    394          INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
   \                     OSMboxPendAbort:
    395                                  INT8U      opt,
    396                                  INT8U     *perr)
    397          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   464D         MOV.B   R13, R6
   \   000006   C80E         MOVA    R14, R8
    398              INT8U      nbr_tasks;
    399          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    400              OS_CPU_SR  cpu_sr = 0u;
    401          #endif
    402          
    403          
    404          
    405          #ifdef OS_SAFETY_CRITICAL
    406              if (perr == (INT8U *)0) {
    407                  OS_SAFETY_CRITICAL_EXCEPTION();
    408              }
    409          #endif
    410          
    411          #if OS_ARG_CHK_EN > 0u
    412              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    413                  *perr = OS_ERR_PEVENT_NULL;
    414                  return (0u);
    415              }
    416          #endif
    417              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   000008   DC930000     CMP.B   #0x1, 0(R12)
   \   00000C   0324         JEQ     ??OSMboxPendAbort_1
    418                  *perr = OS_ERR_EVENT_TYPE;
   \   00000E   DE430000     MOV.B   #0x1, 0(R14)
    419                  return (0u);
   \   000012   1B3C         JMP     ??OSMboxPendAbort_2
    420              }
    421              OS_ENTER_CRITICAL();
   \                     ??OSMboxPendAbort_1:
   \   000014   ........     CALLA   #?Subroutine0
    422              if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
   \                     ??CrossCallReturnLabel_2:
   \   000018   1424         JEQ     ??OSMboxPendAbort_3
    423                  nbr_tasks = 0u;
   \   00001A   4943         MOV.B   #0x0, R9
    424                  switch (opt) {
   \   00001C   5693         CMP.B   #0x1, R6
   \   00001E   0720         JNE     ??OSMboxPendAbort_4
    425                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    426                           while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
    427                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_0:
   \   000020   ........     CALLA   #?Subroutine4
    428                               nbr_tasks++;
   \                     ??CrossCallReturnLabel_10:
   \   000024   5953         ADD.B   #0x1, R9
    429                           }
   \   000026   CB930800     CMP.B   #0x0, 0x8(R11)
   \   00002A   0424         JEQ     ??OSMboxPendAbort_5
   \   00002C   F93F         JMP     ??OSMboxPendAbort_0
    430                           break;
    431          
    432                      case OS_PEND_OPT_NONE:
    433                      default:                                       /* No,  ready HPT       waiting on mailbox  */
    434                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_4:
   \   00002E   ........     CALLA   #?Subroutine4
    435                           nbr_tasks++;
   \                     ??CrossCallReturnLabel_9:
   \   000032   5943         MOV.B   #0x1, R9
    436                           break;
    437                  }
    438                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_5:
   \   000034   ........     CALLA   #?Subroutine1
    439                  OS_Sched();                                        /* Find HPT ready to run                    */
    440                  *perr = OS_ERR_PEND_ABORT;
   \                     ??CrossCallReturnLabel_7:
   \   000038   F8400E000000 MOV.B   #0xe, 0(R8)
    441                  return (nbr_tasks);
   \   00003E   4C49         MOV.B   R9, R12
   \   000040   053C         JMP     ??OSMboxPendAbort_6
    442              }
    443              OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_3:
   \   000042   ........     CALLA   #OSCPURestoreSR
    444              *perr = OS_ERR_NONE;
   \   000046   C8430000     MOV.B   #0x0, 0(R8)
    445              return (0u);                                           /* No tasks waiting on mailbox              */
   \                     ??OSMboxPendAbort_2:
   \   00004A   4C43         MOV.B   #0x0, R12
   \                     ??OSMboxPendAbort_6:
   \   00004C   5616         POPM.A  #0x6, R11
   \   00004E   1001         RETA
    446          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   6F43         MOV.B   #0x2, R15
   \   000002                REQUIRE ??Subroutine7_0
   \   000002                // Fall through to label ??Subroutine7_0
    447          #endif
    448          
    449          /*$PAGE*/
    450          /*
    451          *********************************************************************************************************
    452          *                                       POST MESSAGE TO A MAILBOX
    453          *
    454          * Description: This function sends a message to a mailbox
    455          *
    456          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    457          *
    458          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    459          *
    460          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    461          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    462          *                                   message at a time and thus, the message MUST be consumed before you
    463          *                                   are allowed to send another one.
    464          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    465          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    466          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    467          *
    468          * Note(s)    : 1) HPT means Highest Priority Task
    469          *********************************************************************************************************
    470          */
    471          
    472          #if OS_MBOX_POST_EN > 0u

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   6E43         MOV.B   #0x2, R14
   \   000004   CD08         MOVA    R8, R13
   \   000006                REQUIRE ?Subroutine5
   \   000006                // Fall through to label ?Subroutine5

   \                                 In  segment CODE, align 2
    473          INT8U  OSMboxPost (OS_EVENT  *pevent,
   \                     OSMboxPost:
    474                             void      *pmsg)
    475          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   C80D         MOVA    R13, R8
    476          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    477              OS_CPU_SR  cpu_sr = 0u;
    478          #endif
    479          
    480          
    481          
    482          #if OS_ARG_CHK_EN > 0u
    483              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    484                  return (OS_ERR_PEVENT_NULL);
    485              }
    486              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    487                  return (OS_ERR_POST_NULL_PTR);
    488              }
    489          #endif
    490              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   000006   DC930000     CMP.B   #0x1, 0(R12)
   \   00000A   0224         JEQ     ??OSMboxPost_0
    491                  return (OS_ERR_EVENT_TYPE);
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   163C         JMP     ??OSMboxPost_1
    492              }
    493              OS_ENTER_CRITICAL();
   \                     ??OSMboxPost_0:
   \   000010   ........     CALLA   #?Subroutine0
    494              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
   \                     ??CrossCallReturnLabel_1:
   \   000014   0524         JEQ     ??OSMboxPost_2
    495                                                                /* Ready HPT waiting on event                    */
    496                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   000016   ........     CALLA   #?Subroutine2
    497                  OS_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_11:
   \   00001A   ........     CALLA   #?Subroutine1
    498                  OS_Sched();                                   /* Find highest priority task ready to run       */
    499                  return (OS_ERR_NONE);
   \                     ??CrossCallReturnLabel_8:
   \   00001E   0D3C         JMP     ??OSMboxPost_3
    500              }
    501              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPost_2:
   \   000020   3F0B0200     MOVA    0x2(R11), R15
   \   000024   DF03         CMPA    #0x0, R15
   \   000026   0524         JEQ     ??OSMboxPost_4
    502                  OS_EXIT_CRITICAL();
   \   000028   ........     CALLA   #OSCPURestoreSR
    503                  return (OS_ERR_MBOX_FULL);
   \   00002C   7C401400     MOV.B   #0x14, R12
   \   000030   053C         JMP     ??OSMboxPost_1
    504              }
    505              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPost_4:
   \   000032   7B080200     MOVA    R8, 0x2(R11)
    506              OS_EXIT_CRITICAL();
   \   000036   ........     CALLA   #OSCPURestoreSR
    507              return (OS_ERR_NONE);
   \                     ??OSMboxPost_3:
   \   00003A   4C43         MOV.B   #0x0, R12
   \                     ??OSMboxPost_1:
   \   00003C   3816         POPM.A  #0x4, R11
   \   00003E   1001         RETA
    508          }
    509          #endif
    510          
    511          /*$PAGE*/
    512          /*
    513          *********************************************************************************************************
    514          *                                       POST MESSAGE TO A MAILBOX
    515          *
    516          * Description: This function sends a message to a mailbox
    517          *
    518          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    519          *
    520          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    521          *
    522          *              opt           determines the type of POST performed:
    523          *                            OS_POST_OPT_NONE         POST to a single waiting task
    524          *                                                     (Identical to OSMboxPost())
    525          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
    526          *
    527          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    528          *
    529          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    530          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    531          *                                   message at a time and thus, the message MUST be consumed before you
    532          *                                   are allowed to send another one.
    533          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    534          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    535          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    536          *
    537          * Note(s)    : 1) HPT means Highest Priority Task
    538          *
    539          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    540          *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
    541          *********************************************************************************************************
    542          */
    543          
    544          #if OS_MBOX_POST_OPT_EN > 0u

   \                                 In  segment CODE, align 2
    545          INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
   \                     OSMboxPostOpt:
    546                                void      *pmsg,
    547                                INT8U      opt)
    548          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   C80D         MOVA    R13, R8
   \   000006   494E         MOV.B   R14, R9
    549          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    550              OS_CPU_SR  cpu_sr = 0u;
    551          #endif
    552          
    553          
    554          
    555          #if OS_ARG_CHK_EN > 0u
    556              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    557                  return (OS_ERR_PEVENT_NULL);
    558              }
    559              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    560                  return (OS_ERR_POST_NULL_PTR);
    561              }
    562          #endif
    563              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   000008   DC930000     CMP.B   #0x1, 0(R12)
   \   00000C   0224         JEQ     ??OSMboxPostOpt_3
    564                  return (OS_ERR_EVENT_TYPE);
   \   00000E   5C43         MOV.B   #0x1, R12
   \   000010   233C         JMP     ??OSMboxPostOpt_4
    565              }
    566              OS_ENTER_CRITICAL();
   \                     ??OSMboxPostOpt_3:
   \   000012   ........     CALLA   #?Subroutine0
    567              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
   \                     ??CrossCallReturnLabel_0:
   \   000016   1224         JEQ     ??OSMboxPostOpt_5
    568                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
   \   000018   59B3         BIT.B   #0x1, R9
   \   00001A   0628         JNC     ??OSMboxPostOpt_6
    569                      while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
    570                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_0:
   \   00001C   ........     CALLA   #?Subroutine2
    571                      }
   \                     ??CrossCallReturnLabel_12:
   \   000020   CB930800     CMP.B   #0x0, 0x8(R11)
   \   000024   0324         JEQ     ??OSMboxPostOpt_7
   \   000026   FA3F         JMP     ??OSMboxPostOpt_0
    572                  } else {                                      /* No,  Post to HPT waiting on mbox              */
    573                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_6:
   \   000028   ........     CALLA   #?Subroutine2
    574                  }
    575                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPostOpt_7:
   \   00002C   0C4A         MOV.W   R10, R12
   \   00002E   ........     CALLA   #OSCPURestoreSR
    576                  if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
   \   000032   69B2         BIT.B   #0x4, R9
   \   000034   102C         JC      ??OSMboxPostOpt_2
    577                      OS_Sched();                               /* Find HPT ready to run                         */
   \   000036   ........     CALLA   #OS_Sched
    578                  }
    579                  return (OS_ERR_NONE);
   \   00003A   0D3C         JMP     ??OSMboxPostOpt_2
    580              }
    581              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPostOpt_5:
   \   00003C   3F0B0200     MOVA    0x2(R11), R15
   \   000040   DF03         CMPA    #0x0, R15
   \   000042   0524         JEQ     ??OSMboxPostOpt_8
    582                  OS_EXIT_CRITICAL();
   \   000044   ........     CALLA   #OSCPURestoreSR
    583                  return (OS_ERR_MBOX_FULL);
   \   000048   7C401400     MOV.B   #0x14, R12
   \   00004C   053C         JMP     ??OSMboxPostOpt_4
    584              }
    585              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPostOpt_8:
   \   00004E   7B080200     MOVA    R8, 0x2(R11)
    586              OS_EXIT_CRITICAL();
   \   000052   ........     CALLA   #OSCPURestoreSR
    587              return (OS_ERR_NONE);
   \                     ??OSMboxPostOpt_2:
   \   000056   4C43         MOV.B   #0x0, R12
   \                     ??OSMboxPostOpt_4:
   \   000058   3816         POPM.A  #0x4, R11
   \   00005A   1001         RETA
    588          }
    589          #endif
    590          
    591          /*$PAGE*/
    592          /*
    593          *********************************************************************************************************
    594          *                                        QUERY A MESSAGE MAILBOX
    595          *
    596          * Description: This function obtains information about a message mailbox.
    597          *
    598          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    599          *
    600          *              p_mbox_data   is a pointer to a structure that will contain information about the message
    601          *                            mailbox.
    602          *
    603          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    604          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
    605          *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
    606          *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
    607          *********************************************************************************************************
    608          */
    609          
    610          #if OS_MBOX_QUERY_EN > 0u

   \                                 In  segment CODE, align 2
    611          INT8U  OSMboxQuery (OS_EVENT      *pevent,
   \                     OSMboxQuery:
    612                              OS_MBOX_DATA  *p_mbox_data)
    613          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   CB0D         MOVA    R13, R11
    614              INT8U       i;
    615              OS_PRIO    *psrc;
    616              OS_PRIO    *pdest;
    617          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    618              OS_CPU_SR   cpu_sr = 0u;
    619          #endif
    620          
    621          
    622          
    623          #if OS_ARG_CHK_EN > 0u
    624              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    625                  return (OS_ERR_PEVENT_NULL);
    626              }
    627              if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
    628                  return (OS_ERR_PDATA_NULL);
    629              }
    630          #endif
    631              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   000006   DC930000     CMP.B   #0x1, 0(R12)
   \   00000A   0224         JEQ     ??OSMboxQuery_1
    632                  return (OS_ERR_EVENT_TYPE);
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   1D3C         JMP     ??OSMboxQuery_2
    633              }
    634              OS_ENTER_CRITICAL();
   \                     ??OSMboxQuery_1:
   \   000010   ........     CALLA   #OSCPUSaveSR
    635              p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
   \   000014   DB4A08000C00 MOV.B   0x8(R10), 0xc(R11)
    636              psrc                    = &pevent->OSEventTbl[0];
   \   00001A   CF0A         MOVA    R10, R15
   \   00001C   AF000900     ADDA    #0x9, R15
    637              pdest                   = &p_mbox_data->OSEventTbl[0];
   \   000020   CE0B         MOVA    R11, R14
   \   000022   AE000400     ADDA    #0x4, R14
    638              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   000026   6D42         MOV.B   #0x4, R13
    639                  *pdest++ = *psrc++;
   \                     ??OSMboxQuery_0:
   \   000028   FE4F0000     MOV.B   @R15+, 0(R14)
   \   00002C   AE000100     ADDA    #0x1, R14
   \   000030   FE4F0000     MOV.B   @R15+, 0(R14)
   \   000034   AE000100     ADDA    #0x1, R14
    640              }
   \   000038   7D53         ADD.B   #0xff, R13
   \   00003A   F623         JNE     ??OSMboxQuery_0
    641              p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
   \   00003C   0018DB4A0200 MOVX.A  0x2(R10), 0(R11)
   \            0000        
    642              OS_EXIT_CRITICAL();
   \   000044   ........     CALLA   #OSCPURestoreSR
    643              return (OS_ERR_NONE);
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??OSMboxQuery_2:
   \   00004A   1A16         POPM.A  #0x2, R11
   \   00004C   1001         RETA
    644          }
    645          #endif                                                     /* OS_MBOX_QUERY_EN                         */
    646          #endif                                                     /* OS_MBOX_EN                               */
    647          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      12  OSMboxAccept
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
      12  OSMboxCreate
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
            12 -> OS_EventWaitListInit
      28  OSMboxDel
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventTaskRdy
            28 -> OS_Sched
      36  OSMboxPend
            36 -> OSCPURestoreSR
            36 -> OSCPUSaveSR
            36 -> OS_EventTaskRemove
            36 -> OS_EventTaskWait
            36 -> OS_Sched
      28  OSMboxPendAbort
            28 -> OSCPURestoreSR
            28 -> OSCPUSaveSR
            28 -> OS_EventTaskRdy
            28 -> OS_Sched
      20  OSMboxPost
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      20  OSMboxPostOpt
            20 -> OSCPURestoreSR
            20 -> OSCPUSaveSR
            20 -> OS_EventTaskRdy
            20 -> OS_Sched
      12  OSMboxQuery
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine6_0
       8  ??Subroutine7_0
      12  ?Subroutine0
       2  ?Subroutine1
       6  ?Subroutine2
      22  ?Subroutine3
       2  ?Subroutine4
       6  ?Subroutine5
      38  OSMboxAccept
      70  OSMboxCreate
     138  OSMboxDel
     214  OSMboxPend
      80  OSMboxPendAbort
      64  OSMboxPost
      92  OSMboxPostOpt
      78  OSMboxQuery

 
 840 bytes in segment CODE
 
 840 bytes of CODE memory

Errors: none
Warnings: 11
