###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:27 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\mmc.c                                  #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\mmc.c -D NDEBUG -D RAM_VECTOR -lC      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -lA C:\Users\615\Desktop\MSP430\MS #
#                     P430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -o        #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\ -D__MSP430F5529__ -e --double=32    #
#                     --dlib_config "D:\Program Files (x86)\IAR               #
#                     Systems\Embedded Workbench 6.4                          #
#                     Evaluation\430\LIB\DLIB\dl430xlfn.h" -I                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\mmc.lst                             #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\mmc.r43                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\mmc.c
      1          /*------------------------------------------------------------------------/
      2          /  Bitbanging MMCv3/SDv1/SDv2 (in SPI mode) control module
      3          /-------------------------------------------------------------------------/
      4          /
      5          /  Copyright (C) 2010, ChaN, all right reserved.
      6          /
      7          / * This software is a free software and there is NO WARRANTY.
      8          / * No restriction on use. You can use, modify and redistribute it for
      9          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     10          / * Redistributions of source code must retain the above copyright notice.
     11          /
     12          ---------------------------------------------------------------------------*/
     13          
     14          #include <intrinsics.h>         /* Include MSP430-specific intrincs */
     15          #include "diskio.h"             /* Common include file for FatFs and disk I/O layer */
     16          #include "HAL_SDCard.h"         /* MSP-EXP430F5529 specific SD Card driver */
     17          
     18          /*-------------------------------------------------------------------------*/
     19          /* Platform dependent macros and functions needed to be modified           */
     20          /*-------------------------------------------------------------------------*/
     21          
     22          // CPU Frequency.
     23          #define MCLK_FREQ   25000000
     24          #define	INIT_PORT()     SDCard_init()       /* Initialize MMC control port */
     25          #define FAST_MODE()     SDCard_fastMode()   /* Maximize SD Card transfer speed */
     26          #define DLY_US(n)       __delay_cycles(n * (MCLK_FREQ/1000000))  // Delay n microseconds           // KLQ
     27          
     28          #define	CS_H()          SDCard_setCSHigh()  /* Set MMC CS "high" */
     29          #define CS_L()          SDCard_setCSLow()   /* Set MMC CS "low" */
     30          

   \                                 In  segment DATA20_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy20
     31          BYTE INS = 1;    // KLQ
   \                     INS:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for INS>`
     32          #define	WP              (0)                 /* Card is write protected (yes:true, no:false, default:false) */
     33          
     34          /*-------------------------------------------------------------------------*/
     35          /* Platform dependent RTC Function for FatFs module                        */
     36          /*-------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2
     37          DWORD get_fattime(void)
   \                     get_fattime:
     38          {
     39          	DWORD tmr;
     40          
     41              // TODO: Customize to use the MSP430 RTC
     42          
     43          	/* Pack date and time into a DWORD variable */
     44          	tmr =	  (((DWORD)2001 - 80) << 25)    // rtcYear
     45          			| ((DWORD)9 << 21)              // rtcMon
     46          			| ((DWORD)11 << 16)             // rtcMday
     47          			| (WORD)(4 << 11)               // rtcHour
     48          			| (WORD)(30 << 5)               // rtcMin
     49          			| (WORD)(0 >> 1);               // rtcSec
     50          
     51          	return tmr;
   \   000000   3C40C023     MOV.W   #0x23c0, R12
   \   000004   3D402B03     MOV.W   #0x32b, R13
   \   000008   1001         RETA
     52          }
     53          
     54          /*--------------------------------------------------------------------------
     55             Module Private Functions
     56          ---------------------------------------------------------------------------*/
     57          
     58          /* MMC/SD command (SPI mode) */
     59          #define CMD0	(0)			/* GO_IDLE_STATE */
     60          #define CMD1	(1)			/* SEND_OP_COND */
     61          #define	ACMD41	(0x80+41)	/* SEND_OP_COND (SDC) */
     62          #define CMD8	(8)			/* SEND_IF_COND */
     63          #define CMD9	(9)			/* SEND_CSD */
     64          #define CMD10	(10)		/* SEND_CID */
     65          #define CMD12	(12)		/* STOP_TRANSMISSION */
     66          #define ACMD13	(0x80+13)	/* SD_STATUS (SDC) */
     67          #define CMD16	(16)		/* SET_BLOCKLEN */
     68          #define CMD17	(17)		/* READ_SINGLE_BLOCK */
     69          #define CMD18	(18)		/* READ_MULTIPLE_BLOCK */
     70          #define CMD23	(23)		/* SET_BLOCK_COUNT */
     71          #define	ACMD23	(0x80+23)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
     72          #define CMD24	(24)		/* WRITE_BLOCK */
     73          #define CMD25	(25)		/* WRITE_MULTIPLE_BLOCK */
     74          #define CMD41	(41)		/* SEND_OP_COND (ACMD) */
     75          #define CMD55	(55)		/* APP_CMD */
     76          #define CMD58	(58)		/* READ_OCR */
     77          
     78          /* Card type flags (CardType) */
     79          #define CT_MMC		0x01		/* MMC ver 3 */
     80          #define CT_SD1		0x02		/* SD ver 1 */
     81          #define CT_SD2		0x04		/* SD ver 2 */
     82          #define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
     83          #define CT_BLOCK	0x08		/* Block addressing */
     84          
     85          
     86          static

   \                                 In  segment DATA20_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy20
     87          DSTATUS Stat = STA_NOINIT;	/* Disk status */
   \                     Stat:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for Stat>`
     88          
     89          static

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     90          BYTE CardType;			/* b0:MMC, b1:SDv1, b2:SDv2, b3:Block addressing */
   \                     CardType:
   \   000000                DS8 1
     91          
     92          
     93          
     94          /*-----------------------------------------------------------------------*/
     95          /* Transmit bytes to the MMC                                             */
     96          /*-----------------------------------------------------------------------*/
     97          
     98          static
     99          void xmit_mmc (
    100          	const BYTE* buff,               /* Data to be sent */
    101          	UINT bc                         /* Number of bytes to send */
    102          )
    103          {
    104              SDCard_sendFrame((uint8_t *)buff, bc);
    105          }
    106          
    107          /*-----------------------------------------------------------------------*/
    108          /* Receive bytes from the MMC                                            */
    109          /*-----------------------------------------------------------------------*/
    110          
    111          static
    112          void rcvr_mmc (
    113          	BYTE *buff,	/* Pointer to read buffer */
    114          	UINT bc		/* Number of bytes to receive */
    115          )
    116          {
    117          
    118              SDCard_readFrame(buff, bc);
    119          }
    120          
    121          
    122          /*-----------------------------------------------------------------------*/
    123          /* Wait for card ready                                                   */
    124          /*-----------------------------------------------------------------------*/
    125          
    126          static
    127          int wait_ready (void)    /* 1:OK, 0:Timeout */
    128          {
    129              BYTE d;
    130              UINT tmr;
    131          
    132          
    133              for (tmr = 5000; tmr; tmr--) {    /* Wait for ready in timeout of 500ms */
    134                  rcvr_mmc(&d, 1);
    135                  if (d == 0xFF) return 1;
    136                  DLY_US(100);
    137              }
    138          
    139              return 0;
    140          }
    141          
    142          
    143          
    144          /*-----------------------------------------------------------------------*/
    145          /* Deselect the card and release SPI bus                                 */
    146          /*-----------------------------------------------------------------------*/
    147          

   \                                 In  segment CODE, align 2
    148          static
    149          void deselect (void)
   \                     deselect:
    150          {
   \   000000   2183         SUB.W   #0x2, SP
    151              BYTE d;
    152          
    153              CS_H();
   \   000002   ........     CALLA   #SDCard_setCSHigh
    154              rcvr_mmc(&d, 1);
   \   000006   ........     CALLA   #?Subroutine3
    155          }
   \                     ??CrossCallReturnLabel_3:
   \   00000A   2153         ADD.W   #0x2, SP
   \   00000C   1001         RETA
    156          
    157          
    158          
    159          /*-----------------------------------------------------------------------*/
    160          /* Select the card and wait for ready                                    */
    161          /*-----------------------------------------------------------------------*/
    162          

   \                                 In  segment CODE, align 2
    163          static
    164          int select (void)    /* 1:OK, 0:Timeout */
   \                     select:
    165          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
    166              CS_L();
   \   000004   ........     CALLA   #SDCard_setCSLow
    167              if (!wait_ready()) {
   \   000008   3B408813     MOV.W   #0x1388, R11
   \   00000C   0A41         MOV.W   SP, R10
   \   00000E   0A53         ADD.W   #0x0, R10
   \                     ??select_0:
   \   000010   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_28:
   \   000014   F1930000     CMP.B   #0xff, 0(SP)
   \   000018   0220         JNE     ??select_1
    168                  deselect();
    169                  return 0;
    170              }
    171              return 1;
   \   00001A   1C43         MOV.W   #0x1, R12
   \   00001C   0A3C         JMP     ??select_2
   \                     ??select_1:
   \   00001E                ////////////// Start of 2500 cycles delay.
   \   00001E   003C         JMP     ??select_4
   \                     ??select_4:
   \   000020   3F403F03     MOV.W   #0x33f, R15
   \                     ??select_3:
   \   000024   3F53         ADD.W   #0xffff, R15
   \   000026   FE2F         JC      ??select_3
   \   000028                ////////////// End of delay code.
   \   000028   3B53         ADD.W   #0xffff, R11
   \   00002A   F223         JNE     ??select_0
   \   00002C   ........     CALLA   #deselect
   \   000030   0C43         MOV.W   #0x0, R12
   \                     ??select_2:
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   1A16         POPM.A  #0x2, R11
   \   000036   1001         RETA
    172          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   1D43         MOV.W   #0x1, R13
   \   000002                REQUIRE ??Subroutine1_0
   \   000002                // Fall through to label ??Subroutine1_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine1_0:
   \   000000   CC0A         MOVA    R10, R12
   \   000002   ........     BRA     #SDCard_readFrame
    173          
    174          
    175          
    176          /*-----------------------------------------------------------------------*/
    177          /* Receive a data packet from MMC                                        */
    178          /*-----------------------------------------------------------------------*/
    179          

   \                                 In  segment CODE, align 2, keep-with-next
    180          static
    181          int rcvr_datablock (    /* 1:OK, 0:Failed */
   \                     rcvr_datablock:
    182              BYTE *buff,            /* Data buffer to store received data */
    183              UINT btr            /* Byte count */
    184          )
    185          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   CB0C         MOVA    R12, R11
   \   000006   084D         MOV.W   R13, R8
    186              BYTE d[2];
    187              UINT tmr;
    188          
    189          
    190              for (tmr = 1000; tmr; tmr--) {    /* Wait for data packet in timeout of 100ms */
   \   000008   3940E803     MOV.W   #0x3e8, R9
   \   00000C   0A41         MOV.W   SP, R10
   \   00000E   0A53         ADD.W   #0x0, R10
    191                  rcvr_mmc(d, 1);
   \                     ??rcvr_datablock_0:
   \   000010   ........     CALLA   #?Subroutine1
    192                  if (d[0] != 0xFF) break;
   \                     ??CrossCallReturnLabel_26:
   \   000014   F1930000     CMP.B   #0xff, 0(SP)
   \   000018   0320         JNE     ??rcvr_datablock_1
    193                  DLY_US(100);
   \   00001A   ........     CALLA   #?Subroutine4
    194              }
   \                     ??CrossCallReturnLabel_4:
   \   00001E   F823         JNE     ??rcvr_datablock_0
    195              if (d[0] != 0xFE) return 0;        /* If not valid data token, retutn with error */
   \                     ??rcvr_datablock_1:
   \   000020   F190FE000000 CMP.B   #0xfe, 0(SP)
   \   000026   0224         JEQ     ??rcvr_datablock_2
   \   000028   0C43         MOV.W   #0x0, R12
   \   00002A   083C         JMP     ??rcvr_datablock_3
    196          
    197              rcvr_mmc(buff, btr);            /* Receive the data block into buffer */
   \                     ??rcvr_datablock_2:
   \   00002C   0D48         MOV.W   R8, R13
   \   00002E   CC0B         MOVA    R11, R12
   \   000030   ........     CALLA   #SDCard_readFrame
    198              rcvr_mmc(d, 2);                    /* Discard CRC */
   \   000034   2D43         MOV.W   #0x2, R13
   \   000036   ........     CALLA   #??Subroutine1_0
    199          
    200              return 1;                        /* Return with success */
   \                     ??CrossCallReturnLabel_23:
   \   00003A   1C43         MOV.W   #0x1, R12
   \                     ??rcvr_datablock_3:
   \   00003C   2153         ADD.W   #0x2, SP
   \   00003E   3816         POPM.A  #0x4, R11
   \   000040   1001         RETA
    201          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000                ////////////// Start of 2500 cycles delay.
   \   000000   003C         JMP     ??Subroutine4_1
   \                     ??Subroutine4_1:
   \   000002   3F403F03     MOV.W   #0x33f, R15
   \                     ??Subroutine4_0:
   \   000006   3F53         ADD.W   #0xffff, R15
   \   000008   FE2F         JC      ??Subroutine4_0
   \   00000A                ////////////// End of delay code.
   \   00000A   3953         ADD.W   #0xffff, R9
   \   00000C   1001         RETA
    202          
    203          
    204          
    205          /*-----------------------------------------------------------------------*/
    206          /* Send a data packet to MMC                                             */
    207          /*-----------------------------------------------------------------------*/
    208          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   2152         ADD.W   #0x4, SP
   \   000002   3816         POPM.A  #0x4, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    209          static
    210          int xmit_datablock (    /* 1:OK, 0:Failed */
   \                     xmit_datablock:
    211              const BYTE *buff,    /* 512 byte data block to be transmitted */
    212              BYTE token            /* Data/Stop token */
    213          )
    214          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   C80C         MOVA    R12, R8
   \   000006   4A4D         MOV.B   R13, R10
    215              BYTE d[2];
    216          
    217          
    218              if (!wait_ready()) return 0;
   \   000008   39408813     MOV.W   #0x1388, R9
   \   00000C   0B41         MOV.W   SP, R11
   \   00000E   0B53         ADD.W   #0x0, R11
   \                     ??xmit_datablock_0:
   \   000010   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_2:
   \   000014   F1930000     CMP.B   #0xff, 0(SP)
   \   000018   0D20         JNE     ??xmit_datablock_3
    219          
    220              d[0] = token;
   \   00001A   C14A0100     MOV.B   R10, 0x1(SP)
   \   00001E   0B41         MOV.W   SP, R11
   \   000020   1B53         ADD.W   #0x1, R11
   \   000022   1D43         MOV.W   #0x1, R13
   \   000024   CC0B         MOVA    R11, R12
    221              xmit_mmc(d, 1);                /* Xmit a token */
   \   000026   ........     CALLA   #SDCard_sendFrame
    222              if (token != 0xFD) {        /* Is it data token? */
   \   00002A   7A90FD00     CMP.B   #0xfd, R10
   \   00002E   0620         JNE     ??xmit_datablock_4
    223                  xmit_mmc(buff, 512);    /* Xmit the 512 byte data block to MMC */
    224                  rcvr_mmc(d, 2);            /* Dummy CRC (FF,FF) */
    225                  rcvr_mmc(d, 1);            /* Receive data response */
    226                  if ((d[0] & 0x1F) != 0x05)    /* If not accepted, return with error */
    227                      return 0;
    228              }
    229          
    230              return 1;
   \                     ??xmit_datablock_1:
   \   000030   1C43         MOV.W   #0x1, R12
   \                     ??xmit_datablock_2:
   \   000032   ....         JMP     ?Subroutine0
   \                     ??xmit_datablock_3:
   \   000034   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_5:
   \   000038   1324         JEQ     ??xmit_datablock_5
   \   00003A   EA3F         JMP     ??xmit_datablock_0
   \                     ??xmit_datablock_4:
   \   00003C   3D400002     MOV.W   #0x200, R13
   \   000040   CC08         MOVA    R8, R12
   \   000042   ........     CALLA   #SDCard_sendFrame
   \   000046   2D43         MOV.W   #0x2, R13
   \   000048   CC0B         MOVA    R11, R12
   \   00004A   ........     CALLA   #SDCard_readFrame
   \   00004E   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_0:
   \   000052   5E410100     MOV.B   0x1(SP), R14
   \   000056   7EF01F00     AND.B   #0x1f, R14
   \   00005A   7E900500     CMP.B   #0x5, R14
   \   00005E   E827         JEQ     ??xmit_datablock_1
   \                     ??xmit_datablock_5:
   \   000060   0C43         MOV.W   #0x0, R12
   \   000062   E73F         JMP     ??xmit_datablock_2
   \   000064   0343         NOP
    231          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   1D43         MOV.W   #0x1, R13
   \   000002   CC0B         MOVA    R11, R12
   \   000004   ........     BRA     #SDCard_readFrame
    232          
    233          
    234          
    235          /*-----------------------------------------------------------------------*/
    236          /* Send a command packet to MMC                                          */
    237          /*-----------------------------------------------------------------------*/
    238          

   \                                 In  segment CODE, align 2
    239          static
    240          BYTE send_cmd (        /* Returns command response (bit7==1:Send failed)*/
   \                     send_cmd:
    241              BYTE cmd,        /* Command byte */
    242              DWORD arg        /* Argument */
    243          )
    244          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   484C         MOV.B   R12, R8
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   0B4F         MOV.W   R15, R11
    245              BYTE n, d, buf[6];
    246          
    247          
    248              if (cmd & 0x80) {    /* ACMD<n> is the command sequense of CMD55-CMD<n> */
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   0A34         JGE     ??send_cmd_1
    249                  cmd &= 0x7F;
   \   00000E   78C08000     BIC.B   #0x80, R8
    250                  n = send_cmd(CMD55, 0);
   \   000012   0E43         MOV.W   #0x0, R14
   \   000014   0F43         MOV.W   #0x0, R15
   \   000016   7C403700     MOV.B   #0x37, R12
   \   00001A   ........     CALLA   #send_cmd
    251                  if (n > 1) return n;
   \   00001E   6C93         CMP.B   #0x2, R12
   \   000020   3D2C         JC      ??send_cmd_2
    252              }
    253          
    254              /* Select the card and wait for ready */
    255              deselect();
   \                     ??send_cmd_1:
   \   000022   ........     CALLA   #deselect
    256              if (!select()) return 0xFF;
   \   000026   ........     CALLA   #select
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   0220         JNE     ??send_cmd_3
   \   00002E   7C43         MOV.B   #0xff, R12
   \   000030   353C         JMP     ??send_cmd_2
    257          
    258              /* Send a command packet */
    259              buf[0] = 0x40 | cmd;            /* Start + Command index */
   \                     ??send_cmd_3:
   \   000032   4E48         MOV.B   R8, R14
   \   000034   7ED04000     BIS.B   #0x40, R14
   \   000038   C14E0100     MOV.B   R14, 0x1(SP)
    260              buf[1] = (BYTE)(arg >> 24);        /* Argument[31..24] */
   \   00003C   0F4B         MOV.W   R11, R15
   \   00003E   8F10         SWPB    R15
   \   000040   4E4F         MOV.B   R15, R14
   \   000042   C14E0200     MOV.B   R14, 0x2(SP)
    261              buf[2] = (BYTE)(arg >> 16);        /* Argument[23..16] */
   \   000046   C14B0300     MOV.B   R11, 0x3(SP)
    262              buf[3] = (BYTE)(arg >> 8);        /* Argument[15..8] */
   \   00004A   0F4A         MOV.W   R10, R15
   \   00004C   8F10         SWPB    R15
   \   00004E   C14F0400     MOV.B   R15, 0x4(SP)
    263              buf[4] = (BYTE)arg;                /* Argument[7..0] */
   \   000052   C14A0500     MOV.B   R10, 0x5(SP)
    264              n = 0x01;                        /* Dummy CRC + Stop */
   \   000056   5C43         MOV.B   #0x1, R12
    265              if (cmd == CMD0) n = 0x95;        /* (valid CRC for CMD0(0)) */
   \   000058   4893         CMP.B   #0x0, R8
   \   00005A   0320         JNE     ??send_cmd_4
   \   00005C   7C409500     MOV.B   #0x95, R12
   \   000060   043C         JMP     ??send_cmd_5
    266              if (cmd == CMD8) n = 0x87;        /* (valid CRC for CMD8(0x1AA)) */
   \                     ??send_cmd_4:
   \   000062   7892         CMP.B   #0x8, R8
   \   000064   0220         JNE     ??send_cmd_5
   \   000066   7C408700     MOV.B   #0x87, R12
    267              buf[5] = n;
   \                     ??send_cmd_5:
   \   00006A   C14C0600     MOV.B   R12, 0x6(SP)
    268              xmit_mmc(buf, 6);
   \   00006E   3D400600     MOV.W   #0x6, R13
   \   000072   0C41         MOV.W   SP, R12
   \   000074   1C53         ADD.W   #0x1, R12
   \   000076   ........     CALLA   #SDCard_sendFrame
    269          
    270              /* Receive command response */
    271              if (cmd == CMD12) rcvr_mmc(&d, 1);    /* Skip a stuff byte when stop reading */
   \   00007A   78900C00     CMP.B   #0xc, R8
   \   00007E   0220         JNE     ??send_cmd_6
   \   000080   ........     CALLA   #?Subroutine3
    272              n = 10;                                /* Wait for a valid response in timeout of 10 attempts */
   \                     ??send_cmd_6:
   \   000084   7A400A00     MOV.B   #0xa, R10
   \   000088   0B41         MOV.W   SP, R11
   \   00008A   0B53         ADD.W   #0x0, R11
    273              do
    274                  rcvr_mmc(&d, 1);
   \                     ??send_cmd_0:
   \   00008C   ........     CALLA   #?Subroutine2
    275              while ((d & 0x80) && --n);
   \                     ??CrossCallReturnLabel_1:
   \   000090   C1930000     CMP.B   #0x0, 0(SP)
   \   000094   0234         JGE     ??send_cmd_7
   \   000096   7A53         ADD.B   #0xff, R10
   \   000098   F923         JNE     ??send_cmd_0
    276          
    277              return d;            /* Return with the response value */
   \                     ??send_cmd_7:
   \   00009A   6C41         MOV.B   @SP, R12
   \                     ??send_cmd_2:
   \   00009C   3152         ADD.W   #0x8, SP
   \   00009E   3816         POPM.A  #0x4, R11
   \   0000A0   1001         RETA
    278          }
    279          
    280          
    281          
    282          /*--------------------------------------------------------------------------
    283          
    284             Public Functions
    285          
    286          ---------------------------------------------------------------------------*/
    287          
    288          
    289          /*-----------------------------------------------------------------------*/
    290          /* Get Disk Status                                                       */
    291          /*-----------------------------------------------------------------------*/
    292          

   \                                 In  segment CODE, align 2
    293          DSTATUS disk_status (
   \                     disk_status:
    294              BYTE drv            /* Drive number (0) */
    295          )
    296          {
    297              DSTATUS s = Stat;
   \   000000   ....5E42.... MOVX.B  &Stat, R14
    298          
    299          
    300              if (drv || !INS) {
   \   000006   4C93         CMP.B   #0x0, R12
   \   000008   0420         JNE     ??disk_status_0
   \   00000A   ....C293.... CMPX.B  #0x0, &INS
   \   000010   0320         JNE     ??disk_status_1
    301                  s = STA_NODISK | STA_NOINIT;
   \                     ??disk_status_0:
   \   000012   7E400300     MOV.B   #0x3, R14
   \   000016   023C         JMP     ??disk_status_2
    302              } else {
    303                  s &= ~STA_NODISK;
    304                  if (WP)
    305                      s |= STA_PROTECT;
    306                  else
    307                      s &= ~STA_PROTECT;
   \                     ??disk_status_1:
   \   000018   7EF0F900     AND.B   #0xf9, R14
    308              }
    309              Stat = s;
   \                     ??disk_status_2:
   \   00001C   ....C24E.... MOVX.B  R14, &Stat
    310          
    311              return s;
   \   000022   4C4E         MOV.B   R14, R12
   \   000024   1001         RETA
    312          }
    313          
    314          
    315          
    316          /*-----------------------------------------------------------------------*/
    317          /* Initialize Disk Drive                                                 */
    318          /*-----------------------------------------------------------------------*/
    319          

   \                                 In  segment CODE, align 2, keep-with-next
    320          DSTATUS disk_initialize (
   \                     disk_initialize:
    321          	BYTE drv		/* Physical drive nmuber (0) */
    322          )
    323          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   4A4C         MOV.B   R12, R10
    324          /* TI: Inserted pragma to supress IAR compiler warning incicating 'cmd'
    325           * is not used. If removed however the compile fails */
    326          #ifdef __IAR_SYSTEMS_ICC__
    327          #pragma diag_suppress=Pe550
    328          #endif
    329          #ifdef __TI_COMPILER_VERSION__
    330          #pragma diag_suppress 552
    331          #endif
    332          	BYTE n, ty, cmd, buf[4];
    333          #ifdef __IAR_SYSTEMS_ICC__
    334          #pragma diag_default=Pe550
    335          #endif
    336          //#ifdef __TI_COMPILER_VERSION__
    337          //#pragma diag_default 552
    338          //#endif
    339              UINT tmr;
    340              DSTATUS s;
    341          
    342          
    343              INIT_PORT();                /* Initialize control port */
   \   000006   ........     CALLA   #SDCard_init
    344          
    345              DLY_US(100);
   \   00000A                ////////////// Start of 2500 cycles delay.
   \   00000A   003C         JMP     ??disk_initialize_15
   \                     ??disk_initialize_15:
   \   00000C   3F403F03     MOV.W   #0x33f, R15
   \                     ??disk_initialize_14:
   \   000010   3F53         ADD.W   #0xffff, R15
   \   000012   FE2F         JC      ??disk_initialize_14
   \   000014                ////////////// End of delay code.
    346          
    347              s = disk_status(drv);        /* Check if card is in the socket */
   \   000014   4C4A         MOV.B   R10, R12
   \   000016   ........     CALLA   #disk_status
   \   00001A   4B4C         MOV.B   R12, R11
    348              if (s & STA_NODISK) return s;
   \   00001C   6CB3         BIT.B   #0x2, R12
   \   00001E   752C         JC      ??disk_initialize_6
    349          
    350              CS_H();
   \   000020   ........     CALLA   #SDCard_setCSHigh
    351              for (n = 10; n; n--) rcvr_mmc(buf, 1);    /* 80 dummy clocks */
   \   000024   78400A00     MOV.B   #0xa, R8
   \   000028   0A41         MOV.W   SP, R10
   \   00002A   0A53         ADD.W   #0x0, R10
   \                     ??disk_initialize_0:
   \   00002C   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_27:
   \   000030   7853         ADD.B   #0xff, R8
   \   000032   FC23         JNE     ??disk_initialize_0
    352          
    353              ty = 0;
   \   000034   4843         MOV.B   #0x0, R8
    354              if (send_cmd(CMD0, 0) == 1) {            /* Enter Idle state */
   \   000036   0E43         MOV.W   #0x0, R14
   \   000038   0F43         MOV.W   #0x0, R15
   \   00003A   4C43         MOV.B   #0x0, R12
   \   00003C   ........     CALLA   #send_cmd
   \   000040   5C93         CMP.B   #0x1, R12
   \   000042   5320         JNE     ??disk_initialize_4
    355                  if (send_cmd(CMD8, 0x1AA) == 1) {    /* SDv2? */
   \   000044   3E40AA01     MOV.W   #0x1aa, R14
   \   000048   0F43         MOV.W   #0x0, R15
   \   00004A   7C42         MOV.B   #0x8, R12
   \   00004C   ........     CALLA   #send_cmd
   \   000050   5C93         CMP.B   #0x1, R12
   \   000052   2B20         JNE     ??disk_initialize_7
    356                      rcvr_mmc(buf, 4);                            /* Get trailing return value of R7 resp */
   \   000054   2D42         MOV.W   #0x4, R13
   \   000056   ........     CALLA   #??Subroutine1_0
    357                      if (buf[2] == 0x01 && buf[3] == 0xAA) {        /* The card can work at vdd range of 2.7-3.6V */
   \                     ??CrossCallReturnLabel_25:
   \   00005A   D1930200     CMP.B   #0x1, 0x2(SP)
   \   00005E   4520         JNE     ??disk_initialize_4
   \   000060   F190AA000300 CMP.B   #0xaa, 0x3(SP)
   \   000066   4120         JNE     ??disk_initialize_4
    358                          for (tmr = 1000; tmr; tmr--) {            /* Wait for leaving idle state (ACMD41 with HCS bit) */
   \   000068   3940E803     MOV.W   #0x3e8, R9
    359                              if (send_cmd(ACMD41, 1UL << 30) == 0) break;
   \                     ??disk_initialize_1:
   \   00006C   0E43         MOV.W   #0x0, R14
   \   00006E   3F400040     MOV.W   #0x4000, R15
   \   000072   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_12:
   \   000076   0424         JEQ     ??disk_initialize_8
    360                              DLY_US(1000);
   \   000078   ........     CALLA   #?Subroutine8
    361                          }
   \                     ??CrossCallReturnLabel_8:
   \   00007C   3624         JEQ     ??disk_initialize_4
   \   00007E   F63F         JMP     ??disk_initialize_1
    362                          if (tmr && send_cmd(CMD58, 0) == 0) {    /* Check CCS bit in the OCR */
   \                     ??disk_initialize_8:
   \   000080   0993         CMP.W   #0x0, R9
   \   000082   3324         JEQ     ??disk_initialize_4
   \   000084   0E43         MOV.W   #0x0, R14
   \   000086   0F43         MOV.W   #0x0, R15
   \   000088   7C403A00     MOV.B   #0x3a, R12
   \   00008C   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_14:
   \   000090   2C20         JNE     ??disk_initialize_4
    363                              rcvr_mmc(buf, 4);
   \   000092   2D42         MOV.W   #0x4, R13
   \   000094   ........     CALLA   #??Subroutine1_0
    364                              ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;    /* SDv2 */
   \                     ??CrossCallReturnLabel_24:
   \   000098   F1B040000000 BIT.B   #0x40, 0(SP)
   \   00009E   022C         JC      ??disk_initialize_9
   \   0000A0   6842         MOV.B   #0x4, R8
   \   0000A2   233C         JMP     ??disk_initialize_4
   \                     ??disk_initialize_9:
   \   0000A4   78400C00     MOV.B   #0xc, R8
   \   0000A8   203C         JMP     ??disk_initialize_4
    365                          }
    366                      }
    367                  } else {                            /* SDv1 or MMCv3 */
    368                      if (send_cmd(ACMD41, 0) <= 1)     {
   \                     ??disk_initialize_7:
   \   0000AA   0E43         MOV.W   #0x0, R14
   \   0000AC   0F43         MOV.W   #0x0, R15
   \   0000AE   7C40A900     MOV.B   #0xa9, R12
   \   0000B2   ........     CALLA   #send_cmd
   \   0000B6   6C93         CMP.B   #0x2, R12
   \   0000B8   4873         SUBC.B  #0x0, R8
   \   0000BA   78E3         XOR.B   #0xff, R8
   \   0000BC   6853         ADD.B   #0x2, R8
    369                          ty = CT_SD1; cmd = ACMD41;    /* SDv1 */
    370                      } else {
    371                          ty = CT_MMC; cmd = CMD1;    /* MMCv3 */
    372                      }
    373                      for (tmr = 1000; tmr; tmr--) {            /* Wait for leaving idle state */
   \   0000BE   3940E803     MOV.W   #0x3e8, R9
    374                          if (send_cmd(ACMD41, 0) == 0) break;
   \                     ??disk_initialize_2:
   \   0000C2   0E43         MOV.W   #0x0, R14
   \   0000C4   0F43         MOV.W   #0x0, R15
   \   0000C6   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_13:
   \   0000CA   0424         JEQ     ??disk_initialize_10
    375                          DLY_US(1000);
   \   0000CC   ........     CALLA   #?Subroutine8
    376                      }
   \                     ??CrossCallReturnLabel_9:
   \   0000D0   0B24         JEQ     ??disk_initialize_11
   \   0000D2   F73F         JMP     ??disk_initialize_2
    377                      if (!tmr || send_cmd(CMD16, 512) != 0)    /* Set R/W block length to 512 */
   \                     ??disk_initialize_10:
   \   0000D4   0993         CMP.W   #0x0, R9
   \   0000D6   0824         JEQ     ??disk_initialize_11
   \   0000D8   3E400002     MOV.W   #0x200, R14
   \   0000DC   0F43         MOV.W   #0x0, R15
   \   0000DE   7C401000     MOV.B   #0x10, R12
   \   0000E2   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_15:
   \   0000E6   0124         JEQ     ??disk_initialize_4
    378                          ty = 0;
   \                     ??disk_initialize_11:
   \   0000E8   4843         MOV.B   #0x0, R8
    379                  }
    380              }
    381              CardType = ty;
   \                     ??disk_initialize_4:
   \   0000EA   ....C248.... MOVX.B  R8, &CardType
    382              deselect();
   \   0000F0   ........     CALLA   #deselect
    383          
    384              if (ty) {      /* Initialization succeded */
   \   0000F4   4893         CMP.B   #0x0, R8
   \   0000F6   0424         JEQ     ??disk_initialize_12
    385                  FAST_MODE();
   \   0000F8   ........     CALLA   #SDCard_fastMode
    386                  s &= ~STA_NOINIT;
   \   0000FC   5BC3         BIC.B   #0x1, R11
   \   0000FE   013C         JMP     ??disk_initialize_13
    387              }
    388              else {       /* Initialization failed */
    389                  s |= STA_NOINIT;
   \                     ??disk_initialize_12:
   \   000100   5BD3         BIS.B   #0x1, R11
    390              }
    391              Stat = s;
   \                     ??disk_initialize_13:
   \   000102   ....C24B.... MOVX.B  R11, &Stat
    392          
    393          
    394              return s;
   \   000108   4C4B         MOV.B   R11, R12
   \                     ??disk_initialize_6:
   \   00010A                REQUIRE ?Subroutine0
   \   00010A                // Fall through to label ?Subroutine0
    395          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000                ////////////// Start of 25000 cycles delay.
   \   000000   003C         JMP     ??Subroutine8_1
   \                     ??Subroutine8_1:
   \   000002   3F408B20     MOV.W   #0x208b, R15
   \                     ??Subroutine8_0:
   \   000006   3F53         ADD.W   #0xffff, R15
   \   000008   FE2F         JC      ??Subroutine8_0
   \   00000A                ////////////// End of delay code.
   \   00000A   3953         ADD.W   #0xffff, R9
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   ........     CALLA   #send_cmd
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   7C40A900     MOV.B   #0xa9, R12
   \   000004   ....         JMP     ?Subroutine10
   \   000006   0343         NOP
    396          
    397          
    398          
    399          /*-----------------------------------------------------------------------*/
    400          /* Read Sector(s)                                                        */
    401          /*-----------------------------------------------------------------------*/
    402          

   \                                 In  segment CODE, align 2
    403          DRESULT disk_read (
   \                     disk_read:
    404              BYTE drv,            /* Physical drive nmuber (0) */
    405              BYTE *buff,            /* Pointer to the data buffer to store read data */
    406              DWORD sector,        /* Start sector number (LBA) */
    407              BYTE count            /* Sector count (1..128) */
    408          )
    409          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CB0D         MOVA    R13, R11
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
    410              DSTATUS s;
    411          
    412          
    413              s = disk_status(drv);
   \   000008   ........     CALLA   #disk_status
    414              if (s & STA_NOINIT) return RES_NOTRDY;
   \   00000C   5CB3         BIT.B   #0x1, R12
   \   00000E   0328         JNC     ??disk_read_2
   \   000010   7C400300     MOV.B   #0x3, R12
   \   000014   393C         JMP     ??disk_read_1
   \                     ??disk_read_2:
   \   000016   5A411400     MOV.B   0x14(SP), R10
    415              if (!count) return RES_PARERR;
   \   00001A   4A93         CMP.B   #0x0, R10
   \   00001C   0220         JNE     ??disk_read_3
   \   00001E   6C42         MOV.B   #0x4, R12
   \   000020   333C         JMP     ??disk_read_1
    416              if (!(CardType & CT_BLOCK)) sector *= 512;    /* Convert LBA to byte address if needed */
   \                     ??disk_read_3:
   \   000022   ....F2B2.... BITX.B  #0x8, &CardType
   \   000028   062C         JC      ??disk_read_4
   \   00002A   0C48         MOV.W   R8, R12
   \   00002C   0D4F         MOV.W   R15, R13
   \   00002E   ........     CALLA   #?ShiftLeft32_9
   \   000032   084C         MOV.W   R12, R8
   \   000034   094D         MOV.W   R13, R9
    417          
    418              if (count == 1) {    /* Single block read */
   \                     ??disk_read_4:
   \   000036   5A93         CMP.B   #0x1, R10
   \   000038   0E48         MOV.W   R8, R14
   \   00003A   0F49         MOV.W   R9, R15
   \   00003C   0B20         JNE     ??disk_read_5
    419                  if ((send_cmd(CMD17, sector) == 0)    /* READ_SINGLE_BLOCK */
    420                      && rcvr_datablock(buff, 512))
   \   00003E   7C401100     MOV.B   #0x11, R12
   \   000042   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_18:
   \   000046   1920         JNE     ??disk_read_6
   \   000048   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_11:
   \   00004C   0C93         CMP.W   #0x0, R12
   \   00004E   1524         JEQ     ??disk_read_6
    421                      count = 0;
   \   000050   4A43         MOV.B   #0x0, R10
   \   000052   133C         JMP     ??disk_read_6
    422              }
    423              else {                /* Multiple block read */
    424                  if (send_cmd(CMD18, sector) == 0) {    /* READ_MULTIPLE_BLOCK */
   \                     ??disk_read_5:
   \   000054   7C401200     MOV.B   #0x12, R12
   \   000058   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_19:
   \   00005C   0E20         JNE     ??disk_read_6
    425                      do {
    426                          if (!rcvr_datablock(buff, 512)) break;
   \                     ??disk_read_0:
   \   00005E   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_10:
   \   000062   0C93         CMP.W   #0x0, R12
   \   000064   0424         JEQ     ??disk_read_7
    427                          buff += 512;
   \   000066   AB000002     ADDA    #0x200, R11
    428                      } while (--count);
   \   00006A   7A53         ADD.B   #0xff, R10
   \   00006C   F823         JNE     ??disk_read_0
    429                      send_cmd(CMD12, 0);                /* STOP_TRANSMISSION */
   \                     ??disk_read_7:
   \   00006E   0E43         MOV.W   #0x0, R14
   \   000070   0F43         MOV.W   #0x0, R15
   \   000072   7C400C00     MOV.B   #0xc, R12
   \   000076   ........     CALLA   #send_cmd
    430                  }
    431              }
    432              deselect();
   \                     ??disk_read_6:
   \   00007A   ........     CALLA   #deselect
    433          
    434              return count ? RES_ERROR : RES_OK;
   \   00007E   4A93         CMP.B   #0x0, R10
   \   000080   0220         JNE     ??disk_read_8
   \   000082   4C43         MOV.B   #0x0, R12
   \   000084   013C         JMP     ??disk_read_1
   \                     ??disk_read_8:
   \   000086   5C43         MOV.B   #0x1, R12
   \                     ??disk_read_1:
   \   000088   3816         POPM.A  #0x4, R11
   \   00008A   1001         RETA
    435          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine9:
   \   000000   3D400002     MOV.W   #0x200, R13
   \   000004   CC0B         MOVA    R11, R12
   \   000006   ........     BRA     #rcvr_datablock
    436          
    437          
    438          
    439          /*-----------------------------------------------------------------------*/
    440          /* Write Sector(s)                                                       */
    441          /*-----------------------------------------------------------------------*/
    442          

   \                                 In  segment CODE, align 2, keep-with-next
    443          DRESULT disk_write (
   \                     disk_write:
    444              BYTE drv,            /* Physical drive nmuber (0) */
    445              const BYTE *buff,    /* Pointer to the data to be written */
    446              DWORD sector,        /* Start sector number (LBA) */
    447              BYTE count            /* Sector count (1..128) */
    448          )
    449          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   C90D         MOVA    R13, R9
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
    450              DSTATUS s;
    451          
    452          
    453              s = disk_status(drv);
   \   000008   ........     CALLA   #disk_status
    454              if (s & STA_NOINIT) return RES_NOTRDY;
   \   00000C   5CB3         BIT.B   #0x1, R12
   \   00000E   0328         JNC     ??disk_write_2
   \   000010   7C400300     MOV.B   #0x3, R12
   \   000014   533C         JMP     ??disk_write_1
    455              if (s & STA_PROTECT) return RES_WRPRT;
   \                     ??disk_write_2:
   \   000016   6CB2         BIT.B   #0x4, R12
   \   000018   0228         JNC     ??disk_write_3
   \   00001A   6C43         MOV.B   #0x2, R12
   \   00001C   4F3C         JMP     ??disk_write_1
   \                     ??disk_write_3:
   \   00001E   58411400     MOV.B   0x14(SP), R8
    456              if (!count) return RES_PARERR;
   \   000022   4893         CMP.B   #0x0, R8
   \   000024   0220         JNE     ??disk_write_4
   \   000026   6C42         MOV.B   #0x4, R12
   \   000028   493C         JMP     ??disk_write_1
    457              if (!(CardType & CT_BLOCK)) sector *= 512;    /* Convert LBA to byte address if needed */
   \                     ??disk_write_4:
   \   00002A   ....F2B2.... BITX.B  #0x8, &CardType
   \   000030   062C         JC      ??disk_write_5
   \   000032   0C4A         MOV.W   R10, R12
   \   000034   0D4F         MOV.W   R15, R13
   \   000036   ........     CALLA   #?ShiftLeft32_9
   \   00003A   0A4C         MOV.W   R12, R10
   \   00003C   0B4D         MOV.W   R13, R11
    458          
    459              if (count == 1) {    /* Single block write */
   \                     ??disk_write_5:
   \   00003E   5893         CMP.B   #0x1, R8
   \   000040   1020         JNE     ??disk_write_6
    460                  if ((send_cmd(CMD24, sector) == 0)    /* WRITE_BLOCK */
    461                      && xmit_datablock(buff, 0xFE))
   \   000042   0E4A         MOV.W   R10, R14
   \   000044   0F4B         MOV.W   R11, R15
   \   000046   7C401800     MOV.B   #0x18, R12
   \   00004A   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_16:
   \   00004E   2F20         JNE     ??disk_write_7
   \   000050   7D40FE00     MOV.B   #0xfe, R13
   \   000054   CC09         MOVA    R9, R12
   \   000056   ........     CALLA   #xmit_datablock
   \   00005A   0C93         CMP.W   #0x0, R12
   \   00005C   2824         JEQ     ??disk_write_7
    462                      count = 0;
   \   00005E   4843         MOV.B   #0x0, R8
   \   000060   263C         JMP     ??disk_write_7
    463              }
    464              else {                /* Multiple block write */
    465                  if (CardType & CT_SDC) send_cmd(ACMD23, count);
   \                     ??disk_write_6:
   \   000062   ....5E42.... MOVX.B  &CardType, R14
   \   000068   7EB00600     BIT.B   #0x6, R14
   \   00006C   0624         JEQ     ??disk_write_8
   \   00006E   4E48         MOV.B   R8, R14
   \   000070   0F43         MOV.W   #0x0, R15
   \   000072   7C409700     MOV.B   #0x97, R12
   \   000076   ........     CALLA   #send_cmd
    466                  if (send_cmd(CMD25, sector) == 0) {    /* WRITE_MULTIPLE_BLOCK */
   \                     ??disk_write_8:
   \   00007A   0E4A         MOV.W   R10, R14
   \   00007C   0F4B         MOV.W   R11, R15
   \   00007E   7C401900     MOV.B   #0x19, R12
   \   000082   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_17:
   \   000086   1320         JNE     ??disk_write_7
    467                      do {
    468                          if (!xmit_datablock(buff, 0xFC)) break;
   \                     ??disk_write_0:
   \   000088   7D40FC00     MOV.B   #0xfc, R13
   \   00008C   CC09         MOVA    R9, R12
   \   00008E   ........     CALLA   #xmit_datablock
   \   000092   0C93         CMP.W   #0x0, R12
   \   000094   0424         JEQ     ??disk_write_9
    469                          buff += 512;
   \   000096   A9000002     ADDA    #0x200, R9
    470                      } while (--count);
   \   00009A   7853         ADD.B   #0xff, R8
   \   00009C   F523         JNE     ??disk_write_0
    471                      if (!xmit_datablock(0, 0xFD))    /* STOP_TRAN token */
   \                     ??disk_write_9:
   \   00009E   7D40FD00     MOV.B   #0xfd, R13
   \   0000A2   4C43         MOVA    #0x0, R12
   \   0000A4   ........     CALLA   #xmit_datablock
   \   0000A8   0C93         CMP.W   #0x0, R12
   \   0000AA   0120         JNE     ??disk_write_7
    472                          count = 1;
   \   0000AC   5843         MOV.B   #0x1, R8
    473                  }
    474              }
    475              deselect();
   \                     ??disk_write_7:
   \   0000AE   ........     CALLA   #deselect
    476          
    477              return count ? RES_ERROR : RES_OK;
   \   0000B2   4893         CMP.B   #0x0, R8
   \   0000B4   0220         JNE     ??disk_write_10
   \   0000B6   4C43         MOV.B   #0x0, R12
   \   0000B8   013C         JMP     ??disk_write_1
   \                     ??disk_write_10:
   \   0000BA   5C43         MOV.B   #0x1, R12
   \                     ??disk_write_1:
   \   0000BC   3816         POPM.A  #0x4, R11
   \   0000BE   1001         RETA
    478          }
    479          
    480          
    481          
    482          /*-----------------------------------------------------------------------*/
    483          /* Miscellaneous Functions                                               */
    484          /*-----------------------------------------------------------------------*/
    485          

   \                                 In  segment CODE, align 2, keep-with-next
    486          DRESULT disk_ioctl (
   \                     disk_ioctl:
    487              BYTE drv,        /* Physical drive nmuber (0) */
    488              BYTE ctrl,        /* Control code */
    489              void *buff        /* Buffer to send/receive control data */
    490          )
    491          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   CA0E         MOVA    R14, R10
    492              DRESULT res;
    493              BYTE n, csd[16];
    494              WORD cs;
    495          
    496          
    497              if (disk_status(drv) & STA_NOINIT)                    /* Check if card is in the socket */
   \   000008   ........     CALLA   #disk_status
   \   00000C   5CB3         BIT.B   #0x1, R12
   \   00000E   0328         JNC     ??disk_ioctl_1
    498                  return RES_NOTRDY;
   \   000010   7C400300     MOV.B   #0x3, R12
   \   000014   5B3C         JMP     ??disk_ioctl_2
    499          
    500              res = RES_ERROR;
   \                     ??disk_ioctl_1:
   \   000016   5B43         MOV.B   #0x1, R11
    501              switch (ctrl) {
   \   000018   4D83         SUB.B   #0x0, R13
   \   00001A   0524         JEQ     ??disk_ioctl_3
   \   00001C   5D83         SUB.B   #0x1, R13
   \   00001E   0A24         JEQ     ??disk_ioctl_4
   \   000020   6D83         SUB.B   #0x2, R13
   \   000022   4924         JEQ     ??disk_ioctl_5
   \   000024   4F3C         JMP     ??disk_ioctl_6
    502                  case CTRL_SYNC :        /* Make sure that no pending write process */
    503                      if (select()) {
   \                     ??disk_ioctl_3:
   \   000026   ........     CALLA   #select
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   4C24         JEQ     ??disk_ioctl_7
    504                          deselect();
   \   00002E   ........     CALLA   #deselect
    505                          res = RES_OK;
   \   000032   463C         JMP     ??disk_ioctl_0
    506                      }
    507                      break;
    508          
    509                  case GET_SECTOR_COUNT :    /* Get number of sectors on the disk (DWORD) */
    510                      if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
   \                     ??disk_ioctl_4:
   \   000034   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_22:
   \   000038   4620         JNE     ??disk_ioctl_7
   \   00003A   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_7:
   \   00003E   4324         JEQ     ??disk_ioctl_7
    511                          if ((csd[0] >> 6) == 1) {    /* SDC ver 2.00 */
   \   000040   5F410800     MOV.B   0x8(SP), R15
   \   000044   5E410900     MOV.B   0x9(SP), R14
   \   000048   6D41         MOV.B   @SP, R13
   \   00004A   7DF0C000     AND.B   #0xc0, R13
   \   00004E   7D904000     CMP.B   #0x40, R13
   \   000052   0820         JNE     ??disk_ioctl_8
    512                              cs= csd[9] + ((WORD)csd[8] << 8) + 1;
    513                              *(DWORD*)buff = (DWORD)cs << 10;
   \   000054   4C4E         MOV.B   R14, R12
   \   000056   8F10         SWPB    R15
   \   000058   0C5F         ADD.W   R15, R12
   \   00005A   1C53         ADD.W   #0x1, R12
   \   00005C   0D43         MOV.W   #0x0, R13
   \   00005E   ........     CALLA   #?ShiftLeft32_10
   \   000062   243C         JMP     ??disk_ioctl_9
    514                          } else {                    /* SDC ver 1.XX or MMC */
    515                              n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    516                              cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    517                              *(DWORD*)buff = (DWORD)cs << (n - 9);
   \                     ??disk_ioctl_8:
   \   000064                RPT     #0x6
   \   000064   45194F10     RRUX.B  R15
   \   000068   4C4F         MOV.B   R15, R12
   \   00006A   5F410700     MOV.B   0x7(SP), R15
   \   00006E   5F06         RLAM.W  #0x2, R15
   \   000070   0C5F         ADD.W   R15, R12
   \   000072   5F410600     MOV.B   0x6(SP), R15
   \   000076   7FF00300     AND.B   #0x3, R15
   \   00007A                RPT     #0x2
   \   00007A   41184F5F     RLAX.B  R15
   \   00007E   8F10         SWPB    R15
   \   000080   0C5F         ADD.W   R15, R12
   \   000082   1C53         ADD.W   #0x1, R12
   \   000084   0D43         MOV.W   #0x0, R13
   \   000086   5F410500     MOV.B   0x5(SP), R15
   \   00008A   7FF00F00     AND.B   #0xf, R15
   \   00008E   F1B080000A00 BIT.B   #0x80, 0xa(SP)
   \   000094   5B73         SUBC.B  #0x1, R11
   \   000096   5B53         ADD.B   #0x1, R11
   \   000098   4F5B         ADD.B   R11, R15
   \   00009A   7EF00300     AND.B   #0x3, R14
   \   00009E   4E5E         RLA.B   R14
   \   0000A0   4F5E         ADD.B   R14, R15
   \   0000A2   7F50F900     ADD.B   #0xf9, R15
   \   0000A6   4E4F         MOV.B   R15, R14
   \   0000A8   ........     CALLA   #?ShiftLeft32
   \                     ??disk_ioctl_9:
   \   0000AC   8A4C0000     MOV.W   R12, 0(R10)
   \   0000B0   8A4D0200     MOV.W   R13, 0x2(R10)
    518                          }
    519                          res = RES_OK;
   \   0000B4   053C         JMP     ??disk_ioctl_0
    520                      }
    521                      break;
    522          
    523                  case GET_BLOCK_SIZE :    /* Get erase block size in unit of sector (DWORD) */
    524                      *(DWORD*)buff = 128;
   \                     ??disk_ioctl_5:
   \   0000B6   BA4080000000 MOV.W   #0x80, 0(R10)
   \   0000BC   8A430200     MOV.W   #0x0, 0x2(R10)
    525                      res = RES_OK;
   \                     ??disk_ioctl_0:
   \   0000C0   4B43         MOV.B   #0x0, R11
    526                      break;
   \   0000C2   013C         JMP     ??disk_ioctl_7
    527          
    528                  default:
    529                      res = RES_PARERR;
   \                     ??disk_ioctl_6:
   \   0000C4   6B42         MOV.B   #0x4, R11
    530              }
    531          
    532              deselect();
   \                     ??disk_ioctl_7:
   \   0000C6   ........     CALLA   #deselect
    533          
    534              return res;
   \   0000CA   4C4B         MOV.B   R11, R12
   \                     ??disk_ioctl_2:
   \   0000CC   31501000     ADD.W   #0x10, SP
   \   0000D0   1A16         POPM.A  #0x2, R11
   \   0000D2   1001         RETA
    535          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   3D401000     MOV.W   #0x10, R13
   \   000004   0C41         MOV.W   SP, R12
   \   000006   2C52         ADD.W   #0x4, R12
   \   000008   ........     CALLA   #rcvr_datablock
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   0E43         MOV.W   #0x0, R14
   \   000002   0F43         MOV.W   #0x0, R15
   \   000004   7C400900     MOV.B   #0x9, R12
   \   000008                REQUIRE ?Subroutine10
   \   000008                // Fall through to label ?Subroutine10
    536          
    537          
    538          
    539          // KLQ
    540          

   \                                 In  segment CODE, align 2, keep-with-next
    541          uint8_t validateCSD(void)
   \                     validateCSD:
    542          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   31802000     SUB.W   #0x20, SP
    543            BYTE csd0[16], csd1[16], i;
    544            WORD sum=0;
   \   000006   0A43         MOV.W   #0x0, R10
    545          
    546            // Pull the CSD -- twice.  If the response codes are invalid, then we know the card isn't there or initialized.
    547            if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd0, 16))
   \   000008   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_20:
   \   00000C   3220         JNE     ??validateCSD_2
   \   00000E   0B41         MOV.W   SP, R11
   \   000010   3B501000     ADD.W   #0x10, R11
   \   000014   3D401000     MOV.W   #0x10, R13
   \   000018   0C4B         MOV.W   R11, R12
   \   00001A   ........     CALLA   #rcvr_datablock
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   2824         JEQ     ??validateCSD_2
    548              if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd1, 16))
   \   000022   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_21:
   \   000026   2520         JNE     ??validateCSD_2
   \   000028   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_6:
   \   00002C   2224         JEQ     ??validateCSD_2
    549              {
    550                // The response codes were good -- but maybe the SPI input was just floating low.  Let's evaluate the CSD data.
    551                // First, look for all zero or all ones.  If the SPI input is floating, these are the most likely outcomes.
    552                for(i=0;i<=15;i++)
   \   00002E   0E4B         MOV.W   R11, R14
    553                  sum += csd0[i];
   \                     ??validateCSD_0:
   \   000030   7F4E         MOV.B   @R14+, R15
   \   000032   0A5F         ADD.W   R15, R10
   \   000034   7F4E         MOV.B   @R14+, R15
   \   000036   0A5F         ADD.W   R15, R10
   \   000038   0F4B         MOV.W   R11, R15
   \   00003A   3F501000     ADD.W   #0x10, R15
   \   00003E   0E9F         CMP.W   R15, R14
   \   000040   F723         JNE     ??validateCSD_0
    554                if(!((sum == 0) || (sum == 4096)))
   \   000042   0A93         CMP.W   #0x0, R10
   \   000044   1624         JEQ     ??validateCSD_2
   \   000046   3A900010     CMP.W   #0x1000, R10
   \   00004A   1324         JEQ     ??validateCSD_2
    555                {
    556                  // The response was a mix of 0's and 1's.  Floating inputs could still do that -- but it's unlikely they'd
    557                  // produce the same pattern twice.  Compare to ensure the two are identical.
    558                  i = 0;
   \   00004C   4E43         MOV.B   #0x0, R14
   \   00004E   3F50E0FF     ADD.W   #0xffe0, R15
    559                  while(i<=15)
    560                  {
    561                    if(csd0[i] != csd1[i])
   \                     ??validateCSD_1:
   \   000052   7D4B         MOV.B   @R11+, R13
   \   000054   7D9F         CMP.B   @R15+, R13
   \   000056   0820         JNE     ??validateCSD_3
    562                      break;
    563                    i++;
   \   000058   5E53         ADD.B   #0x1, R14
   \   00005A   7D4B         MOV.B   @R11+, R13
   \   00005C   7D9F         CMP.B   @R15+, R13
   \   00005E   0420         JNE     ??validateCSD_3
   \   000060   5E53         ADD.B   #0x1, R14
    564                  }
   \   000062   7E901000     CMP.B   #0x10, R14
   \   000066   F52B         JNC     ??validateCSD_1
    565                  if(i>15)
   \                     ??validateCSD_3:
   \   000068   7E901000     CMP.B   #0x10, R14
   \   00006C   0228         JNC     ??validateCSD_2
    566                    return 1;
   \   00006E   5C43         MOV.B   #0x1, R12
   \   000070   013C         JMP     ??validateCSD_4
    567                }
    568              }
    569            return 0;
   \                     ??validateCSD_2:
   \   000072   4C43         MOV.B   #0x0, R12
   \                     ??validateCSD_4:
   \   000074   31502000     ADD.W   #0x20, SP
   \   000078   1A16         POPM.A  #0x2, R11
   \   00007A   1001         RETA
    570          }
    571          
    572          
    573          // Attempt to detect the card by commanding it to return its CSD register and evaluating it.  Returns the
    574          // result, and also updates FatFs's internal INS variable.
    575          // The proper way to detect a card is by sensing its presence on the DAT3 signal.  The EXP board doesn't
    576          // contain the necessary h/w, so this s/w method works instead.

   \                                 In  segment CODE, align 2, keep-with-next
    577          uint8_t detectCard(void)
   \                     detectCard:
    578          {
    579            // Check for a valid CSD response
    580            if(validateCSD())
   \   000000   ........     CALLA   #validateCSD
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   0524         JEQ     ??detectCard_0
    581            {
    582              disk_status(0); // Update the INS variable
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   ........     CALLA   #disk_status
    583              return 1;       // Card is present
   \   00000E   5C43         MOV.B   #0x1, R12
   \   000010   1001         RETA
    584            }
   \                     ??detectCard_0:
   \   000012   ....D243.... MOVX.B  #0x1, &INS
    585          
    586            // We didn't get a valid response.  So we now know the status is one of two things:
    587            // a) The card isn't there at all;
    588            // b) or, it was just inserted recently, and needs to be initialized
    589          
    590            INS = 0x01;          // Trick disk_initialize into thinking it's inserted...
    591            disk_initialize(0);  // Attempt to initialize it
   \   000018   4C43         MOV.B   #0x0, R12
   \   00001A   ........     CALLA   #disk_initialize
    592          
    593            INS = validateCSD(); // Try again
   \   00001E   ........     CALLA   #validateCSD
   \   000022   4F4C         MOV.B   R12, R15
   \   000024   ....C24C.... MOVX.B  R12, &INS
    594            disk_status(0);      // Update the INS variable
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   ........     CALLA   #disk_status
    595          
    596            return INS;          // 1 = card is present; 0 = not present
   \   000030   4C4F         MOV.B   R15, R12
   \   000032   1001         RETA
    597          }

   \                                 In  segment DATA20_ID, align 1, align-sorted
   \                     `?<Initializer for INS>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA20_ID, align 1, align-sorted
   \                     `?<Initializer for Stat>`:
   \   000000   01           DC8 1

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   1D43         MOV.W   #0x1, R13
   \   000002   0C41         MOV.W   SP, R12
   \   000004   2C52         ADD.W   #0x4, R12
   \   000006   ........     BRA     #SDCard_readFrame

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       6  deselect
             6 -> SDCard_readFrame
             6 -> SDCard_setCSHigh
       4  detectCard
             4 -> disk_initialize
             4 -> disk_status
             4 -> validateCSD
      24  disk_initialize
            24 -> SDCard_fastMode
            24 -> SDCard_init
            24 -> SDCard_readFrame
            24 -> SDCard_setCSHigh
            24 -> deselect
            24 -> disk_status
            24 -> send_cmd
      28  disk_ioctl
            28 -> deselect
            28 -> disk_status
            28 -> rcvr_datablock
            28 -> select
            28 -> send_cmd
      20  disk_read
            20 -> deselect
            20 -> disk_status
            20 -> rcvr_datablock
            20 -> send_cmd
       4  disk_status
      20  disk_write
            20 -> deselect
            20 -> disk_status
            20 -> send_cmd
            20 -> xmit_datablock
       4  get_fattime
      22  rcvr_datablock
            22 -> SDCard_readFrame
      14  select
            14 -> SDCard_readFrame
            14 -> SDCard_setCSLow
            14 -> deselect
      28  send_cmd
            28 -> SDCard_readFrame
            28 -> SDCard_sendFrame
            28 -> deselect
            28 -> select
            28 -> send_cmd
      44  validateCSD
            44 -> rcvr_datablock
            44 -> send_cmd
      24  xmit_datablock
            24 -> SDCard_readFrame
            24 -> SDCard_sendFrame


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for INS>
       1  ?<Initializer for Stat>
       6  ??Subroutine1_0
       6  ?Subroutine0
       2  ?Subroutine1
       8  ?Subroutine10
       8  ?Subroutine2
      10  ?Subroutine3
      14  ?Subroutine4
       8  ?Subroutine5
       8  ?Subroutine6
      16  ?Subroutine7
      14  ?Subroutine8
      10  ?Subroutine9
       1  CardType
       1  INS
       1  Stat
      14  deselect
      52  detectCard
     266  disk_initialize
     212  disk_ioctl
     140  disk_read
      38  disk_status
     192  disk_write
      10  get_fattime
      66  rcvr_datablock
      56  select
     162  send_cmd
     124  validateCSD
     102  xmit_datablock

 
 1 544 bytes in segment CODE
     2 bytes in segment DATA20_I
     2 bytes in segment DATA20_ID
     1 byte  in segment DATA20_Z
 
 1 544 bytes of CODE  memory
     2 bytes of CONST memory
     3 bytes of DATA  memory

Errors: none
Warnings: none
