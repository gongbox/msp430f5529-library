///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      06/Jun/2016  16:42:37 /
// IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430        /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  large                                                  /
//    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c       /
//    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c -D    /
//                     NDEBUG -D RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\M /
//                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA     /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\M /
//                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\          /
//                     -D__MSP430F5529__ -e --double=32 --dlib_config         /
//                     "D:\Program Files (x86)\IAR Systems\Embedded           /
//                     Workbench 6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I  /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº /
//                     ¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                    /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MS /
//                     P430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I    /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                 /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                   /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I         /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I        /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I        /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\M /
//                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I      /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\12864\ -I                             /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\oled\ -I C:\Users\615\Desktop\MSP430\ /
//                     MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\inc /
//                     \ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\ /
//                     C°æ\¹¤³ÌÄ£°å\HardWare\mpu6050\src\ -I                  /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\nokia5110\inc\ -I                     /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\nokia5110\src\ -I                     /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                        /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\LCD_API\ -I                           /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\2.2TFT\ -I                            /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\HardWare\delay\ -I                             /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\System\ -I C:\Users\615\Desktop\MSP430\MSP430F /
//                     5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\inc\ -I              /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\System\src\ -I C:\Users\615\Desktop\MSP430\MSP /
//                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\ -I                /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\User\USER\ -I C:\Users\615\Desktop\MSP430\MSP4 /
//                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I    /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Lib\uCOSII\App\ -I                             /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\ -I                         /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                            /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Lib\UCOSII\CORE\ -I                            /
//                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP4 /
//                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\        /
//                     --core=430X --data_model=large -Oh --multiplier=32     /
//                     --multiplier_location=4C0 --hw_workaround=CPU40        /
//    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹ /
//                     ¤³ÌÄ£°å\Release\List\usb.s43                           /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME usb

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero20
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK USBCTL
        PUBWEAK USBFUNADR
        PUBWEAK USBIE
        PUBWEAK USBIEPIE
        PUBWEAK USBIFG
        PUBWEAK USBOEPIE
        PUBLIC USB_InitSerialStringDescriptor
        FUNCTION USB_InitSerialStringDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 18, STACK
        PUBLIC USB_connect
        FUNCTION USB_connect,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_connectionInfo
        FUNCTION USB_connectionInfo,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_connectionState
        FUNCTION USB_connectionState,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_disable
        FUNCTION USB_disable,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_disconnect
        FUNCTION USB_disconnect,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_enable
        FUNCTION USB_enable,021201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC USB_forceRemoteWakeup
        FUNCTION USB_forceRemoteWakeup,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_getEnabledEvents
        FUNCTION USB_getEnabledEvents,0201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_init
        FUNCTION USB_init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 10, STACK
        PUBLIC USB_reset
        FUNCTION USB_reset,021201H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC USB_resume
        FUNCTION USB_resume,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_setEnabledEvents
        FUNCTION USB_setEnabledEvents,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC USB_suspend
        FUNCTION USB_suspend,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBWEAK _A_UCSCTL6_L
        PUBWEAK _A_USBCNF_L
        PUBWEAK _A_USBKEYID_L
        PUBWEAK _A_USBPHYCTL_L
        PUBWEAK _A_USBPLLCTL_L
        PUBWEAK _A_USBPLLDIVB_L
        PUBWEAK _A_USBPLLIR_L
        PUBWEAK _A_USBPWRCTL_L
        PUBWEAK abIEP0Buffer
        PUBWEAK abOEP0Buffer
        PUBLIC abUsbRequestIncomingData
        PUBLIC abUsbRequestReturnData
        PUBLIC abramSerialStringDescriptor
        PUBLIC bEnumerationStatus
        PUBLIC bFunctionSuspended
        PUBLIC bStatusAction
        PUBWEAK tEndPoint0DescriptorBlock
        PUBWEAK tInputEndPointDescriptorBlock
        PUBWEAK tOutputEndPointDescriptorBlock
        PUBWEAK tSetupPacket
        PUBLIC usbClearDeviceFeature
        FUNCTION usbClearDeviceFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbClearEndpointFeature
        FUNCTION usbClearEndpointFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbClearOEP0ByteCount
        FUNCTION usbClearOEP0ByteCount,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbDecodeAndProcessUsbRequest
        FUNCTION usbDecodeAndProcessUsbRequest,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC usbGetConfiguration
        FUNCTION usbGetConfiguration,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetConfigurationDescriptor
        FUNCTION usbGetConfigurationDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetDeviceDescriptor
        FUNCTION usbGetDeviceDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetDeviceStatus
        FUNCTION usbGetDeviceStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetEndpointStatus
        FUNCTION usbGetEndpointStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetInterface
        FUNCTION usbGetInterface,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetInterfaceStatus
        FUNCTION usbGetInterfaceStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbGetStringDescriptor
        FUNCTION usbGetStringDescriptor,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbInvalidRequest
        FUNCTION usbInvalidRequest,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbReceiveDataPacketOnEP0
        FUNCTION usbReceiveDataPacketOnEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbReceiveNextPacketOnOEP0
        FUNCTION usbReceiveNextPacketOnOEP0,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC usbSendDataPacketOnEP0
        FUNCTION usbSendDataPacketOnEP0,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSendNextPacketOnIEP0
        FUNCTION usbSendNextPacketOnIEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSendZeroLengthPacketOnIEP0
        FUNCTION usbSendZeroLengthPacketOnIEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetAddress
        FUNCTION usbSetAddress,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetConfiguration
        FUNCTION usbSetConfiguration,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetDeviceFeature
        FUNCTION usbSetDeviceFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetEndpointFeature
        FUNCTION usbSetEndpointFeature,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbSetInterface
        FUNCTION usbSetInterface,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbStallEndpoint0
        FUNCTION usbStallEndpoint0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC usbStallOEP0
        FUNCTION usbStallOEP0,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC wBytesRemainingOnIEP0
        PUBLIC wBytesRemainingOnOEP0
        PUBLIC wUsbEventMask
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H SameValue
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H SameValue
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H SameValue
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H SameValue
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN tUsbRequestList
        EXTERN USB_handleEnumCompleteEvent
        FUNCTION USB_handleEnumCompleteEvent,0200H
        EXTERN stUsbHandle
        EXTERN MscReadControl
        EXTERN MscWriteControl
        EXTERN abromConfigurationDescriptorGroup
        EXTERN abromStringDescriptor
        EXTERN abromDeviceDescriptor
        EXTERN bMscResetRequired
        EXTERN bMcsCommandSupported
        EXTERN XT2_Start
        FUNCTION XT2_Start,0202H
        EXTERN HidResetData
        FUNCTION HidResetData,0200H
        EXTERN isMSCConfigured
        EXTERN MscResetData
        FUNCTION MscResetData,0200H
        EXTERN CdcResetData
        FUNCTION CdcResetData,0200H
        EXTERN Get_TLV_Info
        FUNCTION Get_TLV_Info,0202H
        EXTERN USB_initMemcpy
        FUNCTION USB_initMemcpy,0202H
        EXTERN MscResetCtrlLun
        FUNCTION MscResetCtrlLun,0202H

// C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\USB_API\USB_Common\usb.c
//    1 // (c)2010 by Texas Instruments Incorporated, All Rights Reserved.
//    2 /*----------------------------------------------------------------------------+
//    3 |                                                                             |
//    4 |                              Texas Instruments                              |
//    5 |                                                                             |
//    6 |                          MSP430 USB-Example (CDC/HID Driver)                |
//    7 |                                                                             |
//    8 +-----------------------------------------------------------------------------+
//    9 |  Source: usb.c, File Version 1.02 2010/06/17                                |
//   10 |  Author: RSTO                                                               |
//   11 |                                                                             |
//   12 |  WHO          WHEN         WHAT                                             |
//   13 |  ---          ----------   ------------------------------------------------ |
//   14 |  RSTO         2008/09/03   born                                             |
//   15 |  RSTO         2008/12/23   enhancements of CDC API                          |
//   16 |  RSTO         2009/01/12   enhancements for USB serial number               |
//   17 |  RSTO         2009/05/15   added USB_connectionState()                      |
//   18 |  RSTO         2009/07/17   added __data16 qualifier for USB buffers         |
//   19 |  RSTO         2009/08/04   workaround for PLL start up problem              |
//   20 |  MSP,Biju     2009/10/20   Changes for composite support                    |
//   21 |  RSTO         2009/10/21   updated USB_InitSerialStringDescriptor()         |
//   22 |  RSTO         2009/11/05   updated USB_connectionState()                    |
//   23 |  MSP,Biju     2010/07/15   Updated for MSC                                  |
//   24 +----------------------------------------------------------------------------*/
//   25 /*----------------------------------------------------------------------------+
//   26 | Include files                                                               |
//   27 +----------------------------------------------------------------------------*/
//   28 
//   29 #include "../USB_Common/device.h"

        ASEGN DATA16_AN:DATA:NOROOT,0900H
// union <unnamed> __data16 _A_USBKEYID_L
_A_USBKEYID_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0902H
// union <unnamed> __data16 _A_USBCNF_L
_A_USBCNF_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0904H
// union <unnamed> __data16 _A_USBPHYCTL_L
_A_USBPHYCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0908H
// union <unnamed> __data16 _A_USBPWRCTL_L
_A_USBPWRCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0910H
// union <unnamed> __data16 _A_USBPLLCTL_L
_A_USBPLLCTL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0912H
// union <unnamed> __data16 _A_USBPLLDIVB_L
_A_USBPLLDIVB_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0914H
// union <unnamed> __data16 _A_USBPLLIR_L
_A_USBPLLIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,092eH
// unsigned char volatile __data16 USBIEPIE
USBIEPIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,092fH
// unsigned char volatile __data16 USBOEPIE
USBOEPIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093cH
// unsigned char volatile __data16 USBCTL
USBCTL:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093dH
// unsigned char volatile __data16 USBIE
USBIE:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093eH
// unsigned char volatile __data16 USBIFG
USBIFG:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,093fH
// unsigned char volatile __data16 USBFUNADR
USBFUNADR:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,016cH
// union <unnamed> __data16 _A_UCSCTL6_L
_A_UCSCTL6_L:
        DS8 2
//   30 #include "../USB_Common/types.h"              // Basic Type declarations
//   31 #include "../USB_Common/defMSP430USB.h"
//   32 #include "../USB_Common/usb.h"  // USB-specific Data Structures
//   33 #include "../USB_CDC_API/UsbCdc.h"
//   34 #include "../USB_HID_API/UsbHidReq.h"
//   35 #include "../USB_MSC_API/UsbMscScsi.h"
//   36 #include <descriptors.h>
//   37 
//   38 #include <HAL_UCS.h>
//   39 #include <HAL_TLV.h>
//   40 #include <string.h>
//   41 
//   42 /*----------------------------------------------------------------------------+
//   43  | Internal Constant Definition                                               |
//   44  +----------------------------------------------------------------------------*/
//   45 #define NO_MORE_DATA    0xFFFF
//   46 #define EPBCT_NAK       0x80
//   47 #define EPCNF_TOGLE     0x20
//   48 
//   49 #define DIRECTION_IN	0x80
//   50 #define DIRECTION_OUT	0x00
//   51 
//   52 /*----------------------------------------------------------------------------+
//   53 | Internal Variables                                                          |
//   54 +----------------------------------------------------------------------------*/
//   55 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   56 static BYTE bConfigurationNumber;      // Set to 1 when USB device has been
bConfigurationNumber:
        DS8 1
//   57                                 // configured, set to 0 when unconfigured
//   58 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   59 static BYTE bInterfaceNumber;   // interface number
bInterfaceNumber:
        DS8 1
//   60 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   61 WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
wBytesRemainingOnIEP0:
        DS8 2
//   62                                 // Holds count of bytes remaining to be
//   63                                 // transmitted by endpoint 0.  A value
//   64                                 // of 0 means that a 0-length data packet
//   65                                 // A value of 0xFFFF means that transfer
//   66                                 // is complete.
//   67 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   68 WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
wBytesRemainingOnOEP0:
        DS8 2
//   69                                 // Holds count of bytes remaining to be
//   70                                 // received by endpoint 0.  A value
//   71                                 // of 0 means that a 0-length data packet
//   72                                 // A value of 0xFFFF means that transfer
//   73                                 // is complete.
//   74 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   75 static PBYTE pbIEP0Buffer;      // A buffer pointer to input end point 0
pbIEP0Buffer:
        DS8 4
//   76                                 // Data sent back to host is copied from
//   77                                 // this pointed memory location
//   78 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   79 static PBYTE pbOEP0Buffer;      // A buffer pointer to output end point 0
pbOEP0Buffer:
        DS8 4
//   80                                 // Data sent from host is copied to
//   81                                 // this pointed memory location
//   82 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   83 static BYTE bHostAskMoreDataThanAvailable=0;
bHostAskMoreDataThanAvailable:
        DS8 1
//   84 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   85 BYTE abUsbRequestReturnData[USB_RETURN_DATA_LENGTH];
abUsbRequestReturnData:
        DS8 8

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   86 BYTE abUsbRequestIncomingData[USB_RETURN_DATA_LENGTH];
abUsbRequestIncomingData:
        DS8 8
//   87 

        RSEG DATA20_N:DATA:SORT:NOROOT(0)
//   88 __no_init BYTE abramSerialStringDescriptor[34];
abramSerialStringDescriptor:
        DS8 34
//   89 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   90 BYTE bStatusAction;
bStatusAction:
        DS8 1

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   91 BYTE bFunctionSuspended=FALSE;  // TRUE if function is suspended
bFunctionSuspended:
        DS8 1

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   92 BYTE bEnumerationStatus = 0;    //is 0 if not enumerated
bEnumerationStatus:
        DS8 1
//   93 

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   94 static BYTE bRemoteWakeup;
bRemoteWakeup:
        DS8 1
//   95 

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   96 WORD wUsbEventMask;             //used by USB_getEnabledEvents() and USB_setEnabledEvents()
wUsbEventMask:
        DS8 2
//   97 
//   98 #ifdef _MSC_
//   99 void MscResetData();
//  100 extern BOOL bMcsCommandSupported;
//  101 extern BOOL isMSCConfigured;
//  102 
//  103 extern BYTE bMscResetRequired;
//  104 #endif
//  105 
//  106 /*----------------------------------------------------------------------------+
//  107 | Global Variables                                                            |
//  108 +----------------------------------------------------------------------------*/
//  109 /*----------------------------------------------------------------------------+
//  110 | Hardware Related Structure Definition                                       |
//  111 +----------------------------------------------------------------------------*/
//  112 
//  113 #ifdef __IAR_SYSTEMS_ICC__
//  114 
//  115 #pragma location = 0x2380

        ASEGN DATA16_AN:DATA:NOROOT,02380H
//  116 __no_init tDEVICE_REQUEST __data16 tSetupPacket;
tSetupPacket:
        DS8 8
//  117 
//  118 #pragma location = 0x0920

        ASEGN DATA16_AN:DATA:NOROOT,0920H
//  119 __no_init tEDB0 __data16 tEndPoint0DescriptorBlock;
tEndPoint0DescriptorBlock:
        DS8 4
//  120 
//  121 #pragma location = 0x23C8

        ASEGN DATA16_AN:DATA:NOROOT,023c8H
//  122 __no_init tEDB __data16 tInputEndPointDescriptorBlock[7];
tInputEndPointDescriptorBlock:
        DS8 56
//  123 
//  124 #pragma location = 0x2388

        ASEGN DATA16_AN:DATA:NOROOT,02388H
//  125 __no_init tEDB __data16 tOutputEndPointDescriptorBlock[7];
tOutputEndPointDescriptorBlock:
        DS8 56
//  126 
//  127 #pragma location = 0x2378

        ASEGN DATA16_AN:DATA:NOROOT,02378H
//  128 __no_init BYTE __data16 abIEP0Buffer[EP0_MAX_PACKET_SIZE];
abIEP0Buffer:
        DS8 8
//  129 
//  130 #pragma location = 0x2370

        ASEGN DATA16_AN:DATA:NOROOT,02370H
//  131 __no_init BYTE __data16 abOEP0Buffer[EP0_MAX_PACKET_SIZE];
abOEP0Buffer:
        DS8 8

        RSEG CODE:CODE:NOROOT(1)
USB_resume:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function USB_resume
        FUNCALL USB_resume, USB_enable
        LOCFRAME CSTACK, 4, STACK
        CALLA   #USB_enable
        AND.B   #0x9f, &0x93e
        MOV.B   #0xc4, &0x93d
        JMP     ??Subroutine9_0
        NOP
          CFI EndBlock cfiBlock0
        REQUIRE USBIFG
        REQUIRE USBIE

        RSEG CODE:CODE:NOROOT(1)
USB_suspend:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function USB_suspend
        MOVX.B  #0x1, &bFunctionSuspended
        CALLA   #?Subroutine6
??CrossCallReturnLabel_5:
        BIS.B   #0x10, &0x93c
        BIC.B   #0x40, &0x93e
        BIC.W   #0x100, &0x910
        BIS.W   #0x100, &0x16c
        MOV.B   #0x20, &0x93d
        CALLA   #?Subroutine7
??CrossCallReturnLabel_11:
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock1
        REQUIRE _A_USBKEYID_L
        REQUIRE USBCTL
        REQUIRE USBIFG
        REQUIRE _A_USBPLLCTL_L
        REQUIRE _A_UCSCTL6_L
        REQUIRE USBIE

        RSEG CODE:CODE:NOROOT(1)
USB_connectionState:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function USB_connectionState
        BIT.W   #0x8, &0x908
        JC      ??USB_connectionState_0
        MOV.B   #0x80, R12
        RETA
??USB_connectionState_0:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_1
        BIT.W   #0x2, &0x902
        JC      ??USB_connectionState_1
        MOV.B   #0x81, R12
        RETA
??USB_connectionState_1:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_2
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_2
        CALLA   #?Subroutine8
??CrossCallReturnLabel_16:
        JNE     ??USB_connectionState_2
        CMPX.B  #0x1, &bFunctionSuspended
        JEQ     ??USB_connectionState_2
        MOV.B   #0x83, R12
        RETA
??USB_connectionState_2:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_3
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_3
        CALLA   #?Subroutine8
??CrossCallReturnLabel_17:
        JEQ     ??USB_connectionState_3
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionState_3
        MOV.B   #0x87, R12
        RETA
??USB_connectionState_3:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_4
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_4
        CALLA   #?Subroutine8
??CrossCallReturnLabel_18:
        JNE     ??USB_connectionState_4
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionState_4
        MOV.B   #0x84, R12
        RETA
??USB_connectionState_4:
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionState_5
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionState_5
        CALLA   #?Subroutine8
??CrossCallReturnLabel_19:
        JEQ     ??USB_connectionState_5
        MOV.B   #0x82, R12
        RETA
??USB_connectionState_5:
        MOV.B   #0x86, R12
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L

        RSEG CODE:CODE:NOROOT(1)
USB_connectionInfo:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function USB_connectionInfo
        MOV.B   #0x0, R12
        BIT.W   #0x8, &0x908
        JNC     ??USB_connectionInfo_0
        MOV.B   #0x1, R12
??USB_connectionInfo_0:
        CALLA   #?Subroutine8
??CrossCallReturnLabel_20:
        JNE     ??USB_connectionInfo_1
        BIS.B   #0x20, R12
??USB_connectionInfo_1:
        BIT.W   #0x2, &0x902
        JNC     ??USB_connectionInfo_2
        BIS.B   #0x40, R12
??USB_connectionInfo_2:
        CMPX.B  #0x1, &bFunctionSuspended
        JNE     ??USB_connectionInfo_3
        BIS.B   #0x8, R12
        RETA
??USB_connectionInfo_3:
        BIS.B   #0x10, R12
        RETA
          CFI EndBlock cfiBlock3
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L

        RSEG CODE:CODE:NOROOT(1)
?Subroutine8:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function USB_connectionState
          CFI Conditional ??CrossCallReturnLabel_16
          CFI CFA SP+8
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function USB_connectionState
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_17
          CFI (cfiCond5) CFA SP+8
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function USB_connectionState
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_18
          CFI (cfiCond6) CFA SP+8
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function USB_connectionState
          CFI (cfiCond7) Conditional ??CrossCallReturnLabel_19
          CFI (cfiCond7) CFA SP+8
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function USB_connectionInfo
          CFI (cfiCond8) Conditional ??CrossCallReturnLabel_20
          CFI (cfiCond8) CFA SP+8
          CFI Block cfiPicker9 Using cfiCommon1
          CFI (cfiPicker9) NoFunction
          CFI (cfiPicker9) Picker
        CMPX.B  #0x1, &bEnumerationStatus
        RETA
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiPicker9

        RSEG CODE:CODE:NOROOT(1)
USB_forceRemoteWakeup:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function USB_forceRemoteWakeup
        CMPX.B  #0x0, &bFunctionSuspended
        JNE     ??USB_forceRemoteWakeup_0
        MOV.B   #0x10, R12
        RETA
??USB_forceRemoteWakeup_0:
        CMPX.B  #0x1, &bRemoteWakeup
        JNE     ??USB_forceRemoteWakeup_1
        BIS.B   #0x20, &0x93c
        MOV.B   #0x0, R12
        RETA
??USB_forceRemoteWakeup_1:
        MOV.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock10
        REQUIRE USBCTL

        RSEG CODE:CODE:NOROOT(1)
USB_disconnect:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function USB_disconnect
        CALLA   #?Subroutine6
??CrossCallReturnLabel_6:
        BIC.W   #0x2, &0x902
        BIC.W   #0x400, &0x908
          CFI EndBlock cfiBlock11
        REQUIRE ?Subroutine0
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPWRCTL_L
        // Fall through to label ?Subroutine0
//  132 
//  133 #pragma location = OEP1_X_BUFFER_ADDRESS
//  134  __no_init BYTE __data16 pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  135 
//  136 #pragma location = OEP1_Y_BUFFER_ADDRESS
//  137  __no_init BYTE __data16 pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  138 
//  139 #pragma location = IEP1_X_BUFFER_ADDRESS
//  140  __no_init BYTE __data16 pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  141 
//  142 #pragma location = IEP1_Y_BUFFER_ADDRESS
//  143  __no_init BYTE __data16 pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  144 
//  145 #pragma location = OEP2_X_BUFFER_ADDRESS
//  146  __no_init BYTE __data16 pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  147 
//  148 #pragma location = OEP2_Y_BUFFER_ADDRESS
//  149  __no_init BYTE __data16 pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  150 
//  151 #pragma location = IEP2_X_BUFFER_ADDRESS
//  152  __no_init BYTE __data16 pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  153 
//  154 #pragma location = IEP2_Y_BUFFER_ADDRESS
//  155  __no_init BYTE __data16 pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  156 
//  157 #pragma location = OEP3_X_BUFFER_ADDRESS
//  158 __no_init BYTE __data16 pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  159 
//  160 #pragma location = OEP3_Y_BUFFER_ADDRESS
//  161 __no_init BYTE __data16 pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  162 
//  163 #pragma location = IEP3_X_BUFFER_ADDRESS
//  164 __no_init BYTE __data16 pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  165 
//  166 #pragma location = IEP3_Y_BUFFER_ADDRESS
//  167 __no_init BYTE __data16 pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  168 
//  169 #pragma location = OEP4_X_BUFFER_ADDRESS
//  170 __no_init BYTE __data16 pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  171 
//  172 #pragma location = OEP4_Y_BUFFER_ADDRESS
//  173 __no_init BYTE __data16 pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  174 
//  175 #pragma location = IEP4_X_BUFFER_ADDRESS
//  176 __no_init BYTE __data16 pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  177 
//  178 #pragma location = IEP4_Y_BUFFER_ADDRESS
//  179 __no_init BYTE __data16 pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  180 
//  181 #pragma location = OEP5_X_BUFFER_ADDRESS
//  182 __no_init BYTE __data16 pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  183 
//  184 #pragma location = OEP5_Y_BUFFER_ADDRESS
//  185 __no_init BYTE __data16 pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  186 
//  187 #pragma location = IEP5_X_BUFFER_ADDRESS
//  188 __no_init BYTE __data16 pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  189 
//  190 #pragma location = IEP5_Y_BUFFER_ADDRESS
//  191 __no_init BYTE __data16 pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  192 
//  193 #pragma location = OEP6_X_BUFFER_ADDRESS
//  194 __no_init BYTE __data16 pbXBufferAddressEp6[EP_MAX_PACKET_SIZE];
//  195 
//  196 #pragma location = OEP6_Y_BUFFER_ADDRESS
//  197 __no_init BYTE __data16 pbYBufferAddressEp6[EP_MAX_PACKET_SIZE];
//  198 
//  199 #pragma location = IEP6_X_BUFFER_ADDRESS
//  200 __no_init BYTE __data16 pbXBufferAddressEp86[EP_MAX_PACKET_SIZE];
//  201 
//  202 #pragma location = IEP6_Y_BUFFER_ADDRESS
//  203 __no_init BYTE __data16 pbYBufferAddressEp86[EP_MAX_PACKET_SIZE];
//  204 
//  205 #pragma location = OEP7_X_BUFFER_ADDRESS
//  206 __no_init BYTE __data16 pbXBufferAddressEp7[EP_MAX_PACKET_SIZE];
//  207 
//  208 #pragma location = OEP7_Y_BUFFER_ADDRESS
//  209 __no_init BYTE __data16 pbYBufferAddressEp7[EP_MAX_PACKET_SIZE];
//  210 
//  211 #pragma location = IEP7_X_BUFFER_ADDRESS
//  212 __no_init BYTE __data16 pbXBufferAddressEp87[EP_MAX_PACKET_SIZE];
//  213 
//  214 #pragma location = IEP7_Y_BUFFER_ADDRESS
//  215 __no_init BYTE __data16 pbYBufferAddressEp87[EP_MAX_PACKET_SIZE];
//  216 
//  217 
//  218 
//  219 #endif
//  220 
//  221 #ifdef __TI_COMPILER_VERSION__
//  222 extern __no_init tDEVICE_REQUEST tSetupPacket;
//  223 extern __no_init tEDB0 tEndPoint0DescriptorBlock;
//  224 extern __no_init tEDB tInputEndPointDescriptorBlock[7];
//  225 extern __no_init tEDB tOutputEndPointDescriptorBlock[7];
//  226 extern __no_init BYTE abIEP0Buffer[EP0_MAX_PACKET_SIZE];
//  227 extern __no_init BYTE abOEP0Buffer[EP0_MAX_PACKET_SIZE];
//  228 extern __no_init BYTE pbXBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  229 extern __no_init BYTE pbYBufferAddressEp1[EP_MAX_PACKET_SIZE];
//  230 extern __no_init BYTE pbXBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  231 extern __no_init BYTE pbYBufferAddressEp81[EP_MAX_PACKET_SIZE];
//  232 extern __no_init BYTE pbXBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  233 extern __no_init BYTE pbYBufferAddressEp2[EP_MAX_PACKET_SIZE];
//  234 extern __no_init BYTE pbXBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  235 extern __no_init BYTE pbYBufferAddressEp82[EP_MAX_PACKET_SIZE];
//  236 extern __no_init BYTE pbXBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  237 extern __no_init BYTE pbYBufferAddressEp3[EP_MAX_PACKET_SIZE];
//  238 extern __no_init BYTE pbXBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  239 extern __no_init BYTE pbYBufferAddressEp83[EP_MAX_PACKET_SIZE];
//  240 
//  241 extern __no_init BYTE pbXBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  242 extern __no_init BYTE pbYBufferAddressEp4[EP_MAX_PACKET_SIZE];
//  243 extern __no_init BYTE pbXBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  244 extern __no_init BYTE pbYBufferAddressEp84[EP_MAX_PACKET_SIZE];
//  245 
//  246 extern __no_init BYTE pbXBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  247 extern __no_init BYTE pbYBufferAddressEp5[EP_MAX_PACKET_SIZE];
//  248 extern __no_init BYTE pbXBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  249 extern __no_init BYTE pbYBufferAddressEp85[EP_MAX_PACKET_SIZE];
//  250 
//  251 #endif
//  252 
//  253 VOID CdcResetData();
//  254 VOID HidResetData();
//  255 
//  256 VOID USB_InitSerialStringDescriptor(VOID);
//  257 VOID USB_initMemcpy(VOID);
//  258 
//  259 //----------------------------------------------------------------------------
//  260 BYTE USB_init(VOID)
//  261 {
//  262     WORD bGIE  = __get_SR_register() &GIE;  //save interrupt status
//  263     // atomic operation - disable interrupts
//  264     __disable_interrupt();               // Disable global interrupts
//  265 
//  266     // configuration of USB module
//  267     USBKEYPID   =     0x9628;            // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  268 
//  269     USBPHYCTL   =     PUSEL;             // use DP and DM as USB terminals (not needed because an external PHY is connected to port 9)
//  270 
//  271     USBPWRCTL   =     VUSBEN + SLDOAON; // enable primary and secondary LDO (3.3 and 1.8 V)
//  272     {
//  273     	volatile unsigned int i;
//  274     	for (i =0; i < USB_MCLK_FREQ/1000*2/10; i++);      // wait some time for LDOs (1ms delay)
//  275     }
//  276 
//  277     USBPWRCTL   =   VUSBEN + SLDOAON + VBONIE;  // enable interrupt VBUSon
//  278     USBKEYPID   =    0x9600;            // access to configuration registers disabled
//  279 
//  280     //reset events mask
//  281     wUsbEventMask = 0;
//  282 
//  283     //init Serial Number
//  284 #if (USB_STR_INDEX_SERNUM != 0)
//  285     USB_InitSerialStringDescriptor();
//  286 #endif
//  287 
//  288     // init memcpy() function: DMA or non-DMA
//  289     USB_initMemcpy();
//  290 #ifdef _MSC_
//  291     MscResetCtrlLun();
//  292 #endif
//  293 
//  294     __bis_SR_register(bGIE); //restore interrupt status
//  295     return kUSB_succeed;
//  296 }
//  297 
//  298 //----------------------------------------------------------------------------
//  299 // This function will be compiled only if
//  300 #if (USB_STR_INDEX_SERNUM != 0)
//  301 VOID USB_InitSerialStringDescriptor(VOID)
//  302 {
//  303     BYTE i,j,hexValue;
//  304     PBYTE pbSerNum;
//  305     BYTE bBytes;
//  306 
//  307     j=1;                   // we start with second byte, first byte (lenght) will be filled later
//  308     pbSerNum=0;
//  309     abramSerialStringDescriptor[j++] = DESC_TYPE_STRING;
//  310 
//  311     // TLV access Function Call
//  312     Get_TLV_Info(TLV_DIERECORD, 0, (uint8_t *)&bBytes, (uint16_t **)&pbSerNum); //The die record used for serial number
//  313     if (bBytes == 0)    // no serial number available
//  314     {
//  315         // use 00 as serial number = no serial number available
//  316         abramSerialStringDescriptor[0] = 4;      //length
//  317         abramSerialStringDescriptor[j++] = 0;    // no serial number available
//  318         abramSerialStringDescriptor[j++] = 0;    // no serial number available
//  319     }
//  320     else
//  321     {
//  322         for(i=0; (i<bBytes)&&(i<8); i++,pbSerNum++)
//  323         {
//  324             hexValue = (*pbSerNum & 0xF0)>> 4;
//  325             if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
//  326             else abramSerialStringDescriptor[j++] = (hexValue + 55);
//  327             abramSerialStringDescriptor[j++] = 0x00;  // needed for UNI-Code
//  328 
//  329             hexValue = (*pbSerNum & 0x0F);
//  330             if(hexValue < 10 ) abramSerialStringDescriptor[j++] = (hexValue + '0');
//  331             else abramSerialStringDescriptor[j++] = (hexValue + 55);
//  332             abramSerialStringDescriptor[j++] = 0x00;    // needed for UNI-Code
//  333         }
//  334         abramSerialStringDescriptor[0] = i*4 +2;        // calculate the length
//  335     }
//  336 }
//  337 #endif
//  338 
//  339 //----------------------------------------------------------------------------
//  340 
//  341 BYTE USB_enable()
//  342 {
//  343     volatile unsigned int i;
//  344     volatile unsigned int j = 0;
//  345 
//  346     if (!(USBPWRCTL & USBBGVBV))            // check USB Bandgap and VBUS valid
//  347     {
//  348         return kUSB_generalError;
//  349     }
//  350 
//  351     if ((USBCNF & USB_EN) &&
//  352         (USBPLLCTL & UPLLEN))
//  353     {
//  354         return kUSB_succeed;                // exit if PLL is already enalbed
//  355     }
//  356 
//  357     USBKEYPID = 0x9628;                     // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  358     XT2_Start(XT2DRIVE_3);
//  359     USBPLLDIVB = USB_XT_FREQ;               // Settings desired frequency
//  360 
//  361     if (USB_PLL_XT == 2)
//  362     {
//  363         USBPLLCTL = UPCS0 + UPFDEN + UPLLEN;// Select XT2 as Ref / Select PLL for USB / Discrim. on, enable PLL
//  364     }
//  365     else
//  366     {
//  367         USBPLLCTL = UPFDEN + UPLLEN;        // Select XT1 as Ref / Select PLL for USB / Discrim. on, enable PLL
//  368     }
//  369 
//  370     //Wait some time till PLL is settled
//  371     do
//  372     {
//  373         USBPLLIR    =     0x0000;           // make sure no interrupts can occur on PLL-module
//  374 
//  375 #ifdef __MSP430F6638
//  376         //wait 1 ms till enable USB
//  377         for (i =0; i < USB_MCLK_FREQ/1000*1/10; i++);
//  378 #else
//  379         //wait 1/2 ms till enable USB
//  380         for (i =0; i < USB_MCLK_FREQ/1000* 1/2 /10; i++);
//  381 #endif
//  382 
//  383         if (j++ > 10)
//  384         {
//  385             USBKEYPID   =    0x9600;        // access to configuration registers disabled
//  386             return kUSB_generalError;
//  387         }
//  388     }while (USBPLLIR != 0);
//  389 
//  390     USBCNF     |=    USB_EN;                // enable USB module
//  391     USBKEYPID   =    0x9600;                // access to configuration registers disabled
//  392     return kUSB_succeed;
//  393 }
//  394 
//  395 /*
//  396 Disables the USB module and PLL.
//  397 */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI NoFunction
//  398 BYTE USB_disable(VOID)
//  399 {
//  400     USBKEYPID = 0x9628;        // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  401     USBCNF    = 0;             // disable USB module
//  402     USBPLLCTL &= ~UPLLEN;      // disable PLL
//  403     USBKEYPID = 0x9600;        // access to configuration registers disabled
        CALLA   #?Subroutine7
//  404     bEnumerationStatus = 0x00; // device is not enumerated
??CrossCallReturnLabel_15:
        MOVX.B  #0x0, &bEnumerationStatus
          CFI EndBlock cfiBlock12
//  405     bFunctionSuspended = FALSE;// device is not suspended
        REQUIRE ??Subroutine9_0
        // Fall through to label ??Subroutine9_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine9_0:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI NoFunction
        MOVX.B  #0x0, &bFunctionSuspended
//  406     return kUSB_succeed;
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(1)
USB_connect:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function USB_connect
        CALLA   #?Subroutine6
??CrossCallReturnLabel_7:
        BIS.W   #0x2, &0x902
        BIS.W   #0x400, &0x908
        CALLA   #?Subroutine7
??CrossCallReturnLabel_12:
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock14
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPWRCTL_L

        RSEG CODE:CODE:NOROOT(1)
?Subroutine7:
          CFI Block cfiCond15 Using cfiCommon0
          CFI Function USB_enable
          CFI Conditional ??USB_enable_3
          CFI CFA SP+12
          CFI Block cfiCond16 Using cfiCommon0
          CFI (cfiCond16) Function USB_enable
          CFI (cfiCond16) Conditional ??USB_enable_5
          CFI (cfiCond16) CFA SP+12
          CFI Block cfiCond17 Using cfiCommon0
          CFI (cfiCond17) Function USB_suspend
          CFI (cfiCond17) Conditional ??CrossCallReturnLabel_11
          CFI (cfiCond17) CFA SP+8
          CFI Block cfiCond18 Using cfiCommon0
          CFI (cfiCond18) Function USB_disconnect
          CFI (cfiCond18) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond18) CFA SP+8
          CFI Block cfiCond19 Using cfiCommon0
          CFI (cfiCond19) Function USB_disable
          CFI (cfiCond19) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond19) CFA SP+8
          CFI Block cfiCond20 Using cfiCommon0
          CFI (cfiCond20) Function USB_connect
          CFI (cfiCond20) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond20) CFA SP+8
          CFI Block cfiCond21 Using cfiCommon0
          CFI (cfiCond21) Function USB_reset
          CFI (cfiCond21) Conditional ??CrossCallReturnLabel_13
          CFI (cfiCond21) R10L Frame(CFA, -12)
          CFI (cfiCond21) R10H Frame(CFA, -10)
          CFI (cfiCond21) R11L Frame(CFA, -8)
          CFI (cfiCond21) R11H Frame(CFA, -6)
          CFI (cfiCond21) CFA SP+16
          CFI Block cfiCond22 Using cfiCommon0
          CFI (cfiCond22) Function USB_init
          CFI (cfiCond22) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond22) R10L Frame(CFA, -8)
          CFI (cfiCond22) R10H Frame(CFA, -6)
          CFI (cfiCond22) CFA SP+14
          CFI Block cfiPicker23 Using cfiCommon1
          CFI (cfiPicker23) NoFunction
          CFI (cfiPicker23) Picker
        MOV.W   #0x9600, &0x900
        RETA
          CFI EndBlock cfiCond15
          CFI EndBlock cfiCond16
          CFI EndBlock cfiCond17
          CFI EndBlock cfiCond18
          CFI EndBlock cfiCond19
          CFI EndBlock cfiCond20
          CFI EndBlock cfiCond21
          CFI EndBlock cfiCond22
          CFI EndBlock cfiPicker23

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond24 Using cfiCommon0
          CFI Function USB_enable
          CFI Conditional ??CrossCallReturnLabel_4
          CFI CFA SP+12
          CFI Block cfiCond25 Using cfiCommon0
          CFI (cfiCond25) Function USB_suspend
          CFI (cfiCond25) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond25) CFA SP+8
          CFI Block cfiCond26 Using cfiCommon0
          CFI (cfiCond26) Function USB_disconnect
          CFI (cfiCond26) Conditional ??CrossCallReturnLabel_6
          CFI (cfiCond26) CFA SP+8
          CFI Block cfiCond27 Using cfiCommon0
          CFI (cfiCond27) Function USB_connect
          CFI (cfiCond27) Conditional ??CrossCallReturnLabel_7
          CFI (cfiCond27) CFA SP+8
          CFI Block cfiCond28 Using cfiCommon0
          CFI (cfiCond28) Function USB_reset
          CFI (cfiCond28) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond28) R10L Frame(CFA, -12)
          CFI (cfiCond28) R10H Frame(CFA, -10)
          CFI (cfiCond28) R11L Frame(CFA, -8)
          CFI (cfiCond28) R11H Frame(CFA, -6)
          CFI (cfiCond28) CFA SP+16
          CFI Block cfiCond29 Using cfiCommon0
          CFI (cfiCond29) Function USB_disable
          CFI (cfiCond29) Conditional ??CrossCallReturnLabel_9
          CFI (cfiCond29) CFA SP+8
          CFI Block cfiCond30 Using cfiCommon0
          CFI (cfiCond30) Function USB_init
          CFI (cfiCond30) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond30) R10L Frame(CFA, -8)
          CFI (cfiCond30) R10H Frame(CFA, -6)
          CFI (cfiCond30) CFA SP+14
          CFI Block cfiPicker31 Using cfiCommon1
          CFI (cfiPicker31) NoFunction
          CFI (cfiPicker31) Picker
        MOV.W   #0x9628, &0x900
        RETA
          CFI EndBlock cfiCond24
          CFI EndBlock cfiCond25
          CFI EndBlock cfiCond26
          CFI EndBlock cfiCond27
          CFI EndBlock cfiCond28
          CFI EndBlock cfiCond29
          CFI EndBlock cfiCond30
          CFI EndBlock cfiPicker31

        RSEG CODE:CODE:NOROOT(1)
USB_reset:
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function USB_reset
        FUNCALL USB_reset, HidResetData
        LOCFRAME CSTACK, 12, STACK
        FUNCALL USB_reset, MscResetData
        LOCFRAME CSTACK, 12, STACK
        FUNCALL USB_reset, CdcResetData
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        CALLA   #?Subroutine6
??CrossCallReturnLabel_8:
        MOVX.B  #0x0, &bEnumerationStatus
        MOVX.B  #0x0, &bFunctionSuspended
        MOVX.B  #0x0, &bRemoteWakeup
        MOVX.B  #0x0, &bConfigurationNumber
        MOVX.B  #0x0, &bInterfaceNumber
        MOV.B   #0x0, &0x93c
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
        MOVX.W  #0xffff, &wBytesRemainingOnOEP0
        MOVX.B  #0x0, &bStatusAction
        MOV.B   #0x0, &0x93f
        MOV.B   #0x80, R15
        MOV.B   R15, &0x921
        MOV.B   R15, &0x923
        MOV.B   #0x8c, &0x920
        MOV.B   #0x8c, &0x922
        MOV.B   #0x1b, &0x92f
        MOV.B   #0x1f, &0x92e
        MOVA    #stUsbHandle + 4, R13
        MOV.B   #0x40, R10
        MOV.W   #0xe400, R11
??USB_reset_0:
        MOV.B   -0x2(R13), R12
        RLAM.W  #0x3, R12
        MOV.B   #0x94, 0x23c8(R12)
        MOV.W   R11, R14
        ADD.W   0x8(R13), R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x23c9(R12)
        MOV.W   R11, R14
        ADD.W   0xa(R13), R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x23cd(R12)
        MOV.B   R15, 0x23ca(R12)
        MOV.B   R15, 0x23ce(R12)
        MOV.B   R10, 0x23cf(R12)
        MOV.B   #0x94, 0x2388(R12)
        MOV.W   R11, R14
        ADD.W   0x4(R13), R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x2389(R12)
        MOV.W   R11, R14
        ADD.W   0x6(R13), R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x238d(R12)
        MOV.B   #0x0, 0x238a(R12)
        MOV.B   #0x0, 0x238e(R12)
        MOV.B   R10, 0x238f(R12)
        CMP.B   #0x2, -0x1(R13)
        JNE     ??USB_reset_1
        MOV.B   #0x94, 0x23c0(R12)
        MOV.W   R11, R14
        ADD.W   @R13, R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x23c1(R12)
        MOV.W   R11, R14
        ADD.W   0x2(R13), R14
        RRUM.W  #0x3, R14
        MOV.B   R14, 0x23c5(R12)
        MOV.B   R15, 0x23c2(R12)
        MOV.B   R15, 0x23c6(R12)
        MOV.B   R10, 0x23c7(R12)
??USB_reset_1:
        ADDA    #0x10, R13
        CMPA    #stUsbHandle + 52, R13
        JNE     ??USB_reset_0
        CALLA   #HidResetData
        MOVX.W  #0x0, &isMSCConfigured
        CALLA   #MscResetData
        CALLA   #CdcResetData
        MOV.B   R10, &0x93c
        MOV.B   #0x0, &0x93e
        MOV.B   #0xc4, &0x93d
        CALLA   #?Subroutine7
??CrossCallReturnLabel_13:
        MOV.B   #0x0, R12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock32
        REQUIRE _A_USBKEYID_L
        REQUIRE USBCTL
        REQUIRE USBFUNADR
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE USBOEPIE
        REQUIRE USBIEPIE
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
        REQUIRE USBIFG
        REQUIRE USBIE

        RSEG CODE:CODE:NOROOT(1)
USB_getEnabledEvents:
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function USB_getEnabledEvents
        MOVX.W  &wUsbEventMask, R12
        RETA
          CFI EndBlock cfiBlock33

        RSEG CODE:CODE:NOROOT(1)
USB_setEnabledEvents:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function USB_setEnabledEvents
        MOVX.W  R12, &wUsbEventMask
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock34

        RSEG CODE:CODE:REORDER:NOROOT(1)
USB_disable:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function USB_disable
        CALLA   #?Subroutine6
??CrossCallReturnLabel_9:
        MOV.W   #0x0, &0x902
        BIC.W   #0x100, &0x910
        JMP     ?Subroutine0
        NOP
          CFI EndBlock cfiBlock35
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPLLCTL_L

        RSEG CODE:CODE:REORDER:NOROOT(1)
USB_init:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function USB_init
        FUNCALL USB_init, USB_InitSerialStringDescriptor
        LOCFRAME CSTACK, 10, STACK
        FUNCALL USB_init, USB_initMemcpy
        LOCFRAME CSTACK, 10, STACK
        FUNCALL USB_init, MscResetCtrlLun
        LOCFRAME CSTACK, 10, STACK
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x2, SP
          CFI CFA SP+10
        MOV.W   SR, R10
        AND.W   #0x8, R10
        DINT
        NOP
        CALLA   #?Subroutine6
??CrossCallReturnLabel_10:
        MOV.W   #0x80, &0x904
        MOV.W   #0x840, &0x908
        MOV.W   #0x0, 0(SP)
        JMP     ??USB_init_1
??USB_init_0:
        MOV.W   @SP, R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0(SP)
??USB_init_1:
        CMP.W   #0x1388, 0(SP)
        JNC     ??USB_init_0
        MOV.W   #0xa40, &0x908
        CALLA   #?Subroutine7
??CrossCallReturnLabel_14:
        MOVX.W  #0x0, &wUsbEventMask
        CALLA   #USB_InitSerialStringDescriptor
        CALLA   #USB_initMemcpy
        CALLA   #MscResetCtrlLun
        BIS.W   R10, SR
        MOV.B   #0x0, R12
        ADD.W   #0x2, SP
          CFI CFA SP+8
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock36
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBPHYCTL_L
        REQUIRE _A_USBPWRCTL_L

        RSEG CODE:CODE:REORDER:NOROOT(1)
USB_InitSerialStringDescriptor:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function USB_InitSerialStringDescriptor
        FUNCALL USB_InitSerialStringDescriptor, Get_TLV_Info
        LOCFRAME CSTACK, 18, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x6, SP
          CFI CFA SP+18
        MOVX.A  #0x0, 0x2(SP)
        MOVA    #abramSerialStringDescriptor, R11
        MOV.B   #0x3, 0x1(R11)
        MOV.B   #0x2, R10
        MOV.W   SP, R15
        ADD.W   #0x2, R15
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.B   #0x0, R13
        MOV.B   #0x8, R12
        CALLA   #Get_TLV_Info
        CMP.B   #0x0, 0(SP)
        JNE     ??USB_InitSerialStringDescriptor_5
        MOV.B   #0x4, 0(R11)
        MOV.B   #0x0, 0x2(R11)
        MOV.B   #0x0, 0x3(R11)
        JMP     ??USB_InitSerialStringDescriptor_6
??USB_InitSerialStringDescriptor_5:
        MOV.B   #0x0, R14
??USB_InitSerialStringDescriptor_0:
        MOVA    0x2(SP), R15
        MOV.B   @R15, R13
        RPT     #0x4
        RRUX.B  R13
        MOV.B   R10, R15
        ADD.B   #0x1, R15
        CALLA   #?Subroutine5
??CrossCallReturnLabel_2:
        MOVX.B  R13, abramSerialStringDescriptor(R10)
        MOV.B   R15, R10
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
        MOVA    0x2(SP), R15
        MOV.B   #0xf, R13
        AND.B   @R15, R13
        MOV.B   R10, R12
        ADD.B   #0x1, R12
        MOV.B   R10, R15
        CALLA   #?Subroutine5
??CrossCallReturnLabel_3:
        MOVX.B  R13, abramSerialStringDescriptor(R15)
        MOV.B   R12, R10
        MOV.B   R10, R15
        MOVX.B  #0x0, abramSerialStringDescriptor(R15)
        ADD.B   #0x1, R10
        ADD.B   #0x1, R14
        MOVA    0x2(SP), R15
        ADDA    #0x1, R15
        MOVA    R15, 0x2(SP)
        CMP.B   @SP, R14
        JC      ??USB_InitSerialStringDescriptor_7
        CMP.B   #0x8, R14
        JNC     ??USB_InitSerialStringDescriptor_0
??USB_InitSerialStringDescriptor_7:
        RPT     #0x2
        RLAX.B  R14
        ADD.B   #0x2, R14
        MOV.B   R14, 0(R11)
??USB_InitSerialStringDescriptor_6:
        ADD.W   #0x6, SP
          CFI CFA SP+12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock37

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine5:
          CFI Block cfiCond38 Using cfiCommon0
          CFI Function USB_InitSerialStringDescriptor
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+22
          CFI Block cfiCond39 Using cfiCommon0
          CFI (cfiCond39) Function USB_InitSerialStringDescriptor
          CFI (cfiCond39) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond39) R10L Frame(CFA, -12)
          CFI (cfiCond39) R10H Frame(CFA, -10)
          CFI (cfiCond39) R11L Frame(CFA, -8)
          CFI (cfiCond39) R11H Frame(CFA, -6)
          CFI (cfiCond39) CFA SP+22
          CFI Block cfiPicker40 Using cfiCommon1
          CFI (cfiPicker40) NoFunction
          CFI (cfiPicker40) Picker
        CMP.B   #0xa, R13
        JC      ??USB_InitSerialStringDescriptor_1
        ADD.B   #0x30, R13
        RETA
??USB_InitSerialStringDescriptor_1:
        ADD.B   #0x37, R13
        RETA
          CFI EndBlock cfiCond38
          CFI EndBlock cfiCond39
          CFI EndBlock cfiPicker40

        RSEG CODE:CODE:REORDER:NOROOT(1)
USB_enable:
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function USB_enable
        FUNCALL USB_enable, XT2_Start
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
        MOV.W   #0x0, 0x2(SP)
        BIT.W   #0x8, &0x908
        JNC     ??USB_enable_3
        BIT.W   #0x1, &0x902
        JNC     ??USB_enable_4
        BIT.W   #0x100, &0x910
        JC      ??USB_enable_5
??USB_enable_4:
        CALLA   #?Subroutine6
??CrossCallReturnLabel_4:
        MOV.W   #0xc000, R12
        CALLA   #XT2_Start
        MOV.W   #0x117, &0x912
        MOV.W   #0x1300, &0x910
??USB_enable_1:
        MOV.W   #0x0, &0x914
        MOV.W   #0x0, 0(SP)
        JMP     ??USB_enable_6
??USB_enable_0:
        MOV.W   @SP, R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0(SP)
??USB_enable_6:
        CMP.W   #0x4e2, 0(SP)
        JNC     ??USB_enable_0
        MOV.W   0x2(SP), R15
        MOV.W   R15, R14
        ADD.W   #0x1, R14
        MOV.W   R14, 0x2(SP)
        CMP.W   #0xb, R15
        JNC     ??USB_enable_7
        CALLA   #?Subroutine7
??USB_enable_3:
        MOV.B   #0x1, R12
        JMP     ??USB_enable_8
??USB_enable_7:
        CMP.W   #0x0, &0x914
        JNE     ??USB_enable_1
        BIS.W   #0x1, &0x902
        CALLA   #?Subroutine7
??USB_enable_5:
        MOV.B   #0x0, R12
??USB_enable_8:
        ADD.W   #0x4, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock41
        REQUIRE _A_USBPWRCTL_L
        REQUIRE _A_USBCNF_L
        REQUIRE _A_USBPLLCTL_L
        REQUIRE _A_USBKEYID_L
        REQUIRE _A_USBPLLDIVB_L
        REQUIRE _A_USBPLLIR_L
//  407 }
//  408 
//  409 /*
//  410 Enables/disables various USB events.
//  411 */
//  412 BYTE USB_setEnabledEvents(WORD events)
//  413 {
//  414     wUsbEventMask = events;
//  415     return kUSB_succeed;
//  416 }
//  417 
//  418 /*
//  419 Returns which events are enabled and which are disabled.
//  420 */
//  421 WORD USB_getEnabledEvents()
//  422 {
//  423     return wUsbEventMask;
//  424 }
//  425 
//  426 /*
//  427 Reset USB-SIE and global variables.
//  428 */
//  429 BYTE USB_reset()
//  430 {
//  431     int i;
//  432     USBKEYPID = 0x9628;                   // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  433 
//  434     //reset should be on the bus after this!
//  435     bEnumerationStatus = 0x00;            // Device not enumerated yet
//  436     bFunctionSuspended = FALSE;           // Device is not in suspend mode
//  437 
//  438     bRemoteWakeup = DISABLE;
//  439 
//  440     bConfigurationNumber    = 0x00;       // device unconfigured
//  441     bInterfaceNumber        = 0x00;
//  442 
//  443     // FRSTE handling:
//  444     // Clear FRSTE in the RESRIFG interrupt service routine before re-configuring USB control registers.
//  445     // Set FRSTE at the beginning of SUSRIFG, SETUP, IEPIFG.EP0 and OEPIFG.EP0 interrupt service routines.
//  446     USBCTL = 0;                           // Function Reset Connection disable (FRSTE)
//  447 
//  448     wBytesRemainingOnIEP0   = NO_MORE_DATA;
//  449     wBytesRemainingOnOEP0   = NO_MORE_DATA;
//  450     bStatusAction           = STATUS_ACTION_NOTHING;
//  451 
//  452     //The address reset normally will be done automatically during bus function reset
//  453     USBFUNADR   =     0x00;               // reset address of USB device (unconfigured)
//  454 
//  455     /* Set settings for EP0 */
//  456     // NAK both 0 endpoints and enable endpoint 0 interrupt
//  457     tEndPoint0DescriptorBlock.bIEPBCNT = EPBCNT_NAK;
//  458     tEndPoint0DescriptorBlock.bOEPBCNT = EPBCNT_NAK;
//  459     tEndPoint0DescriptorBlock.bIEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
//  460     tEndPoint0DescriptorBlock.bOEPCNFG = EPCNF_USBIE | EPCNF_UBME | EPCNF_STALL;    // 8 byte data packet
//  461 
//  462     USBOEPIE = USB_OUTEP_INT_EN;
//  463     USBIEPIE = USB_INEP_INT_EN;
//  464 
//  465     // loop for initialization all of used enpoints
//  466     for(i=0; i < (CDC_NUM_INTERFACES + HID_NUM_INTERFACES + MSC_NUM_INTERFACES); i++)
//  467     {
//  468         BYTE edbIndex = stUsbHandle[i].edb_Index;
//  469 
//  470         /* Set settings for IEPx */
//  471         tInputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
//  472         tInputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].iep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  473         tInputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].iep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  474         tInputEndPointDescriptorBlock[edbIndex].bEPBCTX  = EPBCNT_NAK;
//  475         tInputEndPointDescriptorBlock[edbIndex].bEPBCTY  = EPBCNT_NAK;
//  476         tInputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
//  477 
//  478         /* Set settings for OEPx */
//  479         tOutputEndPointDescriptorBlock[edbIndex].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF ; //double buffering
//  480         tOutputEndPointDescriptorBlock[edbIndex].bEPBBAX  = (BYTE)(((stUsbHandle[i].oep_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  481         tOutputEndPointDescriptorBlock[edbIndex].bEPBBAY  = (BYTE)(((stUsbHandle[i].oep_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  482         tOutputEndPointDescriptorBlock[edbIndex].bEPBCTX  = 0x00;
//  483         tOutputEndPointDescriptorBlock[edbIndex].bEPBCTY  = 0x00;
//  484         tOutputEndPointDescriptorBlock[edbIndex].bEPSIZXY = MAX_PACKET_SIZE;
//  485 
//  486 #       ifdef _CDC_
//  487         /* Additional interrupt end point for CDC */
//  488         if(stUsbHandle[i].dev_Class == CDC_CLASS)
//  489         {
//  490             // The decriptor tool always generates the managemnet endpoint before the data endpoint
//  491             tInputEndPointDescriptorBlock[edbIndex-1].bEPCNF   = EPCNF_USBIE | EPCNF_UBME | EPCNF_DBUF; //double buffering
//  492             tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAX  = (BYTE)(((stUsbHandle[i].intepEP_X_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  493             tInputEndPointDescriptorBlock[edbIndex-1].bEPBBAY  = (BYTE)(((stUsbHandle[i].intepEP_Y_Buffer - START_OF_USB_BUFFER) >> 3) & 0x00ff);
//  494             tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTX  = EPBCNT_NAK;
//  495             tInputEndPointDescriptorBlock[edbIndex-1].bEPBCTY  = EPBCNT_NAK;
//  496             tInputEndPointDescriptorBlock[edbIndex-1].bEPSIZXY = MAX_PACKET_SIZE;
//  497         }
//  498 #       endif
//  499     }
//  500 
//  501 #   ifdef _HID_
//  502         HidResetData();                     // reset HID specific data structures
//  503 #   endif // _HID_
//  504 
//  505 #   ifdef _MSC_
//  506         isMSCConfigured = FALSE;
//  507         MscResetData();
//  508 #   endif
//  509 
//  510 #   ifdef _CDC_
//  511         CdcResetData();                     // reset CDC specific data structures
//  512 #   endif // _CDC_
//  513 
//  514     USBCTL = FEN;                       // enable function
//  515     USBIFG = 0;                         // make sure no interrupts are pending
//  516 
//  517     USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
//  518     USBKEYPID = 0x9600;                 // access to configuration registers disabled
//  519     return kUSB_succeed;
//  520 }
//  521 
//  522 /*
//  523 Instruct USB module to make itself available to the PC for connection, by pulling PUR high.
//  524 */
//  525 BYTE USB_connect()
//  526 {
//  527     USBKEYPID = 0x9628;   // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  528     USBCNF |= PUR_EN;     // generate rising edge on DP -> the host enumerates our device as full speed device
//  529     USBPWRCTL |= VBOFFIE; // enable interrupt VUSBoff
//  530     USBKEYPID = 0x9600;   // access to configuration registers disabled
//  531 
//  532     // after this the enumeration may take place
//  533     __no_operation();
//  534     __no_operation();
//  535     __no_operation();
//  536     __no_operation();
//  537     __no_operation();
//  538     __no_operation();
//  539     __no_operation();
//  540 
//  541     return kUSB_succeed;
//  542 }
//  543 
//  544 /*
//  545 Force a disconnect from the PC by pulling PUR low.
//  546 */
//  547 BYTE USB_disconnect()
//  548 {
//  549     USBKEYPID = 0x9628;     // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  550     USBCNF &= ~PUR_EN;      // disconnect pull up resistor - logical disconnect from HOST
//  551     USBPWRCTL &= ~VBOFFIE;  // disable interrupt VUSBoff
//  552     USBKEYPID = 0x9600;     // access to configuration registers disabled
//  553     bEnumerationStatus = 0; // not enumerated
//  554     bFunctionSuspended = FALSE;     // device is not suspended
//  555     return kUSB_succeed;
//  556 }
//  557 
//  558 /*
//  559 Force a remote wakeup of the USB host.
//  560 */
//  561 BYTE USB_forceRemoteWakeup()
//  562 {
//  563     if (bFunctionSuspended == FALSE) // device is not suspended
//  564     {
//  565         return kUSB_NotSuspended;
//  566     }
//  567     if(bRemoteWakeup == ENABLE)
//  568     {
//  569     	volatile unsigned int i;
//  570         USBCTL |= RWUP;             // USB - Device Remote Wakeup Request - this bit is self-cleaned
//  571         return kUSB_succeed;
//  572     }
//  573     return kUSB_generalError;
//  574 }
//  575 
//  576 /*
//  577 Returns the status of the USB connection.
//  578 */
//  579 BYTE USB_connectionInfo()
//  580 {
//  581     BYTE retVal = 0;
//  582     if (USBPWRCTL & USBBGVBV)
//  583     {
//  584         retVal |= kUSB_vbusPresent;
//  585     }
//  586 
//  587     if (bEnumerationStatus == ENUMERATION_COMPLETE)
//  588     {
//  589         retVal |= kUSB_Enumerated;
//  590     }
//  591 
//  592     if (USBCNF & PUR_EN)
//  593     {
//  594         retVal |= kUSB_purHigh;
//  595     }
//  596 
//  597     if (bFunctionSuspended == TRUE)
//  598     {
//  599         retVal |= kUSB_suspended;
//  600     }
//  601     else
//  602     {
//  603         retVal |= kUSB_NotSuspended;
//  604     }
//  605     return retVal;
//  606 }
//  607 
//  608 /*
//  609 Returns the state of the USB connection.
//  610 */
//  611 BYTE USB_connectionState()
//  612 {
//  613     // If no VBUS present
//  614     if (!(USBPWRCTL & USBBGVBV))
//  615     {
//  616         return ST_USB_DISCONNECTED;
//  617     }
//  618 
//  619     // If VBUS present, but PUR is low
//  620     if ((USBPWRCTL & USBBGVBV)&&(!(USBCNF & PUR_EN)))
//  621     {
//  622         return ST_USB_CONNECTED_NO_ENUM;
//  623     }
//  624 
//  625     // If VBUS present, PUR is high, and enumeration is complete, and not suspended
//  626     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  627         && (bEnumerationStatus == ENUMERATION_COMPLETE)
//  628         && (!(bFunctionSuspended == TRUE)))
//  629     {
//  630         return ST_ENUM_ACTIVE;
//  631     }
//  632 
//  633     // If VBUS present, PUR is high, and enumeration is NOT complete, and  suspended
//  634     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  635         && (!(bEnumerationStatus == ENUMERATION_COMPLETE))
//  636         && (bFunctionSuspended == TRUE))
//  637     {
//  638         return ST_NOENUM_SUSPENDED;
//  639     }
//  640 
//  641     // If VBUS present, PUR is high, and enumeration is complete, and  suspended
//  642     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  643         && (bEnumerationStatus == ENUMERATION_COMPLETE)
//  644         && (bFunctionSuspended == TRUE))
//  645     {
//  646         return ST_ENUM_SUSPENDED;
//  647     }
//  648 
//  649     // If VBUS present, PUR is high, but no enumeration yet
//  650     if ((USBPWRCTL & USBBGVBV) && (USBCNF & PUR_EN)
//  651         && (!(bEnumerationStatus == ENUMERATION_COMPLETE)))
//  652     {
//  653         return ST_ENUM_IN_PROGRESS;
//  654     }
//  655 
//  656     return ST_ERROR;
//  657 }
//  658 
//  659 //----------------------------------------------------------------------------
//  660 
//  661 BYTE USB_suspend(VOID)
//  662 {
//  663 
//  664     bFunctionSuspended  = TRUE;
//  665     USBKEYPID = 0x9628;         // set KEY and PID to 0x9628 -> access to configuration registers enabled
//  666     USBCTL |= FRSTE;            // Function Reset Connection Enable
//  667     USBIFG &= ~SUSRIFG;         // clear interrupt flag
//  668 
//  669     if(USB_DISABLE_XT_SUSPEND)
//  670     {
//  671         if (USB_PLL_XT == 2)
//  672         {
//  673             USBPLLCTL &= ~UPLLEN;         // disable PLL
//  674             UCSCTL6   |= XT2OFF;         // disable XT2
//  675         }
//  676         else
//  677         {
//  678             USBPLLCTL &= ~UPLLEN;           // disable PLL
//  679             UCSCTL6 |= XT1OFF;
//  680         }
//  681     }
//  682 
//  683     USBIE = RESRIE;             // disable USB specific interrupts (setup, suspend, reset), enable resume.
//  684                                 // If the reset occured during device in suspend, the resume-interrupt will come, after - reset interrupt
//  685     USBKEYPID = 0x9600;         // access to configuration registers disabled
//  686 
//  687     return kUSB_succeed;
//  688 }
//  689 
//  690 //----------------------------------------------------------------------------
//  691 
//  692 BYTE USB_resume(VOID)
//  693 {
//  694     USB_enable();                       // enable PLL
//  695 
//  696     USBIFG &= ~(RESRIFG | SUSRIFG);     // clear interrupt flags
//  697     USBIE = SETUPIE | RSTRIE | SUSRIE;  // enable USB specific interrupts (setup, reset, suspend)
//  698 
//  699     bFunctionSuspended  = FALSE;
//  700     return kUSB_succeed;
//  701 }
//  702 
//  703 //----------------------------------------------------------------------------
//  704 

        RSEG CODE:CODE:NOROOT(1)
//  705 VOID usbStallEndpoint0(VOID)
usbStallEndpoint0:
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function usbStallEndpoint0
//  706 {
//  707     tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
        BIS.B   #0x8, &0x920
          CFI EndBlock cfiBlock42
//  708     tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
        REQUIRE ?Subroutine1
        REQUIRE tEndPoint0DescriptorBlock
        // Fall through to label ?Subroutine1
//  709 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
          CFI Block cfiBlock43 Using cfiCommon0
          CFI NoFunction
//  710 
//  711 //----------------------------------------------------------------------------
//  712 
//  713 VOID usbClearOEP0ByteCount(VOID)
//  714 {
//  715     tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
//  716 }
//  717 
//  718 //----------------------------------------------------------------------------
//  719 
//  720 VOID usbStallOEP0(VOID)
//  721 {
//  722     // in standard USB request, there is not control write request with data stage
//  723     // control write, stall output endpoint 0
//  724     // wLength should be 0 in all cases
//  725     tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
        BIS.B   #0x8, &0x922
//  726 }
        RETA
          CFI EndBlock cfiBlock43

        RSEG CODE:CODE:NOROOT(1)
usbInvalidRequest:
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function usbInvalidRequest
        FUNCALL usbInvalidRequest, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        BIT.B   #0x1, &0x93e
        JC      ??usbInvalidRequest_0
        CALLA   #usbStallEndpoint0
??usbInvalidRequest_0:
        RETA
          CFI EndBlock cfiBlock44
        REQUIRE USBIFG

        RSEG CODE:CODE:NOROOT(1)
usbSendZeroLengthPacketOnIEP0:
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function usbSendZeroLengthPacketOnIEP0
        MOVX.W  #0xffff, &wBytesRemainingOnIEP0
        MOVX.B  #0x0, &bStatusAction
        MOV.B   #0x0, &0x921
        RETA
          CFI EndBlock cfiBlock45
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:REORDER:NOROOT(1)
usbStallOEP0:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function usbStallOEP0
        JMP     ?Subroutine1
        NOP
          CFI EndBlock cfiBlock46
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbClearOEP0ByteCount:
        REQUIRE ?Subroutine2
        REQUIRE tEndPoint0DescriptorBlock
        // Fall through to label ?Subroutine2

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiBlock47 Using cfiCommon0
          CFI NoFunction
        MOV.B   #0x0, &0x923
//  727 
//  728 //----------------------------------------------------------------------------
//  729 
//  730 VOID usbSendNextPacketOnIEP0(VOID)
//  731 {
//  732     BYTE bPacketSize,bIndex;
//  733 
//  734     // First check if there are bytes remaining to be transferred
//  735     if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
//  736     {
//  737         if(wBytesRemainingOnIEP0 > EP0_PACKET_SIZE)
//  738         {
//  739             // More bytes are remaining than will fit in one packet
//  740             // there will be More IN Stage
//  741             bPacketSize = EP0_PACKET_SIZE;
//  742             wBytesRemainingOnIEP0 -= EP0_PACKET_SIZE;
//  743             bStatusAction = STATUS_ACTION_DATA_IN;
//  744         }
//  745         else if (wBytesRemainingOnIEP0 < EP0_PACKET_SIZE)
//  746         {
//  747             // The remaining data will fit in one packet.
//  748             // This case will properly handle wBytesRemainingOnIEP0 == 0
//  749             bPacketSize = (BYTE)wBytesRemainingOnIEP0;
//  750             wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
//  751             bStatusAction = STATUS_ACTION_NOTHING;
//  752         }
//  753         else
//  754         {
//  755             bPacketSize = EP0_PACKET_SIZE;
//  756             if(bHostAskMoreDataThanAvailable == TRUE)
//  757             {
//  758                 wBytesRemainingOnIEP0 = 0;
//  759                 bStatusAction = STATUS_ACTION_DATA_IN;
//  760             }
//  761             else
//  762             {
//  763                 wBytesRemainingOnIEP0 = NO_MORE_DATA;
//  764                 bStatusAction = STATUS_ACTION_NOTHING;
//  765             }
//  766         }
//  767 
//  768         for(bIndex=0; bIndex<bPacketSize; bIndex++)
//  769         {
//  770             abIEP0Buffer[bIndex] = *pbIEP0Buffer;
//  771             pbIEP0Buffer++;
//  772         }
//  773         tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;
//  774     }
//  775     else
//  776     {
//  777         bStatusAction = STATUS_ACTION_NOTHING;
//  778     }
//  779 }
//  780 
//  781 //----------------------------------------------------------------------------
//  782 
//  783 VOID usbSendDataPacketOnEP0(PBYTE pbBuffer)
//  784 {
//  785     WORD wTemp;
//  786 
//  787     pbIEP0Buffer = pbBuffer;
//  788     wTemp = tSetupPacket.wLength;
//  789 
//  790     // Limit transfer size to wLength if needed
//  791     // this prevent USB device sending 'more than require' data back to host
//  792     if(wBytesRemainingOnIEP0 >= wTemp)
//  793     {
//  794         wBytesRemainingOnIEP0 = wTemp;
//  795         bHostAskMoreDataThanAvailable = FALSE;
//  796     }
//  797     else
//  798     {
//  799         bHostAskMoreDataThanAvailable = TRUE;
//  800     }
//  801     usbSendNextPacketOnIEP0();
//  802 }
//  803 
//  804 //----------------------------------------------------------------------------
//  805 VOID usbReceiveNextPacketOnOEP0(VOID)
//  806 {
//  807     BYTE bIndex,bByte;
//  808 
//  809     bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCNT_BYTECNT_MASK;
//  810 
//  811     if(wBytesRemainingOnOEP0 >= (WORD)bByte)
//  812     {
//  813         for(bIndex=0;bIndex<bByte;bIndex++)
//  814         {
//  815             *pbOEP0Buffer = abOEP0Buffer[bIndex];
//  816             pbOEP0Buffer++;
//  817         }
//  818         wBytesRemainingOnOEP0 -= (WORD)bByte;
//  819 
//  820         // clear the NAK bit for next packet
//  821         if(wBytesRemainingOnOEP0 > 0)
//  822         {
//  823             usbClearOEP0ByteCount();
//  824             bStatusAction = STATUS_ACTION_DATA_OUT;
//  825         }
//  826         else
//  827         {
//  828             usbStallOEP0();
//  829             bStatusAction = STATUS_ACTION_NOTHING;
//  830         }
//  831     }
//  832     else
//  833     {
//  834         usbStallOEP0();
//  835         bStatusAction = STATUS_ACTION_NOTHING;
//  836     }
//  837 }
//  838 
//  839 //----------------------------------------------------------------------------
//  840 
//  841 VOID usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
//  842 {
//  843 
//  844     pbOEP0Buffer = pbBuffer;
//  845 
//  846     wBytesRemainingOnOEP0 = tSetupPacket.wLength;
//  847     bStatusAction = STATUS_ACTION_DATA_OUT;
//  848 
//  849     usbClearOEP0ByteCount();
//  850 }
        RETA
          CFI EndBlock cfiBlock47

        RSEG CODE:CODE:NOROOT(1)
usbGetEndpointStatus:
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function usbGetEndpointStatus
        FUNCALL usbGetEndpointStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x2384, R15
        AND.B   #0xf, R15
        JNE     ??usbGetEndpointStatus_1
        CMP.B   #0x0, &0x2384
        JGE     ??usbGetEndpointStatus_2
        MOV.B   &0x920, R14
        JMP     ??usbGetEndpointStatus_0
??usbGetEndpointStatus_2:
        MOV.B   &0x922, R14
        JMP     ??usbGetEndpointStatus_0
??usbGetEndpointStatus_1:
        ADD.B   #0xff, R15
        CMP.B   #0x7, R15
        JC      ??usbGetEndpointStatus_3
        RLAM.W  #0x3, R15
        CMP.B   #0x0, &0x2384
        JGE     ??usbGetEndpointStatus_4
        MOV.B   0x23c8(R15), R14
        JMP     ??usbGetEndpointStatus_0
??usbGetEndpointStatus_4:
        MOV.B   0x2388(R15), R14
??usbGetEndpointStatus_0:
        AND.B   #0x8, R14
        MOVX.B  R14, &abUsbRequestReturnData
??usbGetEndpointStatus_3:
        MOVX.B  &abUsbRequestReturnData, R14
        RPT     #0x3
        RRUX.B  R14
        MOVX.B  R14, &abUsbRequestReturnData
        CALLA   #?Subroutine4
??CrossCallReturnLabel_0:
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock48
        REQUIRE tSetupPacket
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
//  851 
//  852 //----------------------------------------------------------------------------
//  853 
//  854 VOID usbSendZeroLengthPacketOnIEP0(VOID)
//  855 {
//  856     wBytesRemainingOnIEP0 = NO_MORE_DATA;
//  857     bStatusAction = STATUS_ACTION_NOTHING;
//  858     tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
//  859 }
//  860 
//  861 //----------------------------------------------------------------------------
//  862 
//  863 VOID usbClearEndpointFeature(VOID)
//  864 {
//  865     BYTE bEndpointNumber;
//  866 
//  867     // EP is from EP1 to EP7 while C language start from 0
//  868     bEndpointNumber = (tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM);
//  869     if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();
//  870     else
//  871     {
//  872         bEndpointNumber--;
//  873         if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
//  874         {
//  875             if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
//  876             {
//  877 #ifdef _MSC_
//  878                 if (!bMscResetRequired) {
//  879 #endif
//  880                   tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
//  881 #ifdef _MSC_
//  882                 }
//  883 #endif
//  884 #               ifdef _MSC_
//  885                     if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
//  886                     {
//  887                         MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
//  888                         bMcsCommandSupported = TRUE;
//  889                     }
//  890 #               endif
//  891             }
//  892             else
//  893             {
//  894 #ifdef _MSC_
//  895                 if (!bMscResetRequired) {
//  896 #endif
//  897                     tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF &= ~(EPCNF_STALL | EPCNF_TOGGLE );
//  898 #ifdef _MSC_
//  899                 }
//  900 #endif
//  901 #               ifdef _MSC_
//  902                     if (stUsbHandle[MSC0_INTFNUM].edb_Index == bEndpointNumber)
//  903                     {
//  904                         MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
//  905                         bMcsCommandSupported = TRUE;
//  906                     }
//  907 #               endif
//  908             }
//  909             usbSendZeroLengthPacketOnIEP0();
//  910         }
//  911     }
//  912 }
//  913 
//  914 //----------------------------------------------------------------------------
//  915 
//  916 VOID usbGetConfiguration(VOID)
//  917 {
//  918     usbClearOEP0ByteCount();                    // for status stage
//  919     wBytesRemainingOnIEP0 = 1;
//  920     usbSendDataPacketOnEP0((PBYTE)&bConfigurationNumber);
//  921 }
//  922 
//  923 //----------------------------------------------------------------------------
//  924 
//  925 VOID usbGetDeviceDescriptor(VOID)
//  926 {
//  927     usbClearOEP0ByteCount();
//  928     wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
//  929     usbSendDataPacketOnEP0((PBYTE) &abromDeviceDescriptor);
//  930 }
//  931 
//  932 //----------------------------------------------------------------------------
//  933 
//  934 VOID usbGetConfigurationDescriptor(VOID)
//  935 {
//  936     usbClearOEP0ByteCount();
//  937     wBytesRemainingOnIEP0 = sizeof(abromConfigurationDescriptorGroup);
//  938     usbSendDataPacketOnEP0((PBYTE)&abromConfigurationDescriptorGroup);
//  939 }
//  940 
//  941 //----------------------------------------------------------------------------
//  942 
//  943 VOID usbGetStringDescriptor(VOID)
//  944 {
//  945     WORD bIndex;
//  946     BYTE bVal = (BYTE)tSetupPacket.wValue;
//  947 
//  948     usbClearOEP0ByteCount();                    // for status stage
//  949 #if (USB_STR_INDEX_SERNUM != 0)
//  950 
//  951     if(bVal == 0x03)
//  952     {
//  953         wBytesRemainingOnIEP0 = abramSerialStringDescriptor[0];
//  954         usbSendDataPacketOnEP0((PBYTE)&abramSerialStringDescriptor);
//  955     }
//  956     else
//  957 #endif
//  958     {
//  959         bIndex = 0x00;
//  960         while(bVal-- >  0x00) bIndex += abromStringDescriptor[bIndex];
//  961         wBytesRemainingOnIEP0 = abromStringDescriptor[bIndex];
//  962         usbSendDataPacketOnEP0((PBYTE)&abromStringDescriptor[bIndex]);
//  963     }
//  964 }
//  965 
//  966 //----------------------------------------------------------------------------
//  967 

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond49 Using cfiCommon0
          CFI Function usbGetEndpointStatus
          CFI Conditional ??CrossCallReturnLabel_0
          CFI CFA SP+8
          CFI Block cfiCond50 Using cfiCommon0
          CFI (cfiCond50) Function usbGetInterfaceStatus
          CFI (cfiCond50) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond50) CFA SP+8
          CFI Block cfiCond51 Using cfiCommon0
          CFI (cfiCond51) Function usbGetInterface
          CFI (cfiCond51) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond51) CFA SP+8
          CFI Block cfiPicker52 Using cfiCommon1
          CFI (cfiPicker52) NoFunction
          CFI (cfiPicker52) Picker
        MOV.B   #0x0, &0x923
//  968 VOID usbGetInterface(VOID)
//  969 {
//  970 
//  971     // not fully supported, return one byte, zero
//  972     usbClearOEP0ByteCount();                    // for status stage
//  973     wBytesRemainingOnIEP0 = 0x02;
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
//  974     abUsbRequestReturnData[0] = 0x00;           // changed to report alternative setting byte
        MOVA    #abUsbRequestReturnData, R12
        RETA
          CFI EndBlock cfiCond49
          CFI EndBlock cfiCond50
          CFI EndBlock cfiCond51
          CFI EndBlock cfiPicker52

        RSEG CODE:CODE:NOROOT(1)
usbGetInterfaceStatus:
        FUNCALL usbGetInterfaceStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        REQUIRE ?Subroutine3
        REQUIRE tEndPoint0DescriptorBlock
        // Fall through to label ?Subroutine3

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiBlock53 Using cfiCommon0
          CFI NoFunction
        CALLA   #?Subroutine4
??CrossCallReturnLabel_1:
        MOV.B   #0x0, 0(R12)
//  975     abUsbRequestReturnData[1] = bInterfaceNumber;
        MOVX.B  &bInterfaceNumber, 0x1(R12)
//  976     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock53

        RSEG CODE:CODE:NOROOT(1)
usbGetDeviceStatus:
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function usbGetDeviceStatus
        FUNCALL usbGetDeviceStatus, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOVA    #abUsbRequestReturnData, R12
        BITX.B  #0x40, &abromConfigurationDescriptorGroup + 7
        JNC     ??usbGetDeviceStatus_0
        MOV.B   #0x1, 0(R12)
??usbGetDeviceStatus_0:
        CMPX.B  #0x1, &bRemoteWakeup
        JNE     ??usbGetDeviceStatus_1
        BIS.B   #0x2, 0(R12)
??usbGetDeviceStatus_1:
        MOV.B   #0x0, &0x923
        MOVX.W  #0x2, &wBytesRemainingOnIEP0
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock54
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbGetInterface:
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function usbGetInterface
        FUNCALL usbGetInterface, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        JMP     ?Subroutine3
        NOP
          CFI EndBlock cfiBlock55
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbGetStringDescriptor:
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function usbGetStringDescriptor
        FUNCALL usbGetStringDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbGetStringDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x2382, R14
        MOV.B   #0x0, &0x923
        CMP.B   #0x3, R14
        JNE     ??usbGetStringDescriptor_1
        MOVX.B  &abramSerialStringDescriptor, R15
        MOVX.W  R15, &wBytesRemainingOnIEP0
        MOVA    #abramSerialStringDescriptor, R12
        BRA     #usbSendDataPacketOnEP0
??usbGetStringDescriptor_1:
        MOV.W   #0x0, R12
        CMP.B   #0x0, &0x2382
        JNE     ??usbGetStringDescriptor_2
        JMP     ??usbGetStringDescriptor_3
??usbGetStringDescriptor_0:
        ADD.B   #0xff, R14
        MOVX.B  abromStringDescriptor(R12), R15
        ADD.W   R15, R12
??usbGetStringDescriptor_2:
        CMP.B   #0x0, R14
        JNE     ??usbGetStringDescriptor_0
??usbGetStringDescriptor_3:
        MOVX.B  abromStringDescriptor(R12), R15
        MOVX.W  R15, &wBytesRemainingOnIEP0
        ADDA    #abromStringDescriptor, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock56
        REQUIRE tSetupPacket
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbGetConfigurationDescriptor:
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function usbGetConfigurationDescriptor
        FUNCALL usbGetConfigurationDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, &0x923
        MOVX.W  #0x82, &wBytesRemainingOnIEP0
        MOVA    #abromConfigurationDescriptorGroup, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock57
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbGetDeviceDescriptor:
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function usbGetDeviceDescriptor
        FUNCALL usbGetDeviceDescriptor, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, &0x923
        MOVX.W  #0x12, &wBytesRemainingOnIEP0
        MOVA    #abromDeviceDescriptor, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock58
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbGetConfiguration:
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function usbGetConfiguration
        FUNCALL usbGetConfiguration, usbSendDataPacketOnEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, &0x923
        MOVX.W  #0x1, &wBytesRemainingOnIEP0
        MOVA    #bConfigurationNumber, R12
        BRA     #usbSendDataPacketOnEP0
          CFI EndBlock cfiBlock59
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:NOROOT(1)
usbClearEndpointFeature:
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function usbClearEndpointFeature
        FUNCALL usbClearEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x2384, R14
        AND.B   #0xf, R14
        JEQ     ??usbClearEndpointFeature_0
        ADD.B   #0xff, R14
        CMP.B   #0x7, R14
        JC      ??usbClearEndpointFeature_1
        CMP.B   #0x0, &0x2384
        JGE     ??usbClearEndpointFeature_2
        CMPX.B  #0x0, &bMscResetRequired
        JNE     ??usbClearEndpointFeature_3
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        AND.B   #0xd7, 0x23c8(R15)
??usbClearEndpointFeature_3:
        CMPX.B  R14, &stUsbHandle + 2
        JNE     ??usbClearEndpointFeature_0
        MOVX.B  #0x0, &MscReadControl + 25
        JMP     ??usbClearEndpointFeature_4
??usbClearEndpointFeature_2:
        CMPX.B  #0x0, &bMscResetRequired
        JNE     ??usbClearEndpointFeature_5
        MOV.B   R14, R15
        RLAM.W  #0x3, R15
        AND.B   #0xd7, 0x2388(R15)
??usbClearEndpointFeature_5:
        CMPX.B  R14, &stUsbHandle + 2
        JNE     ??usbClearEndpointFeature_0
        MOVX.B  #0x0, &MscWriteControl + 30
??usbClearEndpointFeature_4:
        MOVX.W  #0x1, &bMcsCommandSupported
??usbClearEndpointFeature_0:
        CALLA   #usbSendZeroLengthPacketOnIEP0
??usbClearEndpointFeature_1:
        RETA
          CFI EndBlock cfiBlock60
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock

        RSEG CODE:CODE:REORDER:NOROOT(1)
usbReceiveDataPacketOnEP0:
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function usbReceiveDataPacketOnEP0
        MOVA    R12, &pbOEP0Buffer
        MOVX.W  &0x2386, &wBytesRemainingOnOEP0
        MOVX.B  #0x2, &bStatusAction
        JMP     ?Subroutine2
        NOP
          CFI EndBlock cfiBlock61
        REQUIRE tSetupPacket
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:REORDER:NOROOT(1)
usbSendNextPacketOnIEP0:
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function usbSendNextPacketOnIEP0
        MOVA    &pbIEP0Buffer, R14
        MOVX.W  &wBytesRemainingOnIEP0, R15
        CMP.W   #0xffff, R15
        JEQ     ??usbSendNextPacketOnIEP0_2
        CMP.W   #0x9, R15
        JNC     ??usbSendNextPacketOnIEP0_3
        MOV.B   #0x8, R13
        SUB.W   #0x8, R15
        JMP     ??usbSendNextPacketOnIEP0_4
??usbSendNextPacketOnIEP0_3:
        CMP.W   #0x8, R15
        JC      ??usbSendNextPacketOnIEP0_5
        MOV.B   R15, R13
        JMP     ??usbSendNextPacketOnIEP0_1
??usbSendNextPacketOnIEP0_5:
        MOV.B   #0x8, R13
        CMPX.B  #0x1, &bHostAskMoreDataThanAvailable
        JNE     ??usbSendNextPacketOnIEP0_1
        MOV.W   #0x0, R15
??usbSendNextPacketOnIEP0_4:
        MOV.B   #0x1, R12
        JMP     ??usbSendNextPacketOnIEP0_6
??usbSendNextPacketOnIEP0_1:
        MOV.W   #0xffff, R15
        MOV.B   #0x0, R12
??usbSendNextPacketOnIEP0_6:
        MOVX.B  R12, &bStatusAction
        MOVX.W  R15, &wBytesRemainingOnIEP0
        CMP.B   #0x0, R13
        JEQ     ??usbSendNextPacketOnIEP0_7
        MOV.W   #0x2378, R15
        MOV.B   R13, R12
??usbSendNextPacketOnIEP0_0:
        MOV.B   @R14+, 0(R15)
        ADD.W   #0x1, R15
        ADD.B   #0xff, R12
        JNE     ??usbSendNextPacketOnIEP0_0
??usbSendNextPacketOnIEP0_7:
        MOV.B   R13, &0x921
        JMP     ??usbSendNextPacketOnIEP0_8
??usbSendNextPacketOnIEP0_2:
        MOVX.B  #0x0, &bStatusAction
??usbSendNextPacketOnIEP0_8:
        MOVA    R14, &pbIEP0Buffer
        RETA
          CFI EndBlock cfiBlock62
        REQUIRE abIEP0Buffer
        REQUIRE tEndPoint0DescriptorBlock

        RSEG CODE:CODE:REORDER:NOROOT(1)
usbSendDataPacketOnEP0:
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function usbSendDataPacketOnEP0
        FUNCALL usbSendDataPacketOnEP0, usbSendNextPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        MOVA    R12, &pbIEP0Buffer
        MOV.W   &0x2386, R15
        CMPX.W  R15, &wBytesRemainingOnIEP0
        JNC     ??usbSendDataPacketOnEP0_0
        MOVX.W  R15, &wBytesRemainingOnIEP0
        MOV.B   #0x0, R14
        JMP     ??usbSendDataPacketOnEP0_1
??usbSendDataPacketOnEP0_0:
        MOV.B   #0x1, R14
??usbSendDataPacketOnEP0_1:
        MOVX.B  R14, &bHostAskMoreDataThanAvailable
        BRA     #usbSendNextPacketOnIEP0
          CFI EndBlock cfiBlock63
        REQUIRE tSetupPacket

        RSEG CODE:CODE:REORDER:NOROOT(1)
usbReceiveNextPacketOnOEP0:
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function usbReceiveNextPacketOnOEP0
        FUNCALL usbReceiveNextPacketOnOEP0, usbStallOEP0
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   &0x923, R14
        AND.B   #0x7f, R14
        MOVA    &pbOEP0Buffer, R15
        MOV.B   R14, R13
        MOVA    #wBytesRemainingOnOEP0, R12
        CMP.W   R13, 0(R12)
        JNC     ??usbReceiveNextPacketOnOEP0_1
        CMP.B   #0x0, R14
        JEQ     ??usbReceiveNextPacketOnOEP0_2
        MOV.W   #0x2370, R10
??usbReceiveNextPacketOnOEP0_0:
        MOV.B   @R10+, R11
        MOV.B   R11, 0(R15)
        ADDA    #0x1, R15
        ADD.B   #0xff, R14
        JNE     ??usbReceiveNextPacketOnOEP0_0
??usbReceiveNextPacketOnOEP0_2:
        SUB.W   R13, 0(R12)
        JEQ     ??usbReceiveNextPacketOnOEP0_1
        MOV.B   #0x0, &0x923
        MOV.B   #0x2, R14
        JMP     ??usbReceiveNextPacketOnOEP0_3
??usbReceiveNextPacketOnOEP0_1:
        CALLA   #usbStallOEP0
        MOV.B   #0x0, R14
??usbReceiveNextPacketOnOEP0_3:
        MOVX.B  R14, &bStatusAction
        MOVA    R15, &pbOEP0Buffer
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock64
        REQUIRE tEndPoint0DescriptorBlock
        REQUIRE abOEP0Buffer
//  977 }
//  978 
//  979 //----------------------------------------------------------------------------
//  980 
//  981 VOID usbGetDeviceStatus(VOID)
//  982 {
//  983     if((abromConfigurationDescriptorGroup.abromConfigurationDescriptorGenric.mattributes &
//  984         CFG_DESC_ATTR_SELF_POWERED) == CFG_DESC_ATTR_SELF_POWERED)
//  985     {
//  986         abUsbRequestReturnData[0] = DEVICE_STATUS_SELF_POWER;
//  987     }
//  988     if(bRemoteWakeup == ENABLE)
//  989     {
//  990         abUsbRequestReturnData[0] |= DEVICE_STATUS_REMOTE_WAKEUP;
//  991     }
//  992     usbClearOEP0ByteCount();                    // for status stage
//  993 
//  994     // Return self power status and remote wakeup status
//  995     wBytesRemainingOnIEP0 = 2;
//  996     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
//  997 }
//  998 
//  999 //----------------------------------------------------------------------------
// 1000 
// 1001 VOID usbGetInterfaceStatus(VOID)
// 1002 {
// 1003     // check bIndexL for index number (not supported)
// 1004     usbClearOEP0ByteCount();                    // for status stage
// 1005 
// 1006     // Return two zero bytes
// 1007     wBytesRemainingOnIEP0 = 2;
// 1008     abUsbRequestReturnData[0] = 0x00;           // changed to support multiple interfaces
// 1009     abUsbRequestReturnData[1] = bInterfaceNumber;
// 1010     usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
// 1011 }
// 1012 
// 1013 //----------------------------------------------------------------------------
// 1014 
// 1015 VOID usbGetEndpointStatus(VOID)
// 1016 {
// 1017     BYTE bEndpointNumber;
// 1018 
// 1019     // Endpoint number is bIndexL
// 1020     bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
// 1021     if(bEndpointNumber == 0x00)
// 1022     {
// 1023         if((tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN) == EP_DESC_ADDR_DIR_IN)
// 1024         {
// 1025             // input endpoint 0
// 1026             abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bIEPCNFG & EPCNF_STALL);
// 1027         }
// 1028         else
// 1029         {
// 1030             // output endpoint 0
// 1031             abUsbRequestReturnData[0] = (BYTE)(tEndPoint0DescriptorBlock.bOEPCNFG & EPCNF_STALL);
// 1032         }
// 1033         abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
// 1034         usbClearOEP0ByteCount();                    // for status stage
// 1035         wBytesRemainingOnIEP0 = 0x02;
// 1036         usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
// 1037     }
// 1038     else
// 1039     {
// 1040         bEndpointNumber--;
// 1041         // EP is from EP1 to EP7 while C language start from 0
// 1042         // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
// 1043         if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
// 1044         {
// 1045             if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
// 1046             {
// 1047                 // input endpoint
// 1048                 abUsbRequestReturnData[0] = (BYTE)(tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
// 1049             }else
// 1050             {
// 1051                 // output endpoint
// 1052                 abUsbRequestReturnData[0] = (BYTE)(tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF & EPCNF_STALL);
// 1053             }
// 1054         }   // no response if endpoint is not supported.
// 1055         abUsbRequestReturnData[0] = abUsbRequestReturnData[0] >> 3; // STALL is on bit 3
// 1056         usbClearOEP0ByteCount();
// 1057         wBytesRemainingOnIEP0 = 0x02;
// 1058         usbSendDataPacketOnEP0((PBYTE)&abUsbRequestReturnData[0]);
// 1059     }
// 1060 }
// 1061 
// 1062 //----------------------------------------------------------------------------

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1063 VOID usbSetAddress(VOID)
usbSetAddress:
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function usbSetAddress
// 1064 {
// 1065     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetAddress, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetAddress, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetAddress, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1066 
// 1067     // bValueL contains device address
// 1068     if(tSetupPacket.wValue < 128)
        CMP.W   #0x80, &0x2382
        JC      ??usbSetAddress_0
// 1069     {
// 1070         // hardware will update the address after status stage
// 1071         // therefore, firmware can set the address now.
// 1072         USBFUNADR = tSetupPacket.wValue;
        MOV.B   &0x2382, &0x93f
// 1073         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1074     }
// 1075     else
// 1076     {
// 1077         usbStallEndpoint0();
??usbSetAddress_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock65
        REQUIRE tSetupPacket
        REQUIRE USBFUNADR
// 1078     }
// 1079 }
// 1080 
// 1081 //----------------------------------------------------------------------------
// 1082 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1083 VOID usbSetConfiguration(VOID)
usbSetConfiguration:
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function usbSetConfiguration
// 1084 {
// 1085     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetConfiguration, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetConfiguration, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1086 
// 1087     // configuration number is in bValueL
// 1088     // change the code if more than one configuration is supported
// 1089     bConfigurationNumber = tSetupPacket.wValue;
        MOVX.B  &0x2382, &bConfigurationNumber
// 1090     usbSendZeroLengthPacketOnIEP0();
        CALLA   #usbSendZeroLengthPacketOnIEP0
// 1091 
// 1092     if (bConfigurationNumber == 1)
        CMPX.B  #0x1, &bConfigurationNumber
        JEQ     ??usbSetConfiguration_0
        MOV.B   #0x0, R14
        JMP     ??usbSetConfiguration_1
??usbSetConfiguration_0:
        MOV.B   #0x1, R14
??usbSetConfiguration_1:
        MOVX.B  R14, &bEnumerationStatus
// 1093     {
// 1094         bEnumerationStatus = ENUMERATION_COMPLETE;      // set device as enumerated
// 1095     }
// 1096     else
// 1097     {
// 1098         bEnumerationStatus = 0; //device is not configured == config # is zero
// 1099     }
// 1100 }
        RETA
          CFI EndBlock cfiBlock66
        REQUIRE tSetupPacket
// 1101 
// 1102 //----------------------------------------------------------------------------
// 1103 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1104 VOID usbClearDeviceFeature(VOID)
usbClearDeviceFeature:
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function usbClearDeviceFeature
// 1105 {
// 1106     // bValueL contains feature selector
// 1107     if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
        FUNCALL usbClearDeviceFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbClearDeviceFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x1, &0x2382
        JNE     ??usbClearDeviceFeature_0
// 1108     {
// 1109         bRemoteWakeup = DISABLE;
        MOVX.B  #0x0, &bRemoteWakeup
// 1110         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1111     }
// 1112     else
// 1113     {
// 1114         usbStallEndpoint0();
??usbClearDeviceFeature_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock67
        REQUIRE tSetupPacket
// 1115     }
// 1116 }
// 1117 
// 1118 //----------------------------------------------------------------------------
// 1119 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1120 VOID usbSetDeviceFeature(VOID)
usbSetDeviceFeature:
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function usbSetDeviceFeature
// 1121 {
// 1122     // bValueL contains feature selector
// 1123     if(tSetupPacket.wValue == FEATURE_REMOTE_WAKEUP)
        FUNCALL usbSetDeviceFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetDeviceFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x1, &0x2382
        JNE     ??usbSetDeviceFeature_0
// 1124     {
// 1125         bRemoteWakeup = ENABLE;
        MOVX.B  #0x1, &bRemoteWakeup
// 1126         usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1127     }
// 1128     else
// 1129     {
// 1130         usbStallEndpoint0();
??usbSetDeviceFeature_0:
        BRA     #usbStallEndpoint0
          CFI EndBlock cfiBlock68
        REQUIRE tSetupPacket
// 1131     }
// 1132 }
// 1133 
// 1134 //----------------------------------------------------------------------------
// 1135 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1136 VOID usbSetEndpointFeature(VOID)
usbSetEndpointFeature:
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function usbSetEndpointFeature
// 1137 {
// 1138     BYTE bEndpointNumber;
// 1139 
// 1140     // wValue contains feature selector
// 1141     // bIndexL contains endpoint number
// 1142     // Endpoint number is in low byte of wIndex
// 1143     if(tSetupPacket.wValue == FEATURE_ENDPOINT_STALL)
        FUNCALL usbSetEndpointFeature, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetEndpointFeature, usbStallEndpoint0
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x0, &0x2382
        JNE     ??usbSetEndpointFeature_0
// 1144     {
// 1145         bEndpointNumber = tSetupPacket.wIndex & EP_DESC_ADDR_EP_NUM;
        MOV.B   &0x2384, R15
        AND.B   #0xf, R15
// 1146         if(bEndpointNumber == 0x00) usbSendZeroLengthPacketOnIEP0();  // do nothing for endpoint 0
        JEQ     ??usbSetEndpointFeature_1
// 1147         else
// 1148         {
// 1149             bEndpointNumber--;
        ADD.B   #0xff, R15
// 1150             // Firmware should NOT response if specified endpoint is not supported. (charpter 8)
// 1151             if(bEndpointNumber < MAX_ENDPOINT_NUMBER)
        CMP.B   #0x7, R15
        JC      ??usbSetEndpointFeature_2
// 1152             {
// 1153                 if(tSetupPacket.wIndex & EP_DESC_ADDR_DIR_IN)
        RLAM.W  #0x3, R15
        CMP.B   #0x0, &0x2384
        JGE     ??usbSetEndpointFeature_3
// 1154                 {
// 1155                     // input endpoint
// 1156                     tInputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
        BIS.B   #0x8, 0x23c8(R15)
        JMP     ??usbSetEndpointFeature_1
// 1157                 }
// 1158                 else
// 1159                 {
// 1160                     // output endpoint
// 1161                     tOutputEndPointDescriptorBlock[bEndpointNumber].bEPCNF |= EPCNF_STALL;
??usbSetEndpointFeature_3:
        BIS.B   #0x8, 0x2388(R15)
// 1162                 }
// 1163                 usbSendZeroLengthPacketOnIEP0();
??usbSetEndpointFeature_1:
        BRA     #usbSendZeroLengthPacketOnIEP0
// 1164             } // no response if endpoint is not supported.
// 1165         }
// 1166     }
// 1167     else
// 1168     {
// 1169         usbStallEndpoint0();
??usbSetEndpointFeature_0:
        CALLA   #usbStallEndpoint0
// 1170     }
// 1171 }
??usbSetEndpointFeature_2:
        RETA
          CFI EndBlock cfiBlock69
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
// 1172 
// 1173 //----------------------------------------------------------------------------
// 1174 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1175 VOID usbSetInterface(VOID)
usbSetInterface:
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function usbSetInterface
// 1176 {
// 1177     // bValueL contains alternative setting
// 1178     // bIndexL contains interface number
// 1179     // change code if more than one interface is supported
// 1180     usbStallOEP0();                             // control write without data stage
        FUNCALL usbSetInterface, usbStallOEP0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL usbSetInterface, usbSendZeroLengthPacketOnIEP0
        LOCFRAME CSTACK, 4, STACK
        CALLA   #usbStallOEP0
// 1181     bInterfaceNumber = tSetupPacket.wIndex;
        MOVX.B  &0x2384, &bInterfaceNumber
// 1182 #ifdef _MSC_
// 1183     tInputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
        MOVX.B  &stUsbHandle + 2, R14
        RLAM.W  #0x3, R14
        MOV.W   R14, R15
        BIC.B   #0x20, 0x23c8(R15)
// 1184     tOutputEndPointDescriptorBlock[stUsbHandle[MSC0_INTFNUM].edb_Index].bEPCNF &= ~(EPCNF_TOGGLE);
        BIC.B   #0x20, 0x2388(R14)
// 1185     MscReadControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscReadControl + 25
// 1186     MscWriteControl.bCurrentBufferXY = 0; //Set current buffer to X
        MOVX.B  #0x0, &MscWriteControl + 30
// 1187 #endif
// 1188     usbSendZeroLengthPacketOnIEP0();
        BRA     #usbSendZeroLengthPacketOnIEP0
          CFI EndBlock cfiBlock70
        REQUIRE tSetupPacket
        REQUIRE tInputEndPointDescriptorBlock
        REQUIRE tOutputEndPointDescriptorBlock
// 1189 }
// 1190 
// 1191 //----------------------------------------------------------------------------
// 1192 
// 1193 VOID usbInvalidRequest(VOID)
// 1194 {
// 1195     // check if setup overwrite is set
// 1196     // if set, do nothing since we might decode it wrong
// 1197     // setup packet buffer could be modified by hardware if another setup packet
// 1198     // was sent while we are deocding setup packet
// 1199     if ((USBIFG & STPOWIFG) == 0x00)
// 1200     {
// 1201       usbStallEndpoint0();
// 1202     }
// 1203 }
// 1204 
// 1205 typedef VOID (*tpF)(VOID);
// 1206 

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1207 BYTE usbDecodeAndProcessUsbRequest(VOID)
usbDecodeAndProcessUsbRequest:
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function usbDecodeAndProcessUsbRequest
// 1208 {
        FUNCALL usbDecodeAndProcessUsbRequest
        LOCFRAME CSTACK, 12, STACK
        FUNCALL usbDecodeAndProcessUsbRequest, USB_handleEnumCompleteEvent
        LOCFRAME CSTACK, 12, STACK
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
// 1209     BYTE  bMask,bResult,bTemp;
// 1210     const BYTE* pbUsbRequestList;
// 1211     BYTE bWakeUp = FALSE;
        MOV.B   #0x0, R10
// 1212     ptDEVICE_REQUEST ptSetupPacket = &tSetupPacket;
// 1213     BYTE  bRequestType,bRequest;
// 1214     tpF lAddrOfFunction;
// 1215 
// 1216     // point to beginning of the matrix
// 1217     pbUsbRequestList = (PBYTE)&tUsbRequestList[0];
        MOVA    #tUsbRequestList, R15
        MOV.B   &0x2380, R14
        JMP     ??usbDecodeAndProcessUsbRequest_3
// 1218 
// 1219     while(1)
// 1220     {
// 1221         bRequestType = *pbUsbRequestList++;
// 1222         bRequest     = *pbUsbRequestList++;
// 1223 
// 1224         if(((bRequestType == 0xff) && (bRequest == 0xff)) ||
// 1225             (tSetupPacket.bmRequestType == (USB_REQ_TYPE_INPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)) ||
// 1226             (tSetupPacket.bmRequestType == (USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)))
// 1227         {
// 1228             pbUsbRequestList -= 2;
// 1229             break;
// 1230         }
// 1231 
// 1232         if((bRequestType == tSetupPacket.bmRequestType) && (bRequest == tSetupPacket.bRequest))
// 1233         {
// 1234             // compare the first two
// 1235             bResult = 0xc0;
// 1236             bMask   = 0x20;
// 1237             // first two bytes matched, compare the rest
// 1238             for(bTemp = 2; bTemp < 8; bTemp++)
// 1239             {
// 1240                 if (*((BYTE*)ptSetupPacket + bTemp) == *pbUsbRequestList)
// 1241                 {
// 1242                     bResult |= bMask;
// 1243                 }
// 1244                 pbUsbRequestList++;
// 1245                 bMask = bMask >> 1;
// 1246             }
// 1247             // now we have the result
// 1248             if((*pbUsbRequestList & bResult) == *pbUsbRequestList)
// 1249             {
// 1250                 pbUsbRequestList -= 8;
// 1251                 break;
// 1252             }
// 1253             else
// 1254             {
// 1255                 pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-8);
??usbDecodeAndProcessUsbRequest_1:
        ADDA    #0x6, R15
// 1256             }
??usbDecodeAndProcessUsbRequest_3:
        MOV.B   @R15+, R13
        MOV.B   @R15+, R12
        CMP.B   #0xff, R13
        JNE     ??usbDecodeAndProcessUsbRequest_4
        CMP.B   #0xff, R12
        JEQ     ??usbDecodeAndProcessUsbRequest_5
??usbDecodeAndProcessUsbRequest_4:
        CMP.B   #0xc0, R14
        JEQ     ??usbDecodeAndProcessUsbRequest_5
        CMP.B   #0x40, R14
        JNE     ??usbDecodeAndProcessUsbRequest_6
??usbDecodeAndProcessUsbRequest_5:
        SUBA    #0x2, R15
// 1257         }
// 1258         else
// 1259         {
// 1260             pbUsbRequestList += (sizeof(tDEVICE_REQUEST_COMPARE)-2);
// 1261         }
// 1262     }
// 1263 
// 1264     // if another setup packet comes before we have the chance to process current
// 1265     // setup request, we return here without processing the request
// 1266     // this check is not necessary but still kept here to reduce response(or simulation) time
// 1267 
// 1268     if((USBIFG & STPOWIFG) != 0x00)
??usbDecodeAndProcessUsbRequest_2:
        BIT.B   #0x1, &0x93e
        JNC     ??usbDecodeAndProcessUsbRequest_7
// 1269     {
// 1270         return bWakeUp;
        MOV.B   #0x0, R12
        JMP     ??usbDecodeAndProcessUsbRequest_8
// 1271     }
??usbDecodeAndProcessUsbRequest_6:
        CMP.B   R14, R13
        JNE     ??usbDecodeAndProcessUsbRequest_9
        CMP.B   &0x2381, R12
        JNE     ??usbDecodeAndProcessUsbRequest_9
        MOV.B   #0xc0, R13
        MOV.B   #0x20, R12
        MOVA    #0x2382, R11
??usbDecodeAndProcessUsbRequest_0:
        CMP.B   @R15, 0(R11)
        JNE     ??usbDecodeAndProcessUsbRequest_10
        BIS.B   R12, R13
??usbDecodeAndProcessUsbRequest_10:
        ADDA    #0x1, R15
        RRUM.W  #0x1, R12
        ADDA    #0x1, R11
        CMPA    #0x2388, R11
        JNE     ??usbDecodeAndProcessUsbRequest_0
        MOV.B   @R15, R11
        MOV.B   R11, R12
        AND.B   R13, R12
        CMP.B   R11, R12
        JNE     ??usbDecodeAndProcessUsbRequest_1
        SUBA    #0x8, R15
        JMP     ??usbDecodeAndProcessUsbRequest_2
??usbDecodeAndProcessUsbRequest_9:
        ADDA    #0xc, R15
        JMP     ??usbDecodeAndProcessUsbRequest_3
// 1272 
// 1273     // now we found the match and jump to the function accordingly.
// 1274     lAddrOfFunction = ((tDEVICE_REQUEST_COMPARE*)pbUsbRequestList)->pUsbFunction;
??usbDecodeAndProcessUsbRequest_7:
        MOVA    0xa(R15), R11
// 1275 
// 1276     // call function
// 1277     (*lAddrOfFunction)();
        CALLA   R11
// 1278 
// 1279     // perform enumeration complete event:
// 1280     // when SetAddress was called and USBADDR is not zero
// 1281     if ((lAddrOfFunction == &usbSetAddress) && (USBFUNADR != 0))
        CMPA    #usbSetAddress, R11
        JNE     ??usbDecodeAndProcessUsbRequest_11
        CMP.B   #0x0, &0x93f
        JEQ     ??usbDecodeAndProcessUsbRequest_11
// 1282     {
// 1283         bWakeUp = USB_handleEnumCompleteEvent();
        CALLA   #USB_handleEnumCompleteEvent
        MOV.B   R12, R10
// 1284     }
// 1285     return bWakeUp;
??usbDecodeAndProcessUsbRequest_11:
        MOV.B   R10, R12
??usbDecodeAndProcessUsbRequest_8:
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock71
        REQUIRE tSetupPacket
        REQUIRE USBIFG
        REQUIRE USBFUNADR
// 1286 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1287 
// 1288 /*----------------------------------------------------------------------------+
// 1289 | End of source file                                                          |
// 1290 +----------------------------------------------------------------------------*/
// 1291 /*------------------------ Nothing Below This Line --------------------------*/
// 
// 2 200 bytes in segment CODE
//   162 bytes in segment DATA16_AN
//    34 bytes in segment DATA20_N
//    37 bytes in segment DATA20_Z
// 
// 2 200 bytes of CODE memory
//    71 bytes of DATA memory (+ 162 bytes shared)
//
//Errors: none
//Warnings: none
