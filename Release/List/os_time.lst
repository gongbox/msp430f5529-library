###############################################################################
#                                                                             #
#                                                       06/Jun/2016  16:42:34 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_time.c                        #
#    Command line  =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\os_time.c -D NDEBUG -D           #
#                     RAM_VECTOR -lC C:\Users\615\Desktop\MSP430\MSP430F5529¿ #
#                     âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\List\ -lA                 #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\ -o C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Release\Obj\             #
#                     -D__MSP430F5529__ -e --double=32 --dlib_config          #
#                     "D:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.4 Evaluation\430\LIB\DLIB\dl430xlfn.h" -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\ -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Ê #
#                     ý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\ -I C:\Users\615\Desktop\MSP430\MSP4 #
#                     30F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Drivers\src\USB\ -I       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_config\ -I                   #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_User\ -I                     #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\srcUSB\USB_API\USB_CDC_API\ -I           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_HID_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Drivers\src\USB\USB_API\USB_MSC_API\ -I          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\KEY\ -I C:\Users\615\Desktop\MSP430\MSP #
#                     430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\LED\ -I         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\12864\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\HardWare\oled\ -I      #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\inc\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\mpu6050\src\ -I                         #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\inc\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\nokia5110\src\ -I                       #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LQ_1.8_TFT\ -I                          #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\LCD_API\ -I                             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\2.2TFT\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\HardWare\delay\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\System\inc\ -I C:\Users\615\Desktop\MSP430\MSP43 #
#                     0F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\System\src\ -I             #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\User\ -I C:\Users\615\Desktop\MSP430\MSP430F5529 #
#                     ¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\User\USER\ -I                    #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CONFIG\ -I                            #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\uCOSII\App\ -I C:\Users\615\Desktop\MSP430\M #
#                     SP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\CONFIHG\    #
#                     -I C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ #
#                     \¹¤³ÌÄ£°å\Lib\uCOSII\PORT\ -I                           #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\UCOSII\CORE\ -I                              #
#                     C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Lib\FatFs\ -I C:\Users\615\Desktop\MSP430\MSP430 #
#                     F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\FatFs\option\           #
#                     --core=430X --data_model=large -Oh --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\List\os_time.lst                         #
#    Object file   =  C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤ #
#                     ³ÌÄ£°å\Release\Obj\os_time.r43                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\UCOSII\CORE\os_time.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             TIME MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TIME.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.91
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include "ucos_ii.h"

  typedef unsigned char  BOOLEAN;
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",31  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",32  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",33  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",34  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",35  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",36  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",37  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef float          FP32;                     /* Single precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",38  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef double         FP64;                     /* Double precision floating point                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",39  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_STK;                   /* Each stack entry is 16-bit wide                    */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",41  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (SR = 16 bits)  */
                         ^
"C:\Users\615\Desktop\MSP430\MSP430F5529¿âº¯Êý2.5\C°æ\¹¤³ÌÄ£°å\Lib\uCOSII\PORT\os_cpu.h",42  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          #endif
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                       DELAY TASK 'n' TICKS
     31          *
     32          * Description: This function is called to delay execution of the currently running task until the
     33          *              specified number of system ticks expires.  This, of course, directly equates to delaying
     34          *              the current task for some time to expire.  No delay will result If the specified delay is
     35          *              0.  If the specified delay is greater than 0 then, a context switch will result.
     36          *
     37          * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
     38          *                        Note that by specifying 0, the task will not be delayed.
     39          *
     40          * Returns    : none
     41          *********************************************************************************************************
     42          */
     43          

   \                                 In  segment CODE, align 2
     44          void  OSTimeDly (INT32U ticks)
   \                     OSTimeDly:
     45          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
     46              INT8U      y;
     47          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     48              OS_CPU_SR  cpu_sr = 0u;
     49          #endif
     50          
     51          
     52          
     53              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   000006   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00000C   2220         JNE     ??OSTimeDly_0
     54                  return;
     55              }
     56              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
   \   00000E   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   000014   1E20         JNE     ??OSTimeDly_0
     57                  return;
     58              }
     59              if (ticks > 0u) {                            /* 0 means no delay!                                  */
   \   000016   0F4C         MOV.W   R12, R15
   \   000018   0FDD         BIS.W   R13, R15
   \   00001A   0F93         CMP.W   #0x0, R15
   \   00001C   1A24         JEQ     ??OSTimeDly_0
     60                  OS_ENTER_CRITICAL();
   \   00001E   ........     CALLA   #OSCPUSaveSR
     61                  y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
   \   000022   ........     MOVA    &OSTCBCur, R14
   \   000026   5F4E3200     MOV.B   0x32(R14), R15
     62                  OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   00002A   ....DFCE3300 BICX.B  0x33(R14), OSRdyTbl(R15)
   \            ....        
     63                  if (OSRdyTbl[y] == 0u) {
   \   000032   ....CF93.... CMPX.B  #0x0, OSRdyTbl(R15)
   \   000038   0420         JNE     ??OSTimeDly_1
     64                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   00003A   ....D2CE3400 BICX.B  0x34(R14), &OSRdyGrp
   \            ....        
     65                  }
     66                  OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
   \                     ??OSTimeDly_1:
   \   000042   8E4A2A00     MOV.W   R10, 0x2a(R14)
   \   000046   8E4B2C00     MOV.W   R11, 0x2c(R14)
     67                  OS_EXIT_CRITICAL();
   \   00004A   ........     CALLA   #OSCPURestoreSR
     68                  OS_Sched();                              /* Find next task to run!                             */
   \   00004E   ........     CALLA   #OS_Sched
   \                     ??OSTimeDly_0:
   \   000052   1A16         POPM.A  #0x2, R11
   \   000054   1001         RETA
     69              }
     70          }
     71          /*$PAGE*/
     72          /*
     73          *********************************************************************************************************
     74          *                                     DELAY TASK FOR SPECIFIED TIME
     75          *
     76          * Description: This function is called to delay execution of the currently running task until some time
     77          *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
     78          *              MILLISECONDS instead of ticks.
     79          *
     80          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
     81          *              minutes   specifies the number of minutes (max. 59)
     82          *              seconds   specifies the number of seconds (max. 59)
     83          *              ms        specifies the number of milliseconds (max. 999)
     84          *
     85          * Returns    : OS_ERR_NONE
     86          *              OS_ERR_TIME_INVALID_MINUTES
     87          *              OS_ERR_TIME_INVALID_SECONDS
     88          *              OS_ERR_TIME_INVALID_MS
     89          *              OS_ERR_TIME_ZERO_DLY
     90          *              OS_ERR_TIME_DLY_ISR
     91          *
     92          * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
     93          *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
     94          *              set to 0.  The actual delay is rounded to the nearest tick.
     95          *********************************************************************************************************
     96          */
     97          
     98          #if OS_TIME_DLY_HMSM_EN > 0u

   \                                 In  segment CODE, align 2
     99          INT8U  OSTimeDlyHMSM (INT8U   hours,
   \                     OSTimeDlyHMSM:
    100                                INT8U   minutes,
    101                                INT8U   seconds,
    102                                INT16U  ms)
    103          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   4B4D         MOV.B   R13, R11
   \   000004   464E         MOV.B   R14, R6
   \   000006   0A4F         MOV.W   R15, R10
    104              INT32U ticks;
    105          
    106          
    107              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   000008   ....C293.... CMPX.B  #0x0, &OSIntNesting
   \   00000E   0324         JEQ     ??OSTimeDlyHMSM_0
    108                  return (OS_ERR_TIME_DLY_ISR);
   \   000010   7C405500     MOV.B   #0x55, R12
   \   000014   363C         JMP     ??OSTimeDlyHMSM_1
    109              }
    110              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
   \                     ??OSTimeDlyHMSM_0:
   \   000016   ....C293.... CMPX.B  #0x0, &OSLockNesting
   \   00001C   0324         JEQ     ??OSTimeDlyHMSM_2
    111                  return (OS_ERR_SCHED_LOCKED);
   \   00001E   7C403200     MOV.B   #0x32, R12
   \   000022   2F3C         JMP     ??OSTimeDlyHMSM_1
    112              }
    113          #if OS_ARG_CHK_EN > 0u
    114              if (hours == 0u) {
    115                  if (minutes == 0u) {
    116                      if (seconds == 0u) {
    117                          if (ms == 0u) {
    118                              return (OS_ERR_TIME_ZERO_DLY);
    119                          }
    120                      }
    121                  }
    122              }
    123              if (minutes > 59u) {
    124                  return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
    125              }
    126              if (seconds > 59u) {
    127                  return (OS_ERR_TIME_INVALID_SECONDS);
    128              }
    129              if (ms > 999u) {
    130                  return (OS_ERR_TIME_INVALID_MS);
    131              }
    132          #endif
    133                                                           /* Compute the total number of clock ticks required.. */
    134                                                           /* .. (rounded to the nearest tick)                   */
    135              ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
    136                    + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
    137              OSTimeDly(ticks);
   \                     ??OSTimeDlyHMSM_2:
   \   000024   4C4C         MOV.B   R12, R12
   \   000026   0D43         MOV.W   #0x0, R13
   \   000028   3E40100E     MOV.W   #0xe10, R14
   \   00002C   0F43         MOV.W   #0x0, R15
   \   00002E   ........     CALLA   #?Mul32
   \   000032   084C         MOV.W   R12, R8
   \   000034   094D         MOV.W   R13, R9
   \   000036   4C4B         MOV.B   R11, R12
   \   000038   0D43         MOV.W   #0x0, R13
   \   00003A   3E403C00     MOV.W   #0x3c, R14
   \   00003E   0F43         MOV.W   #0x0, R15
   \   000040   ........     CALLA   #?Mul32
   \   000044   085C         ADD.W   R12, R8
   \   000046   096D         ADDC.W  R13, R9
   \   000048   0F43         MOV.W   #0x0, R15
   \   00004A   0856         ADD.W   R6, R8
   \   00004C   0963         ADDC.W  #0x0, R9
   \   00004E   0C48         MOV.W   R8, R12
   \   000050   0D49         MOV.W   R9, R13
   \   000052   3E40E803     MOV.W   #0x3e8, R14
   \   000056   ........     CALLA   #?Mul32
   \   00005A   084C         MOV.W   R12, R8
   \   00005C   094D         MOV.W   R13, R9
   \   00005E   0C4A         MOV.W   R10, R12
   \   000060   0D43         MOV.W   #0x0, R13
   \   000062   3E40E803     MOV.W   #0x3e8, R14
   \   000066   0F43         MOV.W   #0x0, R15
   \   000068   ........     CALLA   #?Mul32
   \   00006C   3E40E803     MOV.W   #0x3e8, R14
   \   000070   0F43         MOV.W   #0x0, R15
   \   000072   ........     CALLA   #?DivMod32u
   \   000076   085C         ADD.W   R12, R8
   \   000078   0C48         MOV.W   R8, R12
   \   00007A   0D69         ADDC.W  R9, R13
   \   00007C   ........     CALLA   #OSTimeDly
    138              return (OS_ERR_NONE);
   \   000080   4C43         MOV.B   #0x0, R12
   \                     ??OSTimeDlyHMSM_1:
   \   000082   5616         POPM.A  #0x6, R11
   \   000084   1001         RETA
    139          }
    140          #endif
    141          /*$PAGE*/
    142          /*
    143          *********************************************************************************************************
    144          *                                         RESUME A DELAYED TASK
    145          *
    146          * Description: This function is used resume a task that has been delayed through a call to either
    147          *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
    148          *              task that is waiting for an event with timeout.  This would make the task look
    149          *              like a timeout occurred.
    150          *
    151          * Arguments  : prio                      specifies the priority of the task to resume
    152          *
    153          * Returns    : OS_ERR_NONE               Task has been resumed
    154          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    155          *                                        (i.e. >= OS_LOWEST_PRIO)
    156          *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
    157          *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
    158          *********************************************************************************************************
    159          */
    160          
    161          #if OS_TIME_DLY_RESUME_EN > 0u

   \                                 In  segment CODE, align 2
    162          INT8U  OSTimeDlyResume (INT8U prio)
   \                     OSTimeDlyResume:
    163          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   4A4C         MOV.B   R12, R10
    164              OS_TCB    *ptcb;
    165          #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
    166              OS_CPU_SR  cpu_sr = 0u;
    167          #endif
    168          
    169          
    170          
    171              if (prio >= OS_LOWEST_PRIO) {
   \   000004   7C903F00     CMP.B   #0x3f, R12
   \   000008   0328         JNC     ??OSTimeDlyResume_0
    172                  return (OS_ERR_PRIO_INVALID);
   \   00000A   7C402A00     MOV.B   #0x2a, R12
   \   00000E   403C         JMP     ??OSTimeDlyResume_1
    173              }
    174              OS_ENTER_CRITICAL();
   \                     ??OSTimeDlyResume_0:
   \   000010   ........     CALLA   #OSCPUSaveSR
    175              ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
   \   000014   4A06         RLAM.A  #0x2, R10
   \   000016   ....5E4A.... MOVX.A  OSTCBPrioTbl(R10), R14
    176              if (ptcb == (OS_TCB *)0) {
   \   00001C   DE03         CMPA    #0x0, R14
   \   00001E   0324         JEQ     ??OSTimeDlyResume_2
    177                  OS_EXIT_CRITICAL();
    178                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
    179              }
    180              if (ptcb == OS_TCB_RESERVED) {
   \   000020   9E000100     CMPA    #0x1, R14
   \   000024   0520         JNE     ??OSTimeDlyResume_3
    181                  OS_EXIT_CRITICAL();
   \                     ??OSTimeDlyResume_2:
   \   000026   ........     CALLA   #OSCPURestoreSR
    182                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
   \   00002A   7C404300     MOV.B   #0x43, R12
   \   00002E   303C         JMP     ??OSTimeDlyResume_1
    183              }
    184              if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
   \                     ??OSTimeDlyResume_3:
   \   000030   1F4E2A00     MOV.W   0x2a(R14), R15
   \   000034   1FDE2C00     BIS.W   0x2c(R14), R15
   \   000038   0F93         CMP.W   #0x0, R15
   \   00003A   0520         JNE     ??OSTimeDlyResume_4
    185                  OS_EXIT_CRITICAL();
   \   00003C   ........     CALLA   #OSCPURestoreSR
    186                  return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
   \   000040   7C405000     MOV.B   #0x50, R12
   \   000044   253C         JMP     ??OSTimeDlyResume_1
    187              }
    188          
    189              ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
   \                     ??OSTimeDlyResume_4:
   \   000046   8E432A00     MOV.W   #0x0, 0x2a(R14)
   \   00004A   8E432C00     MOV.W   #0x0, 0x2c(R14)
    190              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   00004E   FEB037002E00 BIT.B   #0x37, 0x2e(R14)
   \   000054   0524         JEQ     ??OSTimeDlyResume_5
    191                  ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
   \   000056   FEF0C8002E00 AND.B   #0xc8, 0x2e(R14)
    192                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
   \   00005C   5F43         MOV.B   #0x1, R15
   \   00005E   013C         JMP     ??OSTimeDlyResume_6
    193              } else {
    194                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
   \                     ??OSTimeDlyResume_5:
   \   000060   4F43         MOV.B   #0x0, R15
   \                     ??OSTimeDlyResume_6:
   \   000062   CE4F2F00     MOV.B   R15, 0x2f(R14)
    195              }
    196              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
   \   000066   FEB22E00     BIT.B   #0x8, 0x2e(R14)
   \   00006A   0F2C         JC      ??OSTimeDlyResume_7
    197                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
   \   00006C   ....D2DE3400 BISX.B  0x34(R14), &OSRdyGrp
   \            ....        
    198                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000074   5F4E3200     MOV.B   0x32(R14), R15
   \   000078   ....DFDE3300 BISX.B  0x33(R14), OSRdyTbl(R15)
   \            ....        
    199                  OS_EXIT_CRITICAL();
   \   000080   ........     CALLA   #OSCPURestoreSR
    200                  OS_Sched();                                            /* See if this is new highest priority  */
   \   000084   ........     CALLA   #OS_Sched
   \   000088   023C         JMP     ??OSTimeDlyResume_8
    201              } else {
    202                  OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
   \                     ??OSTimeDlyResume_7:
   \   00008A   ........     CALLA   #OSCPURestoreSR
    203              }
    204              return (OS_ERR_NONE);
   \                     ??OSTimeDlyResume_8:
   \   00008E   4C43         MOV.B   #0x0, R12
   \                     ??OSTimeDlyResume_1:
   \   000090   0A16         POPM.A  #0x1, R10
   \   000092   1001         RETA
    205          }
    206          #endif
    207          /*$PAGE*/
    208          /*
    209          *********************************************************************************************************
    210          *                                         GET CURRENT SYSTEM TIME
    211          *
    212          * Description: This function is used by your application to obtain the current value of the 32-bit
    213          *              counter which keeps track of the number of clock ticks.
    214          *
    215          * Arguments  : none
    216          *
    217          * Returns    : The current value of OSTime
    218          *********************************************************************************************************
    219          */
    220          
    221          #if OS_TIME_GET_SET_EN > 0u

   \                                 In  segment CODE, align 2
    222          INT32U  OSTimeGet (void)
   \                     OSTimeGet:
    223          {
   \   000000   1B14         PUSHM.A #0x2, R11
    224              INT32U     ticks;
    225          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    226              OS_CPU_SR  cpu_sr = 0u;
    227          #endif
    228          
    229          
    230          
    231              OS_ENTER_CRITICAL();
   \   000002   ........     CALLA   #OSCPUSaveSR
    232              ticks = OSTime;
   \   000006   ....1A42.... MOVX.W  &OSTime, R10
   \   00000C   ....1B42.... MOVX.W  &OSTime + 2, R11
    233              OS_EXIT_CRITICAL();
   \   000012   ........     CALLA   #OSCPURestoreSR
    234              return (ticks);
   \   000016   0C4A         MOV.W   R10, R12
   \   000018   0D4B         MOV.W   R11, R13
   \   00001A   1A16         POPM.A  #0x2, R11
   \   00001C   1001         RETA
    235          }
    236          #endif
    237          
    238          /*
    239          *********************************************************************************************************
    240          *                                            SET SYSTEM CLOCK
    241          *
    242          * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
    243          *
    244          * Arguments  : ticks      specifies the new value that OSTime needs to take.
    245          *
    246          * Returns    : none
    247          *********************************************************************************************************
    248          */
    249          
    250          #if OS_TIME_GET_SET_EN > 0u

   \                                 In  segment CODE, align 2
    251          void  OSTimeSet (INT32U ticks)
   \                     OSTimeSet:
    252          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
    253          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    254              OS_CPU_SR  cpu_sr = 0u;
    255          #endif
    256          
    257          
    258          
    259              OS_ENTER_CRITICAL();
   \   000006   ........     CALLA   #OSCPUSaveSR
    260              OSTime = ticks;
   \   00000A   ....824A.... MOVX.W  R10, &OSTime
   \   000010   ....824B.... MOVX.W  R11, &OSTime + 2
    261              OS_EXIT_CRITICAL();
   \   000016   ........     CALLA   #OSCPURestoreSR
    262          }
   \   00001A   1A16         POPM.A  #0x2, R11
   \   00001C   1001         RETA
    263          #endif
    264          	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      12  OSTimeDly
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
            12 -> OS_Sched
      28  OSTimeDlyHMSM
            28 -> OSTimeDly
       8  OSTimeDlyResume
             8 -> OSCPURestoreSR
             8 -> OSCPUSaveSR
             8 -> OS_Sched
      12  OSTimeGet
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR
      12  OSTimeSet
            12 -> OSCPURestoreSR
            12 -> OSCPUSaveSR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      86  OSTimeDly
     134  OSTimeDlyHMSM
     148  OSTimeDlyResume
      30  OSTimeGet
      30  OSTimeSet

 
 428 bytes in segment CODE
 
 428 bytes of CODE memory

Errors: none
Warnings: 11
